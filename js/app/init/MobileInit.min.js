var amdclean_website = {};
(function () {
    (function (window, undefined) {
        var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
                return new jQuery.fn.init(selector, context, rootjQuery);
            }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
                return letter.toUpperCase();
            }, completed = function () {
                document.removeEventListener('DOMContentLoaded', completed, false);
                window.removeEventListener('load', completed, false);
                jQuery.ready();
            };
        jQuery.fn = jQuery.prototype = {
            jquery: core_version,
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem;
                if (!selector) {
                    return this;
                }
                if (typeof selector === 'string') {
                    if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                        match = [
                            null,
                            selector,
                            null
                        ];
                    } else {
                        match = rquickExpr.exec(selector);
                    }
                    if (match && (match[1] || !context)) {
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    if (jQuery.isFunction(this[match])) {
                                        this[match](context[match]);
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            elem = document.getElementById(match[2]);
                            if (elem && elem.parentNode) {
                                this.length = 1;
                                this[0] = elem;
                            }
                            this.context = document;
                            this.selector = selector;
                            return this;
                        }
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);
                    } else {
                        return this.constructor(context).find(selector);
                    }
                } else if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }
                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }
                return jQuery.makeArray(selector, this);
            },
            selector: '',
            length: 0,
            toArray: function () {
                return core_slice.call(this);
            },
            get: function (num) {
                return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
            },
            pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                ret.prevObject = this;
                ret.context = this.context;
                return ret;
            },
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },
            ready: function (fn) {
                jQuery.ready.promise().done(fn);
                return this;
            },
            slice: function () {
                return this.pushStack(core_slice.apply(this, arguments));
            },
            first: function () {
                return this.eq(0);
            },
            last: function () {
                return this.eq(-1);
            },
            eq: function (i) {
                var len = this.length, j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            end: function () {
                return this.prevObject || this.constructor(null);
            },
            push: core_push,
            sort: [].sort,
            splice: [].splice
        };
        jQuery.fn.init.prototype = jQuery.fn;
        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === 'boolean') {
                deep = target;
                target = arguments[1] || {};
                i = 2;
            }
            if (typeof target !== 'object' && !jQuery.isFunction(target)) {
                target = {};
            }
            if (length === i) {
                target = this;
                --i;
            }
            for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue;
                        }
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }
                            target[name] = jQuery.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        };
        jQuery.extend({
            expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }
                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }
                return jQuery;
            },
            isReady: false,
            readyWait: 1,
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },
            ready: function (wait) {
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }
                jQuery.isReady = true;
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }
                readyList.resolveWith(document, [jQuery]);
                if (jQuery.fn.trigger) {
                    jQuery(document).trigger('ready').off('ready');
                }
            },
            isFunction: function (obj) {
                return jQuery.type(obj) === 'function';
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return obj != null && obj === obj.window;
            },
            isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
            },
            type: function (obj) {
                if (obj == null) {
                    return String(obj);
                }
                return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
            },
            isPlainObject: function (obj) {
                if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }
                try {
                    if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
                return true;
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            error: function (msg) {
                throw new Error(msg);
            },
            parseHTML: function (data, context, keepScripts) {
                if (!data || typeof data !== 'string') {
                    return null;
                }
                if (typeof context === 'boolean') {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;
                var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }
                parsed = jQuery.buildFragment([data], context, scripts);
                if (scripts) {
                    jQuery(scripts).remove();
                }
                return jQuery.merge([], parsed.childNodes);
            },
            parseJSON: JSON.parse,
            parseXML: function (data) {
                var xml, tmp;
                if (!data || typeof data !== 'string') {
                    return null;
                }
                try {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, 'text/xml');
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || xml.getElementsByTagName('parsererror').length) {
                    jQuery.error('Invalid XML: ' + data);
                }
                return xml;
            },
            noop: function () {
            },
            globalEval: function (code) {
                var script, indirect = eval;
                code = jQuery.trim(code);
                if (code) {
                    if (code.indexOf('use strict') === 1) {
                        script = document.createElement('script');
                        script.text = code;
                        document.head.appendChild(script).parentNode.removeChild(script);
                    } else {
                        indirect(code);
                    }
                }
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            },
            each: function (obj, callback, args) {
                var value, i = 0, length = obj.length, isArray = isArraylike(obj);
                if (args) {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.apply(obj[i], args);
                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.apply(obj[i], args);
                            if (value === false) {
                                break;
                            }
                        }
                    }
                } else {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.call(obj[i], i, obj[i]);
                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.call(obj[i], i, obj[i]);
                            if (value === false) {
                                break;
                            }
                        }
                    }
                }
                return obj;
            },
            trim: function (text) {
                return text == null ? '' : core_trim.call(text);
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                if (arr != null) {
                    if (isArraylike(Object(arr))) {
                        jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                    } else {
                        core_push.call(ret, arr);
                    }
                }
                return ret;
            },
            inArray: function (elem, arr, i) {
                return arr == null ? -1 : core_indexOf.call(arr, elem, i);
            },
            merge: function (first, second) {
                var l = second.length, i = first.length, j = 0;
                if (typeof l === 'number') {
                    for (; j < l; j++) {
                        first[i++] = second[j];
                    }
                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }
                first.length = i;
                return first;
            },
            grep: function (elems, callback, inv) {
                var retVal, ret = [], i = 0, length = elems.length;
                inv = !!inv;
                for (; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }
                return ret;
            },
            map: function (elems, callback, arg) {
                var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                } else {
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }
                return core_concat.apply([], ret);
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                if (typeof context === 'string') {
                    tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }
                args = core_slice.call(arguments, 2);
                proxy = function () {
                    return fn.apply(context || this, args.concat(core_slice.call(arguments)));
                };
                proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                return proxy;
            },
            access: function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0, length = elems.length, bulk = key == null;
                if (jQuery.type(key) === 'object') {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }
                } else if (value !== undefined) {
                    chainable = true;
                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }
                    if (bulk) {
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;
                        } else {
                            bulk = fn;
                            fn = function (elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }
                    if (fn) {
                        for (; i < length; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }
                return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
            },
            now: Date.now,
            swap: function (elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            }
        });
        jQuery.ready.promise = function (obj) {
            if (!readyList) {
                readyList = jQuery.Deferred();
                if (document.readyState === 'complete') {
                    setTimeout(jQuery.ready);
                } else {
                    document.addEventListener('DOMContentLoaded', completed, false);
                    window.addEventListener('load', completed, false);
                }
            }
            return readyList.promise(obj);
        };
        jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
            class2type['[object ' + name + ']'] = name.toLowerCase();
        });
        function isArraylike(obj) {
            var length = obj.length, type = jQuery.type(obj);
            if (jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.nodeType === 1 && length) {
                return true;
            }
            return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
        }
        rootjQuery = jQuery(document);
        (function (window, undefined) {
            var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    return 0;
                }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                    var i = 0, len = this.length;
                    for (; i < len; i++) {
                        if (this[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                    'ID': new RegExp('^#(' + characterEncoding + ')'),
                    'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                    'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                    'ATTR': new RegExp('^' + attributes),
                    'PSEUDO': new RegExp('^' + pseudos),
                    'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                    'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                    'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
                }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                    var high = '0x' + escaped - 65536;
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
                };
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ? function (target, els) {
                        push_native.apply(target, slice.call(els));
                    } : function (target, els) {
                        var j = target.length, i = 0;
                        while (target[j++] = els[i++]) {
                        }
                        target.length = j - 1;
                    }
                };
            }
            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                results = results || [];
                if (!selector || typeof selector !== 'string') {
                    return results;
                }
                if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                    return [];
                }
                if (documentIsHTML && !seed) {
                    if (match = rquickExpr.exec(selector)) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                elem = context.getElementById(m);
                                if (elem && elem.parentNode) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType === 9 && selector;
                        if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                            groups = tokenize(selector);
                            if (old = context.getAttribute('id')) {
                                nid = old.replace(rescape, '\\$&');
                            } else {
                                context.setAttribute('id', nid);
                            }
                            nid = '[id=\'' + nid + '\'] ';
                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + toSelector(groups[i]);
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(',');
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (!old) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
                return select(selector.replace(rtrim, '$1'), context, results, seed);
            }
            function createCache() {
                var keys = [];
                function cache(key, value) {
                    if (keys.push(key += ' ') > Expr.cacheLength) {
                        delete cache[keys.shift()];
                    }
                    return cache[key] = value;
                }
                return cache;
            }
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }
            function assert(fn) {
                var div = document.createElement('div');
                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    div = null;
                }
            }
            function addHandle(attrs, handler) {
                var arr = attrs.split('|'), i = attrs.length;
                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }
            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) {
                    return diff;
                }
                if (cur) {
                    while (cur = cur.nextSibling) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }
                return a ? 1 : -1;
            }
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === type;
                };
            }
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === 'input' || name === 'button') && elem.type === type;
                };
            }
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                        while (i--) {
                            if (seed[j = matchIndexes[i]]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }
            isXML = Sizzle.isXML = function (elem) {
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== 'HTML' : false;
            };
            support = Sizzle.support = {};
            setDocument = Sizzle.setDocument = function (node) {
                var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }
                document = doc;
                docElem = doc.documentElement;
                documentIsHTML = !isXML(doc);
                if (parent && parent.attachEvent && parent !== parent.top) {
                    parent.attachEvent('onbeforeunload', function () {
                        setDocument();
                    });
                }
                support.attributes = assert(function (div) {
                    div.className = 'i';
                    return !div.getAttribute('className');
                });
                support.getElementsByTagName = assert(function (div) {
                    div.appendChild(doc.createComment(''));
                    return !div.getElementsByTagName('*').length;
                });
                support.getElementsByClassName = assert(function (div) {
                    div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                    div.firstChild.className = 'i';
                    return div.getElementsByClassName('i').length === 2;
                });
                support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                });
                if (support.getById) {
                    Expr.find['ID'] = function (id, context) {
                        if (typeof context.getElementById !== strundefined && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m && m.parentNode ? [m] : [];
                        }
                    };
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute('id') === attrId;
                        };
                    };
                } else {
                    delete Expr.find['ID'];
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                            return node && node.value === attrId;
                        };
                    };
                }
                Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                    if (typeof context.getElementsByTagName !== strundefined) {
                        return context.getElementsByTagName(tag);
                    }
                } : function (tag, context) {
                    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                    if (tag === '*') {
                        while (elem = results[i++]) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem);
                            }
                        }
                        return tmp;
                    }
                    return results;
                };
                Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };
                rbuggyMatches = [];
                rbuggyQSA = [];
                if (support.qsa = rnative.test(doc.querySelectorAll)) {
                    assert(function (div) {
                        div.innerHTML = '<select><option selected=\'\'></option></select>';
                        if (!div.querySelectorAll('[selected]').length) {
                            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                        }
                        if (!div.querySelectorAll(':checked').length) {
                            rbuggyQSA.push(':checked');
                        }
                    });
                    assert(function (div) {
                        var input = doc.createElement('input');
                        input.setAttribute('type', 'hidden');
                        div.appendChild(input).setAttribute('t', '');
                        if (div.querySelectorAll('[t^=\'\']').length) {
                            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                        }
                        if (!div.querySelectorAll(':enabled').length) {
                            rbuggyQSA.push(':enabled', ':disabled');
                        }
                        div.querySelectorAll('*,:x');
                        rbuggyQSA.push(',.*:');
                    });
                }
                if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                    assert(function (div) {
                        support.disconnectedMatch = matches.call(div, 'div');
                        matches.call(div, '[s!=\'\']:x');
                        rbuggyMatches.push('!=', pseudos);
                    });
                }
                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
                contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
                    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                } : function (a, b) {
                    if (b) {
                        while (b = b.parentNode) {
                            if (b === a) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                sortOrder = docElem.compareDocumentPosition ? function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
                    if (compare) {
                        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                            if (a === doc || contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === doc || contains(preferredDoc, b)) {
                                return 1;
                            }
                            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                        }
                        return compare & 4 ? -1 : 1;
                    }
                    return a.compareDocumentPosition ? -1 : 1;
                } : function (a, b) {
                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    } else if (!aup || !bup) {
                        return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                    } else if (aup === bup) {
                        return siblingCheck(a, b);
                    }
                    cur = a;
                    while (cur = cur.parentNode) {
                        ap.unshift(cur);
                    }
                    cur = b;
                    while (cur = cur.parentNode) {
                        bp.unshift(cur);
                    }
                    while (ap[i] === bp[i]) {
                        i++;
                    }
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                };
                return doc;
            };
            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };
            Sizzle.matchesSelector = function (elem, expr) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                expr = expr.replace(rattributeQuotes, '=\'$1\']');
                if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                    }
                }
                return Sizzle(expr, document, null, [elem]).length > 0;
            };
            Sizzle.contains = function (context, elem) {
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };
            Sizzle.attr = function (elem, name) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
            };
            Sizzle.error = function (msg) {
                throw new Error('Syntax error, unrecognized expression: ' + msg);
            };
            Sizzle.uniqueSort = function (results) {
                var elem, duplicates = [], j = 0, i = 0;
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);
                if (hasDuplicate) {
                    while (elem = results[i++]) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }
                return results;
            };
            getText = Sizzle.getText = function (elem) {
                var node, ret = '', i = 0, nodeType = elem.nodeType;
                if (!nodeType) {
                    for (; node = elem[i]; i++) {
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                return ret;
            };
            Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    '>': {
                        dir: 'parentNode',
                        first: true
                    },
                    ' ': { dir: 'parentNode' },
                    '+': {
                        dir: 'previousSibling',
                        first: true
                    },
                    '~': { dir: 'previousSibling' }
                },
                preFilter: {
                    'ATTR': function (match) {
                        match[1] = match[1].replace(runescape, funescape);
                        match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                        if (match[2] === '~=') {
                            match[3] = ' ' + match[3] + ' ';
                        }
                        return match.slice(0, 4);
                    },
                    'CHILD': function (match) {
                        match[1] = match[1].toLowerCase();
                        if (match[1].slice(0, 3) === 'nth') {
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                            match[5] = +(match[7] + match[8] || match[3] === 'odd');
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }
                        return match;
                    },
                    'PSEUDO': function (match) {
                        var excess, unquoted = !match[5] && match[2];
                        if (matchExpr['CHILD'].test(match[0])) {
                            return null;
                        }
                        if (match[3] && match[4] !== undefined) {
                            match[2] = match[4];
                        } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }
                        return match.slice(0, 3);
                    }
                },
                filter: {
                    'TAG': function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === '*' ? function () {
                            return true;
                        } : function (elem) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                        };
                    },
                    'CLASS': function (className) {
                        var pattern = classCache[className + ' '];
                        return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                        });
                    },
                    'ATTR': function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);
                            if (result == null) {
                                return operator === '!=';
                            }
                            if (!operator) {
                                return true;
                            }
                            result += '';
                            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                        };
                    },
                    'CHILD': function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                        return first === 1 && last === 0 ? function (elem) {
                            return !!elem.parentNode;
                        } : function (elem, context, xml) {
                            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                            if (parent) {
                                if (simple) {
                                    while (dir) {
                                        node = elem;
                                        while (node = node[dir]) {
                                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                return false;
                                            }
                                        }
                                        start = dir = type === 'only' && !start && 'nextSibling';
                                    }
                                    return true;
                                }
                                start = [forward ? parent.firstChild : parent.lastChild];
                                if (forward && useCache) {
                                    outerCache = parent[expando] || (parent[expando] = {});
                                    cache = outerCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = cache[0] === dirruns && cache[2];
                                    node = nodeIndex && parent.childNodes[nodeIndex];
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                            outerCache[type] = [
                                                dirruns,
                                                nodeIndex,
                                                diff
                                            ];
                                            break;
                                        }
                                    }
                                } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                    diff = cache[1];
                                } else {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                (node[expando] || (node[expando] = {}))[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                                diff -= last;
                                return diff === first || diff % first === 0 && diff / first >= 0;
                            }
                        };
                    },
                    'PSEUDO': function (pseudo, argument) {
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                        if (fn[expando]) {
                            return fn(argument);
                        }
                        if (fn.length > 1) {
                            args = [
                                pseudo,
                                pseudo,
                                '',
                                argument
                            ];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                var idx, matched = fn(seed, argument), i = matched.length;
                                while (i--) {
                                    idx = indexOf.call(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i]);
                                }
                            }) : function (elem) {
                                return fn(elem, 0, args);
                            };
                        }
                        return fn;
                    }
                },
                pseudos: {
                    'not': markFunction(function (selector) {
                        var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                            while (i--) {
                                if (elem = unmatched[i]) {
                                    seed[i] = !(matches[i] = elem);
                                }
                            }
                        }) : function (elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            return !results.pop();
                        };
                    }),
                    'has': markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),
                    'contains': markFunction(function (text) {
                        return function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),
                    'lang': markFunction(function (lang) {
                        if (!ridentifier.test(lang || '')) {
                            Sizzle.error('unsupported lang: ' + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),
                    'target': function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },
                    'root': function (elem) {
                        return elem === docElem;
                    },
                    'focus': function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },
                    'enabled': function (elem) {
                        return elem.disabled === false;
                    },
                    'disabled': function (elem) {
                        return elem.disabled === true;
                    },
                    'checked': function (elem) {
                        var nodeName = elem.nodeName.toLowerCase();
                        return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                    },
                    'selected': function (elem) {
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }
                        return elem.selected === true;
                    },
                    'empty': function (elem) {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
                                return false;
                            }
                        }
                        return true;
                    },
                    'parent': function (elem) {
                        return !Expr.pseudos['empty'](elem);
                    },
                    'header': function (elem) {
                        return rheader.test(elem.nodeName);
                    },
                    'input': function (elem) {
                        return rinputs.test(elem.nodeName);
                    },
                    'button': function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === 'input' && elem.type === 'button' || name === 'button';
                    },
                    'text': function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
                    },
                    'first': createPositionalPseudo(function () {
                        return [0];
                    }),
                    'last': createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),
                    'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),
                    'even': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'odd': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };
            Expr.pseudos['nth'] = Expr.pseudos['eq'];
            for (i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true
                }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {
                    submit: true,
                    reset: true
                }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            function tokenize(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }
                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;
                while (soFar) {
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push(tokens = []);
                    }
                    matched = false;
                    if (match = rcombinators.exec(soFar)) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, ' ')
                        });
                        soFar = soFar.slice(matched.length);
                    }
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }
                    if (!matched) {
                        break;
                    }
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
            }
            function toSelector(tokens) {
                var i = 0, len = tokens.length, selector = '';
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }
            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
                return combinator.first ? function (elem, context, xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml);
                        }
                    }
                } : function (elem, context, xml) {
                    var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
                    if (xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                if (matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    } else {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                                    if ((data = cache[1]) === true || data === cachedruns) {
                                        return data === true;
                                    }
                                } else {
                                    cache = outerCache[dir] = [dirkey];
                                    cache[1] = matcher(elem, context, xml) || cachedruns;
                                    if (cache[1] === true) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                };
            }
            function elementMatcher(matchers) {
                return matchers.length > 1 ? function (elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false;
                        }
                    }
                    return true;
                } : matchers[0];
            }
            function condense(unmatched, map, filter, context, xml) {
                var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                for (; i < len; i++) {
                    if (elem = unmatched[i]) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }
                return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);
                        i = temp.length;
                        while (i--) {
                            if (elem = temp[i]) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if (elem = matcherOut[i]) {
                                        temp.push(matcherIn[i] = elem);
                                    }
                                }
                                postFinder(null, matcherOut = [], temp, xml);
                            }
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }
            function matcherFromTokens(tokens) {
                var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                        return indexOf.call(checkContext, elem) > -1;
                    }, implicitRelative, true), matchers = [function (elem, context, xml) {
                            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        }];
                for (; i < len; i++) {
                    if (matcher = Expr.relative[tokens[i].type]) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                        if (matcher[expando]) {
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                        }
                        matchers.push(matcher);
                    }
                }
                return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
                        var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
                        if (outermost) {
                            outermostContext = context !== document && context;
                            cachedruns = matcherCachedRuns;
                        }
                        for (; (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                while (matcher = elementMatchers[j++]) {
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    cachedruns = ++matcherCachedRuns;
                                }
                            }
                            if (bySet) {
                                if (elem = !matcher && elem) {
                                    matchedCount--;
                                }
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while (matcher = setMatchers[j++]) {
                                matcher(unmatched, setMatched, context, xml);
                            }
                            if (seed) {
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }
                                setMatched = condense(setMatched);
                            }
                            push.apply(results, setMatched);
                            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }
                        return unmatched;
                    };
                return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle.compile = function (selector, group) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
                if (!cached) {
                    if (!group) {
                        group = tokenize(selector);
                    }
                    i = group.length;
                    while (i--) {
                        cached = matcherFromTokens(group[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                }
                return cached;
            };
            function multipleContexts(selector, contexts, results) {
                var i = 0, len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }
            function select(selector, context, results, seed) {
                var i, tokens, token, type, find, match = tokenize(selector);
                if (!seed) {
                    if (match.length === 1) {
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results;
                            }
                            selector = selector.slice(tokens.shift().value.length);
                        }
                        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
                            if (Expr.relative[type = token.type]) {
                                break;
                            }
                            if (find = Expr.find[type]) {
                                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
                return results;
            }
            support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
            support.detectDuplicates = hasDuplicate;
            setDocument();
            support.sortDetached = assert(function (div1) {
                return div1.compareDocumentPosition(document.createElement('div')) & 1;
            });
            if (!assert(function (div) {
                    div.innerHTML = '<a href=\'#\'></a>';
                    return div.firstChild.getAttribute('href') === '#';
                })) {
                addHandle('type|href|height|width', function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                    }
                });
            }
            if (!support.attributes || !assert(function (div) {
                    div.innerHTML = '<input/>';
                    div.firstChild.setAttribute('value', '');
                    return div.firstChild.getAttribute('value') === '';
                })) {
                addHandle('value', function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                        return elem.defaultValue;
                    }
                });
            }
            if (!assert(function (div) {
                    return div.getAttribute('disabled') == null;
                })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
                    }
                });
            }
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[':'] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;
        }(window));
        var optionsCache = {};
        function createOptions(options) {
            var object = optionsCache[options] = {};
            jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
                object[flag] = true;
            });
            return object;
        }
        jQuery.Callbacks = function (options) {
            options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
            var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
                    memory = options.memory && data;
                    fired = true;
                    firingIndex = firingStart || 0;
                    firingStart = 0;
                    firingLength = list.length;
                    firing = true;
                    for (; list && firingIndex < firingLength; firingIndex++) {
                        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                            memory = false;
                            break;
                        }
                    }
                    firing = false;
                    if (list) {
                        if (stack) {
                            if (stack.length) {
                                fire(stack.shift());
                            }
                        } else if (memory) {
                            list = [];
                        } else {
                            self.disable();
                        }
                    }
                }, self = {
                    add: function () {
                        if (list) {
                            var start = list.length;
                            (function add(args) {
                                jQuery.each(args, function (_, arg) {
                                    var type = jQuery.type(arg);
                                    if (type === 'function') {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && type !== 'string') {
                                        add(arg);
                                    }
                                });
                            }(arguments));
                            if (firing) {
                                firingLength = list.length;
                            } else if (memory) {
                                firingStart = start;
                                fire(memory);
                            }
                        }
                        return this;
                    },
                    remove: function () {
                        if (list) {
                            jQuery.each(arguments, function (_, arg) {
                                var index;
                                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                    list.splice(index, 1);
                                    if (firing) {
                                        if (index <= firingLength) {
                                            firingLength--;
                                        }
                                        if (index <= firingIndex) {
                                            firingIndex--;
                                        }
                                    }
                                }
                            });
                        }
                        return this;
                    },
                    has: function (fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                    },
                    empty: function () {
                        list = [];
                        firingLength = 0;
                        return this;
                    },
                    disable: function () {
                        list = stack = memory = undefined;
                        return this;
                    },
                    disabled: function () {
                        return !list;
                    },
                    lock: function () {
                        stack = undefined;
                        if (!memory) {
                            self.disable();
                        }
                        return this;
                    },
                    locked: function () {
                        return !stack;
                    },
                    fireWith: function (context, args) {
                        if (list && (!fired || stack)) {
                            args = args || [];
                            args = [
                                context,
                                args.slice ? args.slice() : args
                            ];
                            if (firing) {
                                stack.push(args);
                            } else {
                                fire(args);
                            }
                        }
                        return this;
                    },
                    fire: function () {
                        self.fireWith(this, arguments);
                        return this;
                    },
                    fired: function () {
                        return !!fired;
                    }
                };
            return self;
        };
        jQuery.extend({
            Deferred: function (func) {
                var tuples = [
                        [
                            'resolve',
                            'done',
                            jQuery.Callbacks('once memory'),
                            'resolved'
                        ],
                        [
                            'reject',
                            'fail',
                            jQuery.Callbacks('once memory'),
                            'rejected'
                        ],
                        [
                            'notify',
                            'progress',
                            jQuery.Callbacks('memory')
                        ]
                    ], state = 'pending', promise = {
                        state: function () {
                            return state;
                        },
                        always: function () {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        then: function () {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                        } else {
                                            newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        promise: function (obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    }, deferred = {};
                promise.pipe = promise.then;
                jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2], stateString = tuple[3];
                    promise[tuple[1]] = list.add;
                    if (stateString) {
                        list.add(function () {
                            state = stateString;
                        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                    }
                    deferred[tuple[0]] = function () {
                        deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                        return this;
                    };
                    deferred[tuple[0] + 'With'] = list.fireWith;
                });
                promise.promise(deferred);
                if (func) {
                    func.call(deferred, deferred);
                }
                return deferred;
            },
            when: function (subordinate) {
                var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this;
                            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                            if (values === progressValues) {
                                deferred.notifyWith(contexts, values);
                            } else if (!--remaining) {
                                deferred.resolveWith(contexts, values);
                            }
                        };
                    }, progressValues, progressContexts, resolveContexts;
                if (length > 1) {
                    progressValues = new Array(length);
                    progressContexts = new Array(length);
                    resolveContexts = new Array(length);
                    for (; i < length; i++) {
                        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                        } else {
                            --remaining;
                        }
                    }
                }
                if (!remaining) {
                    deferred.resolveWith(resolveContexts, resolveValues);
                }
                return deferred.promise();
            }
        });
        jQuery.support = function (support) {
            var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
            if (!input.type) {
                return support;
            }
            input.type = 'checkbox';
            support.checkOn = input.value !== '';
            support.optSelected = opt.selected;
            support.reliableMarginRight = true;
            support.boxSizingReliable = true;
            support.pixelPosition = false;
            input.checked = true;
            support.noCloneChecked = input.cloneNode(true).checked;
            select.disabled = true;
            support.optDisabled = !opt.disabled;
            input = document.createElement('input');
            input.value = 't';
            input.type = 'radio';
            support.radioValue = input.value === 't';
            input.setAttribute('checked', 't');
            input.setAttribute('name', 't');
            fragment.appendChild(input);
            support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
            support.focusinBubbles = 'onfocusin' in window;
            div.style.backgroundClip = 'content-box';
            div.cloneNode(true).style.backgroundClip = '';
            support.clearCloneStyle = div.style.backgroundClip === 'content-box';
            jQuery(function () {
                var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                container = document.createElement('div');
                container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
                body.appendChild(container).appendChild(div);
                div.innerHTML = '';
                div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
                jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                    support.boxSizing = div.offsetWidth === 4;
                });
                if (window.getComputedStyle) {
                    support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
                    support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
                    marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                }
                body.removeChild(container);
            });
            return support;
        }({});
        var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
        function Data() {
            Object.defineProperty(this.cache = {}, 0, {
                get: function () {
                    return {};
                }
            });
            this.expando = jQuery.expando + Math.random();
        }
        Data.uid = 1;
        Data.accepts = function (owner) {
            return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
        };
        Data.prototype = {
            key: function (owner) {
                if (!Data.accepts(owner)) {
                    return 0;
                }
                var descriptor = {}, unlock = owner[this.expando];
                if (!unlock) {
                    unlock = Data.uid++;
                    try {
                        descriptor[this.expando] = { value: unlock };
                        Object.defineProperties(owner, descriptor);
                    } catch (e) {
                        descriptor[this.expando] = unlock;
                        jQuery.extend(owner, descriptor);
                    }
                }
                if (!this.cache[unlock]) {
                    this.cache[unlock] = {};
                }
                return unlock;
            },
            set: function (owner, data, value) {
                var prop, unlock = this.key(owner), cache = this.cache[unlock];
                if (typeof data === 'string') {
                    cache[data] = value;
                } else {
                    if (jQuery.isEmptyObject(cache)) {
                        jQuery.extend(this.cache[unlock], data);
                    } else {
                        for (prop in data) {
                            cache[prop] = data[prop];
                        }
                    }
                }
                return cache;
            },
            get: function (owner, key) {
                var cache = this.cache[this.key(owner)];
                return key === undefined ? cache : cache[key];
            },
            access: function (owner, key, value) {
                var stored;
                if (key === undefined || key && typeof key === 'string' && value === undefined) {
                    stored = this.get(owner, key);
                    return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
                }
                this.set(owner, key, value);
                return value !== undefined ? value : key;
            },
            remove: function (owner, key) {
                var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
                if (key === undefined) {
                    this.cache[unlock] = {};
                } else {
                    if (jQuery.isArray(key)) {
                        name = key.concat(key.map(jQuery.camelCase));
                    } else {
                        camel = jQuery.camelCase(key);
                        if (key in cache) {
                            name = [
                                key,
                                camel
                            ];
                        } else {
                            name = camel;
                            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
                        }
                    }
                    i = name.length;
                    while (i--) {
                        delete cache[name[i]];
                    }
                }
            },
            hasData: function (owner) {
                return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
            },
            discard: function (owner) {
                if (owner[this.expando]) {
                    delete this.cache[owner[this.expando]];
                }
            }
        };
        data_user = new Data();
        data_priv = new Data();
        jQuery.extend({
            acceptData: Data.accepts,
            hasData: function (elem) {
                return data_user.hasData(elem) || data_priv.hasData(elem);
            },
            data: function (elem, name, data) {
                return data_user.access(elem, name, data);
            },
            removeData: function (elem, name) {
                data_user.remove(elem, name);
            },
            _data: function (elem, name, data) {
                return data_priv.access(elem, name, data);
            },
            _removeData: function (elem, name) {
                data_priv.remove(elem, name);
            }
        });
        jQuery.fn.extend({
            data: function (key, value) {
                var attrs, name, elem = this[0], i = 0, data = null;
                if (key === undefined) {
                    if (this.length) {
                        data = data_user.get(elem);
                        if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
                            attrs = elem.attributes;
                            for (; i < attrs.length; i++) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                            data_priv.set(elem, 'hasDataAttrs', true);
                        }
                    }
                    return data;
                }
                if (typeof key === 'object') {
                    return this.each(function () {
                        data_user.set(this, key);
                    });
                }
                return jQuery.access(this, function (value) {
                    var data, camelKey = jQuery.camelCase(key);
                    if (elem && value === undefined) {
                        data = data_user.get(elem, key);
                        if (data !== undefined) {
                            return data;
                        }
                        data = data_user.get(elem, camelKey);
                        if (data !== undefined) {
                            return data;
                        }
                        data = dataAttr(elem, camelKey, undefined);
                        if (data !== undefined) {
                            return data;
                        }
                        return;
                    }
                    this.each(function () {
                        var data = data_user.get(this, camelKey);
                        data_user.set(this, camelKey, value);
                        if (key.indexOf('-') !== -1 && data !== undefined) {
                            data_user.set(this, key, value);
                        }
                    });
                }, null, value, arguments.length > 1, null, true);
            },
            removeData: function (key) {
                return this.each(function () {
                    data_user.remove(this, key);
                });
            }
        });
        function dataAttr(elem, key, data) {
            var name;
            if (data === undefined && elem.nodeType === 1) {
                name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
                data = elem.getAttribute(name);
                if (typeof data === 'string') {
                    try {
                        data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
                    } catch (e) {
                    }
                    data_user.set(elem, key, data);
                } else {
                    data = undefined;
                }
            }
            return data;
        }
        jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                if (elem) {
                    type = (type || 'fx') + 'queue';
                    queue = data_priv.get(elem, type);
                    if (data) {
                        if (!queue || jQuery.isArray(data)) {
                            queue = data_priv.access(elem, type, jQuery.makeArray(data));
                        } else {
                            queue.push(data);
                        }
                    }
                    return queue || [];
                }
            },
            dequeue: function (elem, type) {
                type = type || 'fx';
                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                        jQuery.dequeue(elem, type);
                    };
                if (fn === 'inprogress') {
                    fn = queue.shift();
                    startLength--;
                }
                if (fn) {
                    if (type === 'fx') {
                        queue.unshift('inprogress');
                    }
                    delete hooks.stop;
                    fn.call(elem, next, hooks);
                }
                if (!startLength && hooks) {
                    hooks.empty.fire();
                }
            },
            _queueHooks: function (elem, type) {
                var key = type + 'queueHooks';
                return data_priv.get(elem, key) || data_priv.access(elem, key, {
                    empty: jQuery.Callbacks('once memory').add(function () {
                        data_priv.remove(elem, [
                            type + 'queue',
                            key
                        ]);
                    })
                });
            }
        });
        jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                if (typeof type !== 'string') {
                    data = type;
                    type = 'fx';
                    setter--;
                }
                if (arguments.length < setter) {
                    return jQuery.queue(this[0], type);
                }
                return data === undefined ? this : this.each(function () {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type);
                    if (type === 'fx' && queue[0] !== 'inprogress') {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type);
                });
            },
            delay: function (time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || 'fx';
                return this.queue(type, function (next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function () {
                        clearTimeout(timeout);
                    };
                });
            },
            clearQueue: function (type) {
                return this.queue(type || 'fx', []);
            },
            promise: function (type, obj) {
                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                        if (!--count) {
                            defer.resolveWith(elements, [elements]);
                        }
                    };
                if (typeof type !== 'string') {
                    obj = type;
                    type = undefined;
                }
                type = type || 'fx';
                while (i--) {
                    tmp = data_priv.get(elements[i], type + 'queueHooks');
                    if (tmp && tmp.empty) {
                        count++;
                        tmp.empty.add(resolve);
                    }
                }
                resolve();
                return defer.promise(obj);
            }
        });
        var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
        jQuery.fn.extend({
            attr: function (name, value) {
                return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name);
                });
            },
            prop: function (name, value) {
                return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name];
                });
            },
            addClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).addClass(value.call(this, j, this.className));
                    });
                }
                if (proceed) {
                    classes = (value || '').match(core_rnotwhite) || [];
                    for (; i < len; i++) {
                        elem = this[i];
                        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                    cur += clazz + ' ';
                                }
                            }
                            elem.className = jQuery.trim(cur);
                        }
                    }
                }
                return this;
            },
            removeClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).removeClass(value.call(this, j, this.className));
                    });
                }
                if (proceed) {
                    classes = (value || '').match(core_rnotwhite) || [];
                    for (; i < len; i++) {
                        elem = this[i];
                        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                    cur = cur.replace(' ' + clazz + ' ', ' ');
                                }
                            }
                            elem.className = value ? jQuery.trim(cur) : '';
                        }
                    }
                }
                return this;
            },
            toggleClass: function (value, stateVal) {
                var type = typeof value;
                if (typeof stateVal === 'boolean' && type === 'string') {
                    return stateVal ? this.addClass(value) : this.removeClass(value);
                }
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                    });
                }
                return this.each(function () {
                    if (type === 'string') {
                        var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
                        while (className = classNames[i++]) {
                            if (self.hasClass(className)) {
                                self.removeClass(className);
                            } else {
                                self.addClass(className);
                            }
                        }
                    } else if (type === core_strundefined || type === 'boolean') {
                        if (this.className) {
                            data_priv.set(this, '__className__', this.className);
                        }
                        this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
                    }
                });
            },
            hasClass: function (selector) {
                var className = ' ' + selector + ' ', i = 0, l = this.length;
                for (; i < l; i++) {
                    if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                        return true;
                    }
                }
                return false;
            },
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0];
                if (!arguments.length) {
                    if (elem) {
                        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                        if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                            return ret;
                        }
                        ret = elem.value;
                        return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                    }
                    return;
                }
                isFunction = jQuery.isFunction(value);
                return this.each(function (i) {
                    var val;
                    if (this.nodeType !== 1) {
                        return;
                    }
                    if (isFunction) {
                        val = value.call(this, i, jQuery(this).val());
                    } else {
                        val = value;
                    }
                    if (val == null) {
                        val = '';
                    } else if (typeof val === 'number') {
                        val += '';
                    } else if (jQuery.isArray(val)) {
                        val = jQuery.map(val, function (value) {
                            return value == null ? '' : value + '';
                        });
                    }
                    hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                    if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                        this.value = val;
                    }
                });
            }
        });
        jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        var val = elem.attributes.value;
                        return !val || val.specified ? elem.value : elem.text;
                    }
                },
                select: {
                    get: function (elem) {
                        var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                        for (; i < max; i++) {
                            option = options[i];
                            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                                value = jQuery(option).val();
                                if (one) {
                                    return value;
                                }
                                values.push(value);
                            }
                        }
                        return values;
                    },
                    set: function (elem, value) {
                        var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                        while (i--) {
                            option = options[i];
                            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
                                optionSet = true;
                            }
                        }
                        if (!optionSet) {
                            elem.selectedIndex = -1;
                        }
                        return values;
                    }
                }
            },
            attr: function (elem, name, value) {
                var hooks, ret, nType = elem.nodeType;
                if (!elem || nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                if (typeof elem.getAttribute === core_strundefined) {
                    return jQuery.prop(elem, name, value);
                }
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    name = name.toLowerCase();
                    hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                }
                if (value !== undefined) {
                    if (value === null) {
                        jQuery.removeAttr(elem, name);
                    } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    } else {
                        elem.setAttribute(name, value + '');
                        return value;
                    }
                } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                } else {
                    ret = jQuery.find.attr(elem, name);
                    return ret == null ? undefined : ret;
                }
            },
            removeAttr: function (elem, value) {
                var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
                if (attrNames && elem.nodeType === 1) {
                    while (name = attrNames[i++]) {
                        propName = jQuery.propFix[name] || name;
                        if (jQuery.expr.match.bool.test(name)) {
                            elem[propName] = false;
                        }
                        elem.removeAttribute(name);
                    }
                }
            },
            attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                            var val = elem.value;
                            elem.setAttribute('type', value);
                            if (val) {
                                elem.value = val;
                            }
                            return value;
                        }
                    }
                }
            },
            propFix: {
                'for': 'htmlFor',
                'class': 'className'
            },
            prop: function (elem, name, value) {
                var ret, hooks, notxml, nType = elem.nodeType;
                if (!elem || nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
                if (notxml) {
                    name = jQuery.propFix[name] || name;
                    hooks = jQuery.propHooks[name];
                }
                if (value !== undefined) {
                    return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
                } else {
                    return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
                }
            },
            propHooks: {
                tabIndex: {
                    get: function (elem) {
                        return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                    }
                }
            }
        });
        boolHook = {
            set: function (elem, value, name) {
                if (value === false) {
                    jQuery.removeAttr(elem, name);
                } else {
                    elem.setAttribute(name, name);
                }
                return name;
            }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
            var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
            jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
                var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
                jQuery.expr.attrHandle[name] = fn;
                return ret;
            };
        });
        if (!jQuery.support.optSelected) {
            jQuery.propHooks.selected = {
                get: function (elem) {
                    var parent = elem.parentNode;
                    if (parent && parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                    return null;
                }
            };
        }
        jQuery.each([
            'tabIndex',
            'readOnly',
            'maxLength',
            'cellSpacing',
            'cellPadding',
            'rowSpan',
            'colSpan',
            'useMap',
            'frameBorder',
            'contentEditable'
        ], function () {
            jQuery.propFix[this.toLowerCase()] = this;
        });
        jQuery.each([
            'radio',
            'checkbox'
        ], function () {
            jQuery.valHooks[this] = {
                set: function (elem, value) {
                    if (jQuery.isArray(value)) {
                        return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                    }
                }
            };
            if (!jQuery.support.checkOn) {
                jQuery.valHooks[this].get = function (elem) {
                    return elem.getAttribute('value') === null ? 'on' : elem.value;
                };
            }
        });
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
        function returnTrue() {
            return true;
        }
        function returnFalse() {
            return false;
        }
        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch (err) {
            }
        }
        jQuery.event = {
            global: {},
            add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                if (!elemData) {
                    return;
                }
                if (handler.handler) {
                    handleObjIn = handler;
                    handler = handleObjIn.handler;
                    selector = handleObjIn.selector;
                }
                if (!handler.guid) {
                    handler.guid = jQuery.guid++;
                }
                if (!(events = elemData.events)) {
                    events = elemData.events = {};
                }
                if (!(eventHandle = elemData.handle)) {
                    eventHandle = elemData.handle = function (e) {
                        return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                    };
                    eventHandle.elem = elem;
                }
                types = (types || '').match(core_rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    if (!type) {
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    special = jQuery.event.special[type] || {};
                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join('.')
                    }, handleObjIn);
                    if (!(handlers = events[type])) {
                        handlers = events[type] = [];
                        handlers.delegateCount = 0;
                        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                            if (elem.addEventListener) {
                                elem.addEventListener(type, eventHandle, false);
                            }
                        }
                    }
                    if (special.add) {
                        special.add.call(elem, handleObj);
                        if (!handleObj.handler.guid) {
                            handleObj.handler.guid = handler.guid;
                        }
                    }
                    if (selector) {
                        handlers.splice(handlers.delegateCount++, 0, handleObj);
                    } else {
                        handlers.push(handleObj);
                    }
                    jQuery.event.global[type] = true;
                }
                elem = null;
            },
            remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                if (!elemData || !(events = elemData.events)) {
                    return;
                }
                types = (types || '').match(core_rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    if (!type) {
                        for (type in events) {
                            jQuery.event.remove(elem, type + types[t], handler, selector, true);
                        }
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    handlers = events[type] || [];
                    tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                    origCount = j = handlers.length;
                    while (j--) {
                        handleObj = handlers[j];
                        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                            handlers.splice(j, 1);
                            if (handleObj.selector) {
                                handlers.delegateCount--;
                            }
                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }
                    }
                    if (origCount && !handlers.length) {
                        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                            jQuery.removeEvent(elem, type, elemData.handle);
                        }
                        delete events[type];
                    }
                }
                if (jQuery.isEmptyObject(events)) {
                    delete elemData.handle;
                    data_priv.remove(elem, 'events');
                }
            },
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
                cur = tmp = elem = elem || document;
                if (elem.nodeType === 3 || elem.nodeType === 8) {
                    return;
                }
                if (rfocusMorph.test(type + jQuery.event.triggered)) {
                    return;
                }
                if (type.indexOf('.') >= 0) {
                    namespaces = type.split('.');
                    type = namespaces.shift();
                    namespaces.sort();
                }
                ontype = type.indexOf(':') < 0 && 'on' + type;
                event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join('.');
                event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
                event.result = undefined;
                if (!event.target) {
                    event.target = elem;
                }
                data = data == null ? [event] : jQuery.makeArray(data, [event]);
                special = jQuery.event.special[type] || {};
                if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                    return;
                }
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    bubbleType = special.delegateType || type;
                    if (!rfocusMorph.test(bubbleType + type)) {
                        cur = cur.parentNode;
                    }
                    for (; cur; cur = cur.parentNode) {
                        eventPath.push(cur);
                        tmp = cur;
                    }
                    if (tmp === (elem.ownerDocument || document)) {
                        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                    }
                }
                i = 0;
                while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                    event.type = i > 1 ? bubbleType : special.bindType || type;
                    handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
                    if (handle) {
                        handle.apply(cur, data);
                    }
                    handle = ontype && cur[ontype];
                    if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                        event.preventDefault();
                    }
                }
                event.type = type;
                if (!onlyHandlers && !event.isDefaultPrevented()) {
                    if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                        if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                            tmp = elem[ontype];
                            if (tmp) {
                                elem[ontype] = null;
                            }
                            jQuery.event.triggered = type;
                            elem[type]();
                            jQuery.event.triggered = undefined;
                            if (tmp) {
                                elem[ontype] = tmp;
                            }
                        }
                    }
                }
                return event.result;
            },
            dispatch: function (event) {
                event = jQuery.event.fix(event);
                var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                args[0] = event;
                event.delegateTarget = this;
                if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                    return;
                }
                handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                i = 0;
                while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                    event.currentTarget = matched.elem;
                    j = 0;
                    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                        if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                            event.handleObj = handleObj;
                            event.data = handleObj.data;
                            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                            if (ret !== undefined) {
                                if ((event.result = ret) === false) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            }
                        }
                    }
                }
                if (special.postDispatch) {
                    special.postDispatch.call(this, event);
                }
                return event.result;
            },
            handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                    for (; cur !== this; cur = cur.parentNode || this) {
                        if (cur.disabled !== true || event.type !== 'click') {
                            matches = [];
                            for (i = 0; i < delegateCount; i++) {
                                handleObj = handlers[i];
                                sel = handleObj.selector + ' ';
                                if (matches[sel] === undefined) {
                                    matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                                }
                                if (matches[sel]) {
                                    matches.push(handleObj);
                                }
                            }
                            if (matches.length) {
                                handlerQueue.push({
                                    elem: cur,
                                    handlers: matches
                                });
                            }
                        }
                    }
                }
                if (delegateCount < handlers.length) {
                    handlerQueue.push({
                        elem: this,
                        handlers: handlers.slice(delegateCount)
                    });
                }
                return handlerQueue;
            },
            props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
            fixHooks: {},
            keyHooks: {
                props: 'char charCode key keyCode'.split(' '),
                filter: function (event, original) {
                    if (event.which == null) {
                        event.which = original.charCode != null ? original.charCode : original.keyCode;
                    }
                    return event;
                }
            },
            mouseHooks: {
                props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
                filter: function (event, original) {
                    var eventDoc, doc, body, button = original.button;
                    if (event.pageX == null && original.clientX != null) {
                        eventDoc = event.target.ownerDocument || document;
                        doc = eventDoc.documentElement;
                        body = eventDoc.body;
                        event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                        event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                    }
                    if (!event.which && button !== undefined) {
                        event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                    }
                    return event;
                }
            },
            fix: function (event) {
                if (event[jQuery.expando]) {
                    return event;
                }
                var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
                if (!fixHook) {
                    this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                }
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                event = new jQuery.Event(originalEvent);
                i = copy.length;
                while (i--) {
                    prop = copy[i];
                    event[prop] = originalEvent[prop];
                }
                if (!event.target) {
                    event.target = document;
                }
                if (event.target.nodeType === 3) {
                    event.target = event.target.parentNode;
                }
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
            },
            special: {
                load: { noBubble: true },
                focus: {
                    trigger: function () {
                        if (this !== safeActiveElement() && this.focus) {
                            this.focus();
                            return false;
                        }
                    },
                    delegateType: 'focusin'
                },
                blur: {
                    trigger: function () {
                        if (this === safeActiveElement() && this.blur) {
                            this.blur();
                            return false;
                        }
                    },
                    delegateType: 'focusout'
                },
                click: {
                    trigger: function () {
                        if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                            this.click();
                            return false;
                        }
                    },
                    _default: function (event) {
                        return jQuery.nodeName(event.target, 'a');
                    }
                },
                beforeunload: {
                    postDispatch: function (event) {
                        if (event.result !== undefined) {
                            event.originalEvent.returnValue = event.result;
                        }
                    }
                }
            },
            simulate: function (type, elem, event, bubble) {
                var e = jQuery.extend(new jQuery.Event(), event, {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    });
                if (bubble) {
                    jQuery.event.trigger(e, null, elem);
                } else {
                    jQuery.event.dispatch.call(elem, e);
                }
                if (e.isDefaultPrevented()) {
                    event.preventDefault();
                }
            }
        };
        jQuery.removeEvent = function (elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
            }
        };
        jQuery.Event = function (src, props) {
            if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props);
            }
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
            } else {
                this.type = src;
            }
            if (props) {
                jQuery.extend(this, props);
            }
            this.timeStamp = src && src.timeStamp || jQuery.now();
            this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue;
                if (e && e.preventDefault) {
                    e.preventDefault();
                }
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue;
                if (e && e.stopPropagation) {
                    e.stopPropagation();
                }
            },
            stopImmediatePropagation: function () {
                this.isImmediatePropagationStopped = returnTrue;
                this.stopPropagation();
            }
        };
        jQuery.each({
            mouseenter: 'mouseover',
            mouseleave: 'mouseout'
        }, function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function (event) {
                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                    if (!related || related !== target && !jQuery.contains(target, related)) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply(this, arguments);
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });
        if (!jQuery.support.focusinBubbles) {
            jQuery.each({
                focus: 'focusin',
                blur: 'focusout'
            }, function (orig, fix) {
                var attaches = 0, handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };
                jQuery.event.special[fix] = {
                    setup: function () {
                        if (attaches++ === 0) {
                            document.addEventListener(orig, handler, true);
                        }
                    },
                    teardown: function () {
                        if (--attaches === 0) {
                            document.removeEventListener(orig, handler, true);
                        }
                    }
                };
            });
        }
        jQuery.fn.extend({
            on: function (types, selector, data, fn, one) {
                var origFn, type;
                if (typeof types === 'object') {
                    if (typeof selector !== 'string') {
                        data = data || selector;
                        selector = undefined;
                    }
                    for (type in types) {
                        this.on(type, selector, data, types[type], one);
                    }
                    return this;
                }
                if (data == null && fn == null) {
                    fn = selector;
                    data = selector = undefined;
                } else if (fn == null) {
                    if (typeof selector === 'string') {
                        fn = data;
                        data = undefined;
                    } else {
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if (fn === false) {
                    fn = returnFalse;
                } else if (!fn) {
                    return this;
                }
                if (one === 1) {
                    origFn = fn;
                    fn = function (event) {
                        jQuery().off(event);
                        return origFn.apply(this, arguments);
                    };
                    fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                }
                return this.each(function () {
                    jQuery.event.add(this, types, fn, data, selector);
                });
            },
            one: function (types, selector, data, fn) {
                return this.on(types, selector, data, fn, 1);
            },
            off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) {
                    handleObj = types.handleObj;
                    jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                    return this;
                }
                if (typeof types === 'object') {
                    for (type in types) {
                        this.off(type, selector, types[type]);
                    }
                    return this;
                }
                if (selector === false || typeof selector === 'function') {
                    fn = selector;
                    selector = undefined;
                }
                if (fn === false) {
                    fn = returnFalse;
                }
                return this.each(function () {
                    jQuery.event.remove(this, types, fn, selector);
                });
            },
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this);
                });
            },
            triggerHandler: function (type, data) {
                var elem = this[0];
                if (elem) {
                    return jQuery.event.trigger(type, data, elem, true);
                }
            }
        });
        var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
        jQuery.fn.extend({
            find: function (selector) {
                var i, ret = [], self = this, len = self.length;
                if (typeof selector !== 'string') {
                    return this.pushStack(jQuery(selector).filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    }));
                }
                for (i = 0; i < len; i++) {
                    jQuery.find(selector, self[i], ret);
                }
                ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                ret.selector = this.selector ? this.selector + ' ' + selector : selector;
                return ret;
            },
            has: function (target) {
                var targets = jQuery(target, this), l = targets.length;
                return this.filter(function () {
                    var i = 0;
                    for (; i < l; i++) {
                        if (jQuery.contains(this, targets[i])) {
                            return true;
                        }
                    }
                });
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], true));
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], false));
            },
            is: function (selector) {
                return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
            },
            closest: function (selectors, context) {
                var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            cur = matched.push(cur);
                            break;
                        }
                    }
                }
                return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
            },
            index: function (elem) {
                if (!elem) {
                    return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                }
                if (typeof elem === 'string') {
                    return core_indexOf.call(jQuery(elem), this[0]);
                }
                return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
            },
            add: function (selector, context) {
                var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
                return this.pushStack(jQuery.unique(all));
            },
            addBack: function (selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            }
        });
        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {
            }
            return cur;
        }
        jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
                return jQuery.dir(elem, 'parentNode');
            },
            parentsUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'parentNode', until);
            },
            next: function (elem) {
                return sibling(elem, 'nextSibling');
            },
            prev: function (elem) {
                return sibling(elem, 'previousSibling');
            },
            nextAll: function (elem) {
                return jQuery.dir(elem, 'nextSibling');
            },
            prevAll: function (elem) {
                return jQuery.dir(elem, 'previousSibling');
            },
            nextUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'nextSibling', until);
            },
            prevUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'previousSibling', until);
            },
            siblings: function (elem) {
                return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
            },
            children: function (elem) {
                return jQuery.sibling(elem.firstChild);
            },
            contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes);
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until);
                if (name.slice(-5) !== 'Until') {
                    selector = until;
                }
                if (selector && typeof selector === 'string') {
                    matched = jQuery.filter(selector, matched);
                }
                if (this.length > 1) {
                    if (!guaranteedUnique[name]) {
                        jQuery.unique(matched);
                    }
                    if (rparentsprev.test(name)) {
                        matched.reverse();
                    }
                }
                return this.pushStack(matched);
            };
        });
        jQuery.extend({
            filter: function (expr, elems, not) {
                var elem = elems[0];
                if (not) {
                    expr = ':not(' + expr + ')';
                }
                return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                    return elem.nodeType === 1;
                }));
            },
            dir: function (elem, dir, until) {
                var matched = [], truncate = until !== undefined;
                while ((elem = elem[dir]) && elem.nodeType !== 9) {
                    if (elem.nodeType === 1) {
                        if (truncate && jQuery(elem).is(until)) {
                            break;
                        }
                        matched.push(elem);
                    }
                }
                return matched;
            },
            sibling: function (n, elem) {
                var matched = [];
                for (; n; n = n.nextSibling) {
                    if (n.nodeType === 1 && n !== elem) {
                        matched.push(n);
                    }
                }
                return matched;
            }
        });
        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function (elem, i) {
                    return !!qualifier.call(elem, i, elem) !== not;
                });
            }
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function (elem) {
                    return elem === qualifier !== not;
                });
            }
            if (typeof qualifier === 'string') {
                if (isSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not);
                }
                qualifier = jQuery.filter(qualifier, elements);
            }
            return jQuery.grep(elements, function (elem) {
                return core_indexOf.call(qualifier, elem) >= 0 !== not;
            });
        }
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
                option: [
                    1,
                    '<select multiple=\'multiple\'>',
                    '</select>'
                ],
                thead: [
                    1,
                    '<table>',
                    '</table>'
                ],
                col: [
                    2,
                    '<table><colgroup>',
                    '</colgroup></table>'
                ],
                tr: [
                    2,
                    '<table><tbody>',
                    '</tbody></table>'
                ],
                td: [
                    3,
                    '<table><tbody><tr>',
                    '</tr></tbody></table>'
                ],
                _default: [
                    0,
                    '',
                    ''
                ]
            };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        jQuery.fn.extend({
            text: function (value) {
                return jQuery.access(this, function (value) {
                    return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
                }, null, value, arguments.length);
            },
            append: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem);
                    }
                });
            },
            prepend: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild);
                    }
                });
            },
            before: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this);
                    }
                });
            },
            after: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this.nextSibling);
                    }
                });
            },
            remove: function (selector, keepData) {
                var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
                for (; (elem = elems[i]) != null; i++) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem));
                    }
                    if (elem.parentNode) {
                        if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                            setGlobalEval(getAll(elem, 'script'));
                        }
                        elem.parentNode.removeChild(elem);
                    }
                }
                return this;
            },
            empty: function () {
                var elem, i = 0;
                for (; (elem = this[i]) != null; i++) {
                    if (elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem, false));
                        elem.textContent = '';
                    }
                }
                return this;
            },
            clone: function (dataAndEvents, deepDataAndEvents) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                return this.map(function () {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
            },
            html: function (value) {
                return jQuery.access(this, function (value) {
                    var elem = this[0] || {}, i = 0, l = this.length;
                    if (value === undefined && elem.nodeType === 1) {
                        return elem.innerHTML;
                    }
                    if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                            '',
                            ''
                        ])[1].toLowerCase()]) {
                        value = value.replace(rxhtmlTag, '<$1></$2>');
                        try {
                            for (; i < l; i++) {
                                elem = this[i] || {};
                                if (elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem, false));
                                    elem.innerHTML = value;
                                }
                            }
                            elem = 0;
                        } catch (e) {
                        }
                    }
                    if (elem) {
                        this.empty().append(value);
                    }
                }, null, value, arguments.length);
            },
            replaceWith: function () {
                var args = jQuery.map(this, function (elem) {
                        return [
                            elem.nextSibling,
                            elem.parentNode
                        ];
                    }), i = 0;
                this.domManip(arguments, function (elem) {
                    var next = args[i++], parent = args[i++];
                    if (parent) {
                        if (next && next.parentNode !== parent) {
                            next = this.nextSibling;
                        }
                        jQuery(this).remove();
                        parent.insertBefore(elem, next);
                    }
                }, true);
                return i ? this : this.remove();
            },
            detach: function (selector) {
                return this.remove(selector, true);
            },
            domManip: function (args, callback, allowIntersection) {
                args = core_concat.apply([], args);
                var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
                if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
                    return this.each(function (index) {
                        var self = set.eq(index);
                        if (isFunction) {
                            args[0] = value.call(this, index, self.html());
                        }
                        self.domManip(args, callback, allowIntersection);
                    });
                }
                if (l) {
                    fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
                    first = fragment.firstChild;
                    if (fragment.childNodes.length === 1) {
                        fragment = first;
                    }
                    if (first) {
                        scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                        hasScripts = scripts.length;
                        for (; i < l; i++) {
                            node = fragment;
                            if (i !== iNoClone) {
                                node = jQuery.clone(node, true, true);
                                if (hasScripts) {
                                    jQuery.merge(scripts, getAll(node, 'script'));
                                }
                            }
                            callback.call(this[i], node, i);
                        }
                        if (hasScripts) {
                            doc = scripts[scripts.length - 1].ownerDocument;
                            jQuery.map(scripts, restoreScript);
                            for (i = 0; i < hasScripts; i++) {
                                node = scripts[i];
                                if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                                    if (node.src) {
                                        jQuery._evalUrl(node.src);
                                    } else {
                                        jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                    }
                                }
                            }
                        }
                    }
                }
                return this;
            }
        });
        jQuery.each({
            appendTo: 'append',
            prependTo: 'prepend',
            insertBefore: 'before',
            insertAfter: 'after',
            replaceAll: 'replaceWith'
        }, function (name, original) {
            jQuery.fn[name] = function (selector) {
                var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    core_push.apply(ret, elems.get());
                }
                return this.pushStack(ret);
            };
        });
        jQuery.extend({
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
                if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                    destElements = getAll(clone);
                    srcElements = getAll(elem);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        fixInput(srcElements[i], destElements[i]);
                    }
                }
                if (dataAndEvents) {
                    if (deepDataAndEvents) {
                        srcElements = srcElements || getAll(elem);
                        destElements = destElements || getAll(clone);
                        for (i = 0, l = srcElements.length; i < l; i++) {
                            cloneCopyEvent(srcElements[i], destElements[i]);
                        }
                    } else {
                        cloneCopyEvent(elem, clone);
                    }
                }
                destElements = getAll(clone, 'script');
                if (destElements.length > 0) {
                    setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
                }
                return clone;
            },
            buildFragment: function (elems, context, scripts, selection) {
                var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
                for (; i < l; i++) {
                    elem = elems[i];
                    if (elem || elem === 0) {
                        if (jQuery.type(elem) === 'object') {
                            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                        } else if (!rhtml.test(elem)) {
                            nodes.push(context.createTextNode(elem));
                        } else {
                            tmp = tmp || fragment.appendChild(context.createElement('div'));
                            tag = (rtagName.exec(elem) || [
                                '',
                                ''
                            ])[1].toLowerCase();
                            wrap = wrapMap[tag] || wrapMap._default;
                            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                            j = wrap[0];
                            while (j--) {
                                tmp = tmp.lastChild;
                            }
                            jQuery.merge(nodes, tmp.childNodes);
                            tmp = fragment.firstChild;
                            tmp.textContent = '';
                        }
                    }
                }
                fragment.textContent = '';
                i = 0;
                while (elem = nodes[i++]) {
                    if (selection && jQuery.inArray(elem, selection) !== -1) {
                        continue;
                    }
                    contains = jQuery.contains(elem.ownerDocument, elem);
                    tmp = getAll(fragment.appendChild(elem), 'script');
                    if (contains) {
                        setGlobalEval(tmp);
                    }
                    if (scripts) {
                        j = 0;
                        while (elem = tmp[j++]) {
                            if (rscriptType.test(elem.type || '')) {
                                scripts.push(elem);
                            }
                        }
                    }
                }
                return fragment;
            },
            cleanData: function (elems) {
                var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
                for (; (elem = elems[i]) !== undefined; i++) {
                    if (Data.accepts(elem)) {
                        key = elem[data_priv.expando];
                        if (key && (data = data_priv.cache[key])) {
                            events = Object.keys(data.events || {});
                            if (events.length) {
                                for (j = 0; (type = events[j]) !== undefined; j++) {
                                    if (special[type]) {
                                        jQuery.event.remove(elem, type);
                                    } else {
                                        jQuery.removeEvent(elem, type, data.handle);
                                    }
                                }
                            }
                            if (data_priv.cache[key]) {
                                delete data_priv.cache[key];
                            }
                        }
                    }
                    delete data_user.cache[elem[data_user.expando]];
                }
            },
            _evalUrl: function (url) {
                return jQuery.ajax({
                    url: url,
                    type: 'GET',
                    dataType: 'script',
                    async: false,
                    global: false,
                    'throws': true
                });
            }
        });
        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
        }
        function disableScript(elem) {
            elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
            return elem;
        }
        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            if (match) {
                elem.type = match[1];
            } else {
                elem.removeAttribute('type');
            }
            return elem;
        }
        function setGlobalEval(elems, refElements) {
            var l = elems.length, i = 0;
            for (; i < l; i++) {
                data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
            }
        }
        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
                return;
            }
            if (data_priv.hasData(src)) {
                pdataOld = data_priv.access(src);
                pdataCur = data_priv.set(dest, pdataOld);
                events = pdataOld.events;
                if (events) {
                    delete pdataCur.handle;
                    pdataCur.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }
            }
            if (data_user.hasData(src)) {
                udataOld = data_user.access(src);
                udataCur = jQuery.extend({}, udataOld);
                data_user.set(dest, udataCur);
            }
        }
        function getAll(context, tag) {
            var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
            return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
        }
        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
                dest.checked = src.checked;
            } else if (nodeName === 'input' || nodeName === 'textarea') {
                dest.defaultValue = src.defaultValue;
            }
        }
        jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapAll(html.call(this, i));
                    });
                }
                if (this[0]) {
                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                    if (this[0].parentNode) {
                        wrap.insertBefore(this[0]);
                    }
                    wrap.map(function () {
                        var elem = this;
                        while (elem.firstElementChild) {
                            elem = elem.firstElementChild;
                        }
                        return elem;
                    }).append(this);
                }
                return this;
            },
            wrapInner: function (html) {
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapInner(html.call(this, i));
                    });
                }
                return this.each(function () {
                    var self = jQuery(this), contents = self.contents();
                    if (contents.length) {
                        contents.wrapAll(html);
                    } else {
                        self.append(html);
                    }
                });
            },
            wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                });
            },
            unwrap: function () {
                return this.parent().each(function () {
                    if (!jQuery.nodeName(this, 'body')) {
                        jQuery(this).replaceWith(this.childNodes);
                    }
                }).end();
            }
        });
        var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
                position: 'absolute',
                visibility: 'hidden',
                display: 'block'
            }, cssNormalTransform = {
                letterSpacing: 0,
                fontWeight: 400
            }, cssExpand = [
                'Top',
                'Right',
                'Bottom',
                'Left'
            ], cssPrefixes = [
                'Webkit',
                'O',
                'Moz',
                'ms'
            ];
        function vendorPropName(style, name) {
            if (name in style) {
                return name;
            }
            var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
            while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in style) {
                    return name;
                }
            }
            return origName;
        }
        function isHidden(elem, el) {
            elem = el || elem;
            return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
        }
        function getStyles(elem) {
            return window.getComputedStyle(elem, null);
        }
        function showHide(elements, show) {
            var display, elem, hidden, values = [], index = 0, length = elements.length;
            for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                values[index] = data_priv.get(elem, 'olddisplay');
                display = elem.style.display;
                if (show) {
                    if (!values[index] && display === 'none') {
                        elem.style.display = '';
                    }
                    if (elem.style.display === '' && isHidden(elem)) {
                        values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
                    }
                } else {
                    if (!values[index]) {
                        hidden = isHidden(elem);
                        if (display && display !== 'none' || !hidden) {
                            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                        }
                    }
                }
            }
            for (index = 0; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                if (!show || elem.style.display === 'none' || elem.style.display === '') {
                    elem.style.display = show ? values[index] || '' : 'none';
                }
            }
            return elements;
        }
        jQuery.fn.extend({
            css: function (name, value) {
                return jQuery.access(this, function (elem, name, value) {
                    var styles, len, map = {}, i = 0;
                    if (jQuery.isArray(name)) {
                        styles = getStyles(elem);
                        len = name.length;
                        for (; i < len; i++) {
                            map[name[i]] = jQuery.css(elem, name[i], false, styles);
                        }
                        return map;
                    }
                    return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                }, name, value, arguments.length > 1);
            },
            show: function () {
                return showHide(this, true);
            },
            hide: function () {
                return showHide(this);
            },
            toggle: function (state) {
                if (typeof state === 'boolean') {
                    return state ? this.show() : this.hide();
                }
                return this.each(function () {
                    if (isHidden(this)) {
                        jQuery(this).show();
                    } else {
                        jQuery(this).hide();
                    }
                });
            }
        });
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, 'opacity');
                            return ret === '' ? '1' : ret;
                        }
                    }
                }
            },
            cssNumber: {
                'columnCount': true,
                'fillOpacity': true,
                'fontWeight': true,
                'lineHeight': true,
                'opacity': true,
                'order': true,
                'orphans': true,
                'widows': true,
                'zIndex': true,
                'zoom': true
            },
            cssProps: { 'float': 'cssFloat' },
            style: function (elem, name, value, extra) {
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                    return;
                }
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (value !== undefined) {
                    type = typeof value;
                    if (type === 'string' && (ret = rrelNum.exec(value))) {
                        value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                        type = 'number';
                    }
                    if (value == null || type === 'number' && isNaN(value)) {
                        return;
                    }
                    if (type === 'number' && !jQuery.cssNumber[origName]) {
                        value += 'px';
                    }
                    if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                        style[name] = 'inherit';
                    }
                    if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                        style[name] = value;
                    }
                } else {
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                        return ret;
                    }
                    return style[name];
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (hooks && 'get' in hooks) {
                    val = hooks.get(elem, true, extra);
                }
                if (val === undefined) {
                    val = curCSS(elem, name, styles);
                }
                if (val === 'normal' && name in cssNormalTransform) {
                    val = cssNormalTransform[name];
                }
                if (extra === '' || extra) {
                    num = parseFloat(val);
                    return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                }
                return val;
            }
        });
        curCSS = function (elem, name, _computed) {
            var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret;
        };
        function setPositiveNumber(elem, value, subtract) {
            var matches = rnumsplit.exec(value);
            return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
        }
        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
            for (; i < 4; i += 2) {
                if (extra === 'margin') {
                    val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                }
                if (isBorderBox) {
                    if (extra === 'content') {
                        val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    }
                    if (extra !== 'margin') {
                        val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                } else {
                    val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    if (extra !== 'padding') {
                        val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                }
            }
            return val;
        }
        function getWidthOrHeight(elem, name, extra) {
            var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
            if (val <= 0 || val == null) {
                val = curCSS(elem, name, styles);
                if (val < 0 || val == null) {
                    val = elem.style[name];
                }
                if (rnumnonpx.test(val)) {
                    return val;
                }
                valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
                val = parseFloat(val) || 0;
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
        }
        function css_defaultDisplay(nodeName) {
            var doc = document, display = elemdisplay[nodeName];
            if (!display) {
                display = actualDisplay(nodeName, doc);
                if (display === 'none' || !display) {
                    iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
                    doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                    doc.write('<!doctype html><html><body>');
                    doc.close();
                    display = actualDisplay(nodeName, doc);
                    iframe.detach();
                }
                elemdisplay[nodeName] = display;
            }
            return display;
        }
        function actualDisplay(name, doc) {
            var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
            elem.remove();
            return display;
        }
        jQuery.each([
            'height',
            'width'
        ], function (i, name) {
            jQuery.cssHooks[name] = {
                get: function (elem, computed, extra) {
                    if (computed) {
                        return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, name, extra);
                        }) : getWidthOrHeight(elem, name, extra);
                    }
                },
                set: function (elem, value, extra) {
                    var styles = extra && getStyles(elem);
                    return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
                }
            };
        });
        jQuery(function () {
            if (!jQuery.support.reliableMarginRight) {
                jQuery.cssHooks.marginRight = {
                    get: function (elem, computed) {
                        if (computed) {
                            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                                elem,
                                'marginRight'
                            ]);
                        }
                    }
                };
            }
            if (!jQuery.support.pixelPosition && jQuery.fn.position) {
                jQuery.each([
                    'top',
                    'left'
                ], function (i, prop) {
                    jQuery.cssHooks[prop] = {
                        get: function (elem, computed) {
                            if (computed) {
                                computed = curCSS(elem, prop);
                                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
                            }
                        }
                    };
                });
            }
        });
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.hidden = function (elem) {
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
            };
            jQuery.expr.filters.visible = function (elem) {
                return !jQuery.expr.filters.hidden(elem);
            };
        }
        jQuery.each({
            margin: '',
            padding: '',
            border: 'Width'
        }, function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                    for (; i < 4; i++) {
                        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    }
                    return expanded;
                }
            };
            if (!rmargin.test(prefix)) {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
        });
        var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray());
            },
            serializeArray: function () {
                return this.map(function () {
                    var elements = jQuery.prop(this, 'elements');
                    return elements ? jQuery.makeArray(elements) : this;
                }).filter(function () {
                    var type = this.type;
                    return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }).get();
            }
        });
        jQuery.param = function (a, traditional) {
            var prefix, s = [], add = function (key, value) {
                    value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                    s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
                };
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
            }
            if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });
            } else {
                for (prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }
            return s.join('&').replace(r20, '+');
        };
        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) {
                jQuery.each(obj, function (i, v) {
                    if (traditional || rbracket.test(prefix)) {
                        add(prefix, v);
                    } else {
                        buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                    }
                });
            } else if (!traditional && jQuery.type(obj) === 'object') {
                for (name in obj) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            } else {
                add(prefix, obj);
            }
        }
        jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        });
        jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            },
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn);
            },
            unbind: function (types, fn) {
                return this.off(types, null, fn);
            },
            delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn);
            },
            undelegate: function (selector, types, fn) {
                return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
            }
        });
        var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
        try {
            ajaxLocation = location.href;
        } catch (e) {
            ajaxLocation = document.createElement('a');
            ajaxLocation.href = '';
            ajaxLocation = ajaxLocation.href;
        }
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
        function addToPrefiltersOrTransports(structure) {
            return function (dataTypeExpression, func) {
                if (typeof dataTypeExpression !== 'string') {
                    func = dataTypeExpression;
                    dataTypeExpression = '*';
                }
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
                if (jQuery.isFunction(func)) {
                    while (dataType = dataTypes[i++]) {
                        if (dataType[0] === '+') {
                            dataType = dataType.slice(1) || '*';
                            (structure[dataType] = structure[dataType] || []).unshift(func);
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    }
                }
            };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                        options.dataTypes.unshift(dataTypeOrTransport);
                        inspect(dataTypeOrTransport);
                        return false;
                    } else if (seekingTransport) {
                        return !(selected = dataTypeOrTransport);
                    }
                });
                return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
        }
        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
                if (src[key] !== undefined) {
                    (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                }
            }
            if (deep) {
                jQuery.extend(true, target, deep);
            }
            return target;
        }
        jQuery.fn.load = function (url, params, callback) {
            if (typeof url !== 'string' && _load) {
                return _load.apply(this, arguments);
            }
            var selector, type, response, self = this, off = url.indexOf(' ');
            if (off >= 0) {
                selector = url.slice(off);
                url = url.slice(0, off);
            }
            if (jQuery.isFunction(params)) {
                callback = params;
                params = undefined;
            } else if (params && typeof params === 'object') {
                type = 'POST';
            }
            if (self.length > 0) {
                jQuery.ajax({
                    url: url,
                    type: type,
                    dataType: 'html',
                    data: params
                }).done(function (responseText) {
                    response = arguments;
                    self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                }).complete(callback && function (jqXHR, status) {
                    self.each(callback, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            }
            return this;
        };
        jQuery.each([
            'ajaxStart',
            'ajaxStop',
            'ajaxComplete',
            'ajaxError',
            'ajaxSuccess',
            'ajaxSend'
        ], function (i, type) {
            jQuery.fn[type] = function (fn) {
                return this.on(type, fn);
            };
        });
        jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ajaxLocation,
                type: 'GET',
                isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                global: true,
                processData: true,
                async: true,
                contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                accepts: {
                    '*': allTypes,
                    text: 'text/plain',
                    html: 'text/html',
                    xml: 'application/xml, text/xml',
                    json: 'application/json, text/javascript'
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: 'responseXML',
                    text: 'responseText',
                    json: 'responseJSON'
                },
                converters: {
                    '* text': String,
                    'text html': true,
                    'text json': jQuery.parseJSON,
                    'text xml': jQuery.parseXML
                },
                flatOptions: {
                    url: true,
                    context: true
                }
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                if (typeof url === 'object') {
                    options = url;
                    url = undefined;
                }
                options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                        readyState: 0,
                        getResponseHeader: function (key) {
                            var match;
                            if (state === 2) {
                                if (!responseHeaders) {
                                    responseHeaders = {};
                                    while (match = rheaders.exec(responseHeadersString)) {
                                        responseHeaders[match[1].toLowerCase()] = match[2];
                                    }
                                }
                                match = responseHeaders[key.toLowerCase()];
                            }
                            return match == null ? null : match;
                        },
                        getAllResponseHeaders: function () {
                            return state === 2 ? responseHeadersString : null;
                        },
                        setRequestHeader: function (name, value) {
                            var lname = name.toLowerCase();
                            if (!state) {
                                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                requestHeaders[name] = value;
                            }
                            return this;
                        },
                        overrideMimeType: function (type) {
                            if (!state) {
                                s.mimeType = type;
                            }
                            return this;
                        },
                        statusCode: function (map) {
                            var code;
                            if (map) {
                                if (state < 2) {
                                    for (code in map) {
                                        statusCode[code] = [
                                            statusCode[code],
                                            map[code]
                                        ];
                                    }
                                } else {
                                    jqXHR.always(map[jqXHR.status]);
                                }
                            }
                            return this;
                        },
                        abort: function (statusText) {
                            var finalText = statusText || strAbort;
                            if (transport) {
                                transport.abort(finalText);
                            }
                            done(0, finalText);
                            return this;
                        }
                    };
                deferred.promise(jqXHR).complete = completeDeferred.add;
                jqXHR.success = jqXHR.done;
                jqXHR.error = jqXHR.fail;
                s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
                s.type = options.method || options.type || s.method || s.type;
                s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
                if (s.crossDomain == null) {
                    parts = rurl.exec(s.url.toLowerCase());
                    s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
                }
                if (s.data && s.processData && typeof s.data !== 'string') {
                    s.data = jQuery.param(s.data, s.traditional);
                }
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                if (state === 2) {
                    return jqXHR;
                }
                fireGlobals = s.global;
                if (fireGlobals && jQuery.active++ === 0) {
                    jQuery.event.trigger('ajaxStart');
                }
                s.type = s.type.toUpperCase();
                s.hasContent = !rnoContent.test(s.type);
                cacheURL = s.url;
                if (!s.hasContent) {
                    if (s.data) {
                        cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
                        delete s.data;
                    }
                    if (s.cache === false) {
                        s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
                    }
                }
                if (s.ifModified) {
                    if (jQuery.lastModified[cacheURL]) {
                        jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                    }
                    if (jQuery.etag[cacheURL]) {
                        jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                    }
                }
                if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                    jqXHR.setRequestHeader('Content-Type', s.contentType);
                }
                jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
                for (i in s.headers) {
                    jqXHR.setRequestHeader(i, s.headers[i]);
                }
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                    return jqXHR.abort();
                }
                strAbort = 'abort';
                for (i in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) {
                    jqXHR[i](s[i]);
                }
                transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                if (!transport) {
                    done(-1, 'No Transport');
                } else {
                    jqXHR.readyState = 1;
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxSend', [
                            jqXHR,
                            s
                        ]);
                    }
                    if (s.async && s.timeout > 0) {
                        timeoutTimer = setTimeout(function () {
                            jqXHR.abort('timeout');
                        }, s.timeout);
                    }
                    try {
                        state = 1;
                        transport.send(requestHeaders, done);
                    } catch (e) {
                        if (state < 2) {
                            done(-1, e);
                        } else {
                            throw e;
                        }
                    }
                }
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    if (state === 2) {
                        return;
                    }
                    state = 2;
                    if (timeoutTimer) {
                        clearTimeout(timeoutTimer);
                    }
                    transport = undefined;
                    responseHeadersString = headers || '';
                    jqXHR.readyState = status > 0 ? 4 : 0;
                    isSuccess = status >= 200 && status < 300 || status === 304;
                    if (responses) {
                        response = ajaxHandleResponses(s, jqXHR, responses);
                    }
                    response = ajaxConvert(s, response, jqXHR, isSuccess);
                    if (isSuccess) {
                        if (s.ifModified) {
                            modified = jqXHR.getResponseHeader('Last-Modified');
                            if (modified) {
                                jQuery.lastModified[cacheURL] = modified;
                            }
                            modified = jqXHR.getResponseHeader('etag');
                            if (modified) {
                                jQuery.etag[cacheURL] = modified;
                            }
                        }
                        if (status === 204 || s.type === 'HEAD') {
                            statusText = 'nocontent';
                        } else if (status === 304) {
                            statusText = 'notmodified';
                        } else {
                            statusText = response.state;
                            success = response.data;
                            error = response.error;
                            isSuccess = !error;
                        }
                    } else {
                        error = statusText;
                        if (status || !statusText) {
                            statusText = 'error';
                            if (status < 0) {
                                status = 0;
                            }
                        }
                    }
                    jqXHR.status = status;
                    jqXHR.statusText = (nativeStatusText || statusText) + '';
                    if (isSuccess) {
                        deferred.resolveWith(callbackContext, [
                            success,
                            statusText,
                            jqXHR
                        ]);
                    } else {
                        deferred.rejectWith(callbackContext, [
                            jqXHR,
                            statusText,
                            error
                        ]);
                    }
                    jqXHR.statusCode(statusCode);
                    statusCode = undefined;
                    if (fireGlobals) {
                        globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                            jqXHR,
                            s,
                            isSuccess ? success : error
                        ]);
                    }
                    completeDeferred.fireWith(callbackContext, [
                        jqXHR,
                        statusText
                    ]);
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxComplete', [
                            jqXHR,
                            s
                        ]);
                        if (!--jQuery.active) {
                            jQuery.event.trigger('ajaxStop');
                        }
                    }
                }
                return jqXHR;
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, 'json');
            },
            getScript: function (url, callback) {
                return jQuery.get(url, undefined, callback, 'script');
            }
        });
        jQuery.each([
            'get',
            'post'
        ], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
                if (jQuery.isFunction(data)) {
                    type = type || callback;
                    callback = data;
                    data = undefined;
                }
                return jQuery.ajax({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                });
            };
        });
        function ajaxHandleResponses(s, jqXHR, responses) {
            var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
            while (dataTypes[0] === '*') {
                dataTypes.shift();
                if (ct === undefined) {
                    ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
                }
            }
            if (ct) {
                for (type in contents) {
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break;
                    }
                }
            }
            if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0];
            } else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                        finalDataType = type;
                        break;
                    }
                    if (!firstDataType) {
                        firstDataType = type;
                    }
                }
                finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                    dataTypes.unshift(finalDataType);
                }
                return responses[finalDataType];
            }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
            if (dataTypes[1]) {
                for (conv in s.converters) {
                    converters[conv.toLowerCase()] = s.converters[conv];
                }
            }
            current = dataTypes.shift();
            while (current) {
                if (s.responseFields[current]) {
                    jqXHR[s.responseFields[current]] = response;
                }
                if (!prev && isSuccess && s.dataFilter) {
                    response = s.dataFilter(response, s.dataType);
                }
                prev = current;
                current = dataTypes.shift();
                if (current) {
                    if (current === '*') {
                        current = prev;
                    } else if (prev !== '*' && prev !== current) {
                        conv = converters[prev + ' ' + current] || converters['* ' + current];
                        if (!conv) {
                            for (conv2 in converters) {
                                tmp = conv2.split(' ');
                                if (tmp[1] === current) {
                                    conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                    if (conv) {
                                        if (conv === true) {
                                            conv = converters[conv2];
                                        } else if (converters[conv2] !== true) {
                                            current = tmp[0];
                                            dataTypes.unshift(tmp[1]);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        if (conv !== true) {
                            if (conv && s['throws']) {
                                response = conv(response);
                            } else {
                                try {
                                    response = conv(response);
                                } catch (e) {
                                    return {
                                        state: 'parsererror',
                                        error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                    };
                                }
                            }
                        }
                    }
                }
            }
            return {
                state: 'success',
                data: response
            };
        }
        jQuery.ajaxSetup({
            accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
            contents: { script: /(?:java|ecma)script/ },
            converters: {
                'text script': function (text) {
                    jQuery.globalEval(text);
                    return text;
                }
            }
        });
        jQuery.ajaxPrefilter('script', function (s) {
            if (s.cache === undefined) {
                s.cache = false;
            }
            if (s.crossDomain) {
                s.type = 'GET';
            }
        });
        jQuery.ajaxTransport('script', function (s) {
            if (s.crossDomain) {
                var script, callback;
                return {
                    send: function (_, complete) {
                        script = jQuery('<script>').prop({
                            async: true,
                            charset: s.scriptCharset,
                            src: s.url
                        }).on('load error', callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === 'error' ? 404 : 200, evt.type);
                            }
                        });
                        document.head.appendChild(script[0]);
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
                this[callback] = true;
                return callback;
            }
        });
        jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
            if (jsonProp || s.dataTypes[0] === 'jsonp') {
                callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
                } else if (s.jsonp !== false) {
                    s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
                }
                s.converters['script json'] = function () {
                    if (!responseContainer) {
                        jQuery.error(callbackName + ' was not called');
                    }
                    return responseContainer[0];
                };
                s.dataTypes[0] = 'json';
                overwritten = window[callbackName];
                window[callbackName] = function () {
                    responseContainer = arguments;
                };
                jqXHR.always(function () {
                    window[callbackName] = overwritten;
                    if (s[callbackName]) {
                        s.jsonpCallback = originalSettings.jsonpCallback;
                        oldCallbacks.push(callbackName);
                    }
                    if (responseContainer && jQuery.isFunction(overwritten)) {
                        overwritten(responseContainer[0]);
                    }
                    responseContainer = overwritten = undefined;
                });
                return 'script';
            }
        });
        jQuery.ajaxSettings.xhr = function () {
            try {
                return new XMLHttpRequest();
            } catch (e) {
            }
        };
        var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
                0: 200,
                1223: 204
            }, xhrId = 0, xhrCallbacks = {};
        if (window.ActiveXObject) {
            jQuery(window).on('unload', function () {
                for (var key in xhrCallbacks) {
                    xhrCallbacks[key]();
                }
                xhrCallbacks = undefined;
            });
        }
        jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
        jQuery.support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function (options) {
            var callback;
            if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
                return {
                    send: function (headers, complete) {
                        var i, id, xhr = options.xhr();
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        for (i in headers) {
                            xhr.setRequestHeader(i, headers[i]);
                        }
                        callback = function (type) {
                            return function () {
                                if (callback) {
                                    delete xhrCallbacks[id];
                                    callback = xhr.onload = xhr.onerror = null;
                                    if (type === 'abort') {
                                        xhr.abort();
                                    } else if (type === 'error') {
                                        complete(xhr.status || 404, xhr.statusText);
                                    } else {
                                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                                    }
                                }
                            };
                        };
                        xhr.onload = callback();
                        xhr.onerror = callback('error');
                        callback = xhrCallbacks[id = xhrId++] = callback('abort');
                        xhr.send(options.hasContent && options.data || null);
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
                '*': [function (prop, value) {
                        var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                        if (start && start[3] !== unit) {
                            unit = unit || start[3];
                            parts = parts || [];
                            start = +target || 1;
                            do {
                                scale = scale || '.5';
                                start = start / scale;
                                jQuery.style(tween.elem, prop, start + unit);
                            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                        }
                        if (parts) {
                            start = tween.start = +start || +target || 0;
                            tween.unit = unit;
                            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                        }
                        return tween;
                    }]
            };
        function createFxNow() {
            setTimeout(function () {
                fxNow = undefined;
            });
            return fxNow = jQuery.now();
        }
        function createTween(value, prop, animation) {
            var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
            for (; index < length; index++) {
                if (tween = collection[index].call(animation, prop, value)) {
                    return tween;
                }
            }
        }
        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                    delete tick.elem;
                }), tick = function () {
                    if (stopped) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                    for (; index < length; index++) {
                        animation.tweens[index].run(percent);
                    }
                    deferred.notifyWith(elem, [
                        animation,
                        percent,
                        remaining
                    ]);
                    if (percent < 1 && length) {
                        return remaining;
                    } else {
                        deferred.resolveWith(elem, [animation]);
                        return false;
                    }
                }, animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(true, { specialEasing: {} }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function (prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        animation.tweens.push(tween);
                        return tween;
                    },
                    stop: function (gotoEnd) {
                        var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) {
                            return this;
                        }
                        stopped = true;
                        for (; index < length; index++) {
                            animation.tweens[index].run(1);
                        }
                        if (gotoEnd) {
                            deferred.resolveWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        } else {
                            deferred.rejectWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        }
                        return this;
                    }
                }), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
                result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                if (result) {
                    return result;
                }
            }
            jQuery.map(props, createTween, animation);
            if (jQuery.isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation);
            }
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            }));
            return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        }
        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
                name = jQuery.camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (jQuery.isArray(value)) {
                    easing = value[1];
                    value = props[index] = value[0];
                }
                if (index !== name) {
                    props[name] = value;
                    delete props[index];
                }
                hooks = jQuery.cssHooks[name];
                if (hooks && 'expand' in hooks) {
                    value = hooks.expand(value);
                    delete props[name];
                    for (index in value) {
                        if (!(index in props)) {
                            props[index] = value[index];
                            specialEasing[index] = easing;
                        }
                    }
                } else {
                    specialEasing[name] = easing;
                }
            }
        }
        jQuery.Animation = jQuery.extend(Animation, {
            tweener: function (props, callback) {
                if (jQuery.isFunction(props)) {
                    callback = props;
                    props = ['*'];
                } else {
                    props = props.split(' ');
                }
                var prop, index = 0, length = props.length;
                for (; index < length; index++) {
                    prop = props[index];
                    tweeners[prop] = tweeners[prop] || [];
                    tweeners[prop].unshift(callback);
                }
            },
            prefilter: function (callback, prepend) {
                if (prepend) {
                    animationPrefilters.unshift(callback);
                } else {
                    animationPrefilters.push(callback);
                }
            }
        });
        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
            if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, 'fx');
                if (hooks.unqueued == null) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function () {
                        if (!hooks.unqueued) {
                            oldfire();
                        }
                    };
                }
                hooks.unqueued++;
                anim.always(function () {
                    anim.always(function () {
                        hooks.unqueued--;
                        if (!jQuery.queue(elem, 'fx').length) {
                            hooks.empty.fire();
                        }
                    });
                });
            }
            if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
                opts.overflow = [
                    style.overflow,
                    style.overflowX,
                    style.overflowY
                ];
                if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
                    style.display = 'inline-block';
                }
            }
            if (opts.overflow) {
                style.overflow = 'hidden';
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
            for (prop in props) {
                value = props[prop];
                if (rfxtypes.exec(value)) {
                    delete props[prop];
                    toggle = toggle || value === 'toggle';
                    if (value === (hidden ? 'hide' : 'show')) {
                        if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                            hidden = true;
                        } else {
                            continue;
                        }
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                }
            }
            if (!jQuery.isEmptyObject(orig)) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = data_priv.access(elem, 'fxshow', {});
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    jQuery(elem).show();
                } else {
                    anim.done(function () {
                        jQuery(elem).hide();
                    });
                }
                anim.done(function () {
                    var prop;
                    data_priv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
                for (prop in orig) {
                    tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                    if (!(prop in dataShow)) {
                        dataShow[prop] = tween.start;
                        if (hidden) {
                            tween.end = tween.start;
                            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                        }
                    }
                }
            }
        }
        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || 'swing';
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                if (this.options.duration) {
                    this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                } else {
                    this.pos = eased = percent;
                }
                this.now = (this.end - this.start) * eased + this.start;
                if (this.options.step) {
                    this.options.step.call(this.elem, this.now, this);
                }
                if (hooks && hooks.set) {
                    hooks.set(this);
                } else {
                    Tween.propHooks._default.set(this);
                }
                return this;
            }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                        return tween.elem[tween.prop];
                    }
                    result = jQuery.css(tween.elem, tween.prop, '');
                    return !result || result === 'auto' ? 0 : result;
                },
                set: function (tween) {
                    if (jQuery.fx.step[tween.prop]) {
                        jQuery.fx.step[tween.prop](tween);
                    } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                    } else {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                if (tween.elem.nodeType && tween.elem.parentNode) {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        };
        jQuery.each([
            'toggle',
            'show',
            'hide'
        ], function (i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function (speed, easing, callback) {
                return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
        });
        jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
                return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
            },
            animate: function (prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        if (empty || data_priv.get(this, 'finish')) {
                            anim.stop(true);
                        }
                    };
                doAnimation.finish = doAnimation;
                return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function (type, clearQueue, gotoEnd) {
                var stopQueue = function (hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop;
                    stop(gotoEnd);
                };
                if (typeof type !== 'string') {
                    gotoEnd = clearQueue;
                    clearQueue = type;
                    type = undefined;
                }
                if (clearQueue && type !== false) {
                    this.queue(type || 'fx', []);
                }
                return this.each(function () {
                    var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
                    if (index) {
                        if (data[index] && data[index].stop) {
                            stopQueue(data[index]);
                        }
                    } else {
                        for (index in data) {
                            if (data[index] && data[index].stop && rrun.test(index)) {
                                stopQueue(data[index]);
                            }
                        }
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                            timers[index].anim.stop(gotoEnd);
                            dequeue = false;
                            timers.splice(index, 1);
                        }
                    }
                    if (dequeue || !gotoEnd) {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            finish: function (type) {
                if (type !== false) {
                    type = type || 'fx';
                }
                return this.each(function () {
                    var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                    data.finish = true;
                    jQuery.queue(this, type, []);
                    if (hooks && hooks.stop) {
                        hooks.stop.call(this, true);
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && timers[index].queue === type) {
                            timers[index].anim.stop(true);
                            timers.splice(index, 1);
                        }
                    }
                    for (index = 0; index < length; index++) {
                        if (queue[index] && queue[index].finish) {
                            queue[index].finish.call(this);
                        }
                    }
                    delete data.finish;
                });
            }
        });
        function genFx(type, includeWidth) {
            var which, attrs = { height: type }, i = 0;
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs['margin' + which] = attrs['padding' + which] = type;
            }
            if (includeWidth) {
                attrs.opacity = attrs.width = type;
            }
            return attrs;
        }
        jQuery.each({
            slideDown: genFx('show'),
            slideUp: genFx('hide'),
            slideToggle: genFx('toggle'),
            fadeIn: { opacity: 'show' },
            fadeOut: { opacity: 'hide' },
            fadeToggle: { opacity: 'toggle' }
        }, function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        });
        jQuery.speed = function (speed, easing, fn) {
            var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
            if (opt.queue == null || opt.queue === true) {
                opt.queue = 'fx';
            }
            opt.old = opt.complete;
            opt.complete = function () {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }
                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue);
                }
            };
            return opt;
        };
        jQuery.easing = {
            linear: function (p) {
                return p;
            },
            swing: function (p) {
                return 0.5 - Math.cos(p * Math.PI) / 2;
            }
        };
        jQuery.timers = [];
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.tick = function () {
            var timer, timers = jQuery.timers, i = 0;
            fxNow = jQuery.now();
            for (; i < timers.length; i++) {
                timer = timers[i];
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1);
                }
            }
            if (!timers.length) {
                jQuery.fx.stop();
            }
            fxNow = undefined;
        };
        jQuery.fx.timer = function (timer) {
            if (timer() && jQuery.timers.push(timer)) {
                jQuery.fx.start();
            }
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function () {
            if (!timerId) {
                timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
            }
        };
        jQuery.fx.stop = function () {
            clearInterval(timerId);
            timerId = null;
        };
        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        };
        jQuery.fx.step = {};
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.animated = function (elem) {
                return jQuery.grep(jQuery.timers, function (fn) {
                    return elem === fn.elem;
                }).length;
            };
        }
        jQuery.fn.offset = function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                    top: 0,
                    left: 0
                }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== core_strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        };
        jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
                if (position === 'static') {
                    elem.style.position = 'relative';
                }
                curOffset = curElem.offset();
                curCSSTop = jQuery.css(elem, 'top');
                curCSSLeft = jQuery.css(elem, 'left');
                calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
                if (calculatePosition) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }
                if (jQuery.isFunction(options)) {
                    options = options.call(elem, i, curOffset);
                }
                if (options.top != null) {
                    props.top = options.top - curOffset.top + curTop;
                }
                if (options.left != null) {
                    props.left = options.left - curOffset.left + curLeft;
                }
                if ('using' in options) {
                    options.using.call(elem, props);
                } else {
                    curElem.css(props);
                }
            }
        };
        jQuery.fn.extend({
            position: function () {
                if (!this[0]) {
                    return;
                }
                var offsetParent, offset, elem = this[0], parentOffset = {
                        top: 0,
                        left: 0
                    };
                if (jQuery.css(elem, 'position') === 'fixed') {
                    offset = elem.getBoundingClientRect();
                } else {
                    offsetParent = this.offsetParent();
                    offset = this.offset();
                    if (!jQuery.nodeName(offsetParent[0], 'html')) {
                        parentOffset = offsetParent.offset();
                    }
                    parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                    parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
                }
                return {
                    top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                    left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
                };
            },
            offsetParent: function () {
                return this.map(function () {
                    var offsetParent = this.offsetParent || docElem;
                    while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || docElem;
                });
            }
        });
        jQuery.each({
            scrollLeft: 'pageXOffset',
            scrollTop: 'pageYOffset'
        }, function (method, prop) {
            var top = 'pageYOffset' === prop;
            jQuery.fn[method] = function (val) {
                return jQuery.access(this, function (elem, method, val) {
                    var win = getWindow(elem);
                    if (val === undefined) {
                        return win ? win[prop] : elem[method];
                    }
                    if (win) {
                        win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                    } else {
                        elem[method] = val;
                    }
                }, method, val, arguments.length, null);
            };
        });
        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
        }
        jQuery.each({
            Height: 'height',
            Width: 'width'
        }, function (name, type) {
            jQuery.each({
                padding: 'inner' + name,
                content: type,
                '': 'outer' + name
            }, function (defaultExtra, funcName) {
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                    return jQuery.access(this, function (elem, type, value) {
                        var doc;
                        if (jQuery.isWindow(elem)) {
                            return elem.document.documentElement['client' + name];
                        }
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;
                            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                        }
                        return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable, null);
                };
            });
        });
        jQuery.fn.size = function () {
            return this.length;
        };
        jQuery.fn.andSelf = jQuery.fn.addBack;
        if (typeof module === 'object' && module && typeof module.exports === 'object') {
            module.exports = jQuery;
        } else {
            if (true) {
                amdclean_website['jquery'] = function () {
                    return jQuery;
                }();
            }
        }
        if (typeof window === 'object' && typeof window.document === 'object') {
            window.jQuery = window.$ = jQuery;
        }
    }(window));
    (function (window) {
        var undefined;
        var arrayPool = [], objectPool = [];
        var idCounter = 0;
        var indicatorObject = {};
        var keyPrefix = +new Date() + '';
        var largeArraySize = 75;
        var maxPoolSize = 40;
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reInterpolate = /<%=([\s\S]+?)%>/g;
        var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;
        var whitespace = ' \t\x0B\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
        var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
        var reNoMatch = /($^)/;
        var reUnescapedHtml = /[&<>"']/g;
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
        var contextProps = [
                'Array',
                'Boolean',
                'Date',
                'Error',
                'Function',
                'Math',
                'Number',
                'Object',
                'RegExp',
                'String',
                '_',
                'attachEvent',
                'clearTimeout',
                'isFinite',
                'isNaN',
                'parseInt',
                'setImmediate',
                'setTimeout'
            ];
        var shadowedProps = [
                'constructor',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'toLocaleString',
                'toString',
                'valueOf'
            ];
        var templateCounter = 0;
        var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', errorClass = '[object Error]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
        var cloneableClasses = {};
        cloneableClasses[funcClass] = false;
        cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
        var objectTypes = {
                'boolean': false,
                'function': true,
                'object': true,
                'number': false,
                'string': false,
                'undefined': false
            };
        var stringEscapes = {
                '\\': '\\',
                '\'': '\'',
                '\n': 'n',
                '\r': 'r',
                '\t': 't',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };
        var freeExports = objectTypes[typeof exports] && exports;
        var freeModule = objectTypes[typeof module] && module && module.exports == freeExports && module;
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
            window = freeGlobal;
        }
        function basicIndexOf(array, value, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array.length;
            while (++index < length) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function cacheIndexOf(cache, value) {
            var type = typeof value;
            cache = cache.cache;
            if (type == 'boolean' || value == null) {
                return cache[value];
            }
            if (type != 'number' && type != 'string') {
                type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value;
            cache = cache[type] || (cache[type] = {});
            return type == 'object' ? cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1 : cache[key] ? 0 : -1;
        }
        function cachePush(value) {
            var cache = this.cache, type = typeof value;
            if (type == 'boolean' || value == null) {
                cache[value] = true;
            } else {
                if (type != 'number' && type != 'string') {
                    type = 'object';
                }
                var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                if (type == 'object') {
                    if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
                        cache[type] = false;
                    }
                } else {
                    typeCache[key] = true;
                }
            }
        }
        function charAtCallback(value) {
            return value.charCodeAt(0);
        }
        function compareAscending(a, b) {
            var ai = a.index, bi = b.index;
            a = a.criteria;
            b = b.criteria;
            if (a !== b) {
                if (a > b || typeof a == 'undefined') {
                    return 1;
                }
                if (a < b || typeof b == 'undefined') {
                    return -1;
                }
            }
            return ai < bi ? -1 : 1;
        }
        function createCache(array) {
            var index = -1, length = array.length;
            var cache = getObject();
            cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
            var result = getObject();
            result.array = array;
            result.cache = cache;
            result.push = cachePush;
            while (++index < length) {
                result.push(array[index]);
            }
            return cache.object === false ? (releaseObject(result), null) : result;
        }
        function escapeStringChar(match) {
            return '\\' + stringEscapes[match];
        }
        function getArray() {
            return arrayPool.pop() || [];
        }
        function getObject() {
            return objectPool.pop() || {
                'args': '',
                'array': null,
                'bottom': '',
                'cache': null,
                'criteria': null,
                'false': false,
                'firstArg': '',
                'index': 0,
                'init': '',
                'leading': false,
                'loop': '',
                'maxWait': 0,
                'null': false,
                'number': null,
                'object': null,
                'push': null,
                'shadowedProps': null,
                'string': null,
                'top': '',
                'trailing': false,
                'true': false,
                'undefined': false,
                'useHas': false,
                'useKeys': false,
                'value': null
            };
        }
        function isNode(value) {
            return typeof value.toString != 'function' && typeof (value + '') == 'string';
        }
        function noop() {
        }
        function releaseArray(array) {
            array.length = 0;
            if (arrayPool.length < maxPoolSize) {
                arrayPool.push(array);
            }
        }
        function releaseObject(object) {
            var cache = object.cache;
            if (cache) {
                releaseObject(cache);
            }
            object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
            if (objectPool.length < maxPoolSize) {
                objectPool.push(object);
            }
        }
        function slice(array, start, end) {
            start || (start = 0);
            if (typeof end == 'undefined') {
                end = array ? array.length : 0;
            }
            var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = array[start + index];
            }
            return result;
        }
        function runInContext(context) {
            context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;
            var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
            var arrayRef = [];
            var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
            var oldDash = context._;
            var reNative = RegExp('^' + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');
            var ceil = Math.ceil, clearTimeout = context.clearTimeout, concat = arrayRef.concat, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setImmediate = context.setImmediate, setTimeout = context.setTimeout, toString = objectProto.toString;
            var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice;
            var isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
            var ctorByClass = {};
            ctorByClass[arrayClass] = Array;
            ctorByClass[boolClass] = Boolean;
            ctorByClass[dateClass] = Date;
            ctorByClass[funcClass] = Function;
            ctorByClass[objectClass] = Object;
            ctorByClass[numberClass] = Number;
            ctorByClass[regexpClass] = RegExp;
            ctorByClass[stringClass] = String;
            var nonEnumProps = {};
            nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
                'constructor': true,
                'toLocaleString': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
                'constructor': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
                'constructor': true,
                'toString': true
            };
            nonEnumProps[objectClass] = { 'constructor': true };
            (function () {
                var length = shadowedProps.length;
                while (length--) {
                    var prop = shadowedProps[length];
                    for (var className in nonEnumProps) {
                        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], prop)) {
                            nonEnumProps[className][prop] = false;
                        }
                    }
                }
            }());
            function lodash(value) {
                return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
            }
            function lodashWrapper(value) {
                this.__wrapped__ = value;
            }
            lodashWrapper.prototype = lodash.prototype;
            var support = lodash.support = {};
            (function () {
                var ctor = function () {
                        this.x = 1;
                    }, object = {
                        '0': 1,
                        'length': 1
                    }, props = [];
                ctor.prototype = {
                    'valueOf': 1,
                    'y': 1
                };
                for (var prop in new ctor()) {
                    props.push(prop);
                }
                for (prop in arguments) {
                }
                support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
                support.argsClass = isArguments(arguments);
                support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
                support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
                support.fastBind = nativeBind && !isV8;
                support.ownLast = props[0] != 'x';
                support.nonEnumArgs = prop != 0;
                support.nonEnumShadows = !/valueOf/.test(props);
                support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
                support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';
                try {
                    support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
                } catch (e) {
                    support.nodeClass = true;
                }
            }(1));
            lodash.templateSettings = {
                'escape': /<%-([\s\S]+?)%>/g,
                'evaluate': /<%([\s\S]+?)%>/g,
                'interpolate': reInterpolate,
                'variable': '',
                'imports': { '_': lodash }
            };
            var iteratorTemplate = function (obj) {
                var __p = 'var index, iterable = ' + obj.firstArg + ', result = ' + obj.init + ';\nif (!iterable) return result;\n' + obj.top + ';';
                if (obj.array) {
                    __p += '\nvar length = iterable.length; index = -1;\nif (' + obj.array + ') {  ';
                    if (support.unindexedChars) {
                        __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
                    }
                    __p += '\n  while (++index < length) {\n    ' + obj.loop + ';\n  }\n}\nelse {  ';
                } else if (support.nonEnumArgs) {
                    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' + obj.loop + ';\n    }\n  } else {  ';
                }
                if (support.enumPrototypes) {
                    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
                }
                if (support.enumErrorProps) {
                    __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
                }
                var conditions = [];
                if (support.enumPrototypes) {
                    conditions.push('!(skipProto && index == "prototype")');
                }
                if (support.enumErrorProps) {
                    conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
                }
                if (obj.useHas && obj.useKeys) {
                    __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
                    if (conditions.length) {
                        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
                    }
                    __p += obj.loop + ';    ';
                    if (conditions.length) {
                        __p += '\n    }';
                    }
                    __p += '\n  }  ';
                } else {
                    __p += '\n  for (index in iterable) {\n';
                    if (obj.useHas) {
                        conditions.push('hasOwnProperty.call(iterable, index)');
                    }
                    if (conditions.length) {
                        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
                    }
                    __p += obj.loop + ';    ';
                    if (conditions.length) {
                        __p += '\n    }';
                    }
                    __p += '\n  }    ';
                    if (support.nonEnumShadows) {
                        __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
                        for (k = 0; k < 7; k++) {
                            __p += '\n    index = \'' + obj.shadowedProps[k] + '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
                            if (!obj.useHas) {
                                __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
                            }
                            __p += ') {\n      ' + obj.loop + ';\n    }      ';
                        }
                        __p += '\n  }    ';
                    }
                }
                if (obj.array || support.nonEnumArgs) {
                    __p += '\n}';
                }
                __p += obj.bottom + ';\nreturn result';
                return __p;
            };
            var defaultsIteratorOptions = {
                    'args': 'object, source, guard',
                    'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + '    argsLength = typeof guard == \'number\' ? 2 : args.length;\n' + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
                    'loop': 'if (typeof result[index] == \'undefined\') result[index] = iterable[index]',
                    'bottom': '  }\n}'
                };
            var eachIteratorOptions = {
                    'args': 'collection, callback, thisArg',
                    'top': 'callback = callback && typeof thisArg == \'undefined\' ? callback : lodash.createCallback(callback, thisArg)',
                    'array': 'typeof length == \'number\'',
                    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
                };
            var forOwnIteratorOptions = {
                    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
                    'array': false
                };
            function createBound(func, thisArg, partialArgs, indicator) {
                var isFunc = isFunction(func), isPartial = !partialArgs, key = thisArg;
                if (isPartial) {
                    var rightIndicator = indicator;
                    partialArgs = thisArg;
                } else if (!isFunc) {
                    if (!indicator) {
                        throw new TypeError();
                    }
                    thisArg = func;
                }
                function bound() {
                    var args = arguments, thisBinding = isPartial ? this : thisArg;
                    if (!isFunc) {
                        func = thisArg[key];
                    }
                    if (partialArgs.length) {
                        args = args.length ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
                    }
                    if (this instanceof bound) {
                        thisBinding = createObject(func.prototype);
                        var result = func.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding;
                    }
                    return func.apply(thisBinding, args);
                }
                return bound;
            }
            function createIterator() {
                var data = getObject();
                data.shadowedProps = shadowedProps;
                data.array = data.bottom = data.loop = data.top = '';
                data.init = 'iterable';
                data.useHas = true;
                data.useKeys = !!keys;
                for (var object, index = 0; object = arguments[index]; index++) {
                    for (var key in object) {
                        data[key] = object[key];
                    }
                }
                var args = data.args;
                data.firstArg = /^[^,]+/.exec(args)[0];
                var factory = Function('errorClass, errorProto, hasOwnProperty, isArguments, isArray, ' + 'isString, keys, lodash, objectProto, objectTypes, nonEnumProps, ' + 'stringClass, stringProto, toString', 'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}');
                releaseObject(data);
                return factory(errorClass, errorProto, hasOwnProperty, isArguments, isArray, isString, keys, lodash, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
            }
            function createObject(prototype) {
                return isObject(prototype) ? nativeCreate(prototype) : {};
            }
            if (!nativeCreate) {
                var createObject = function (prototype) {
                    if (isObject(prototype)) {
                        noop.prototype = prototype;
                        var result = new noop();
                        noop.prototype = null;
                    }
                    return result || {};
                };
            }
            function escapeHtmlChar(match) {
                return htmlEscapes[match];
            }
            function getIndexOf(array, value, fromIndex) {
                var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
                return result;
            }
            function overloadWrapper(func) {
                return function (array, flag, callback, thisArg) {
                    if (typeof flag != 'boolean' && flag != null) {
                        thisArg = callback;
                        callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
                        flag = false;
                    }
                    if (callback != null) {
                        callback = lodash.createCallback(callback, thisArg);
                    }
                    return func(array, flag, callback, thisArg);
                };
            }
            function shimIsPlainObject(value) {
                var ctor, result;
                if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
                    return false;
                }
                if (support.ownLast) {
                    forIn(value, function (value, key, object) {
                        result = hasOwnProperty.call(object, key);
                        return false;
                    });
                    return result !== false;
                }
                forIn(value, function (value, key) {
                    result = key;
                });
                return result === undefined || hasOwnProperty.call(value, result);
            }
            function unescapeHtmlChar(match) {
                return htmlUnescapes[match];
            }
            function isArguments(value) {
                return toString.call(value) == argsClass;
            }
            if (!support.argsClass) {
                isArguments = function (value) {
                    return value ? hasOwnProperty.call(value, 'callee') : false;
                };
            }
            var isArray = nativeIsArray || function (value) {
                    return value ? typeof value == 'object' && toString.call(value) == arrayClass : false;
                };
            var shimKeys = createIterator({
                    'args': 'object',
                    'init': '[]',
                    'top': 'if (!(objectTypes[typeof object])) return result',
                    'loop': 'result.push(index)'
                });
            var keys = !nativeKeys ? shimKeys : function (object) {
                    if (!isObject(object)) {
                        return [];
                    }
                    if (support.enumPrototypes && typeof object == 'function' || support.nonEnumArgs && object.length && isArguments(object)) {
                        return shimKeys(object);
                    }
                    return nativeKeys(object);
                };
            var basicEach = createIterator(eachIteratorOptions);
            var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    '\'': '&#39;'
                };
            var htmlUnescapes = invert(htmlEscapes);
            var assign = createIterator(defaultsIteratorOptions, {
                    'top': defaultsIteratorOptions.top.replace(';', ';\n' + 'if (argsLength > 3 && typeof args[argsLength - 2] == \'function\') {\n' + '  var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + '} else if (argsLength > 2 && typeof args[argsLength - 1] == \'function\') {\n' + '  callback = args[--argsLength];\n' + '}'),
                    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
                });
            function clone(value, deep, callback, thisArg, stackA, stackB) {
                var result = value;
                if (typeof deep != 'boolean' && deep != null) {
                    thisArg = callback;
                    callback = deep;
                    deep = false;
                }
                if (typeof callback == 'function') {
                    callback = typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg, 1);
                    result = callback(result);
                    if (typeof result != 'undefined') {
                        return result;
                    }
                    result = value;
                }
                var isObj = isObject(result);
                if (isObj) {
                    var className = toString.call(result);
                    if (!cloneableClasses[className] || !support.nodeClass && isNode(result)) {
                        return result;
                    }
                    var isArr = isArray(result);
                }
                if (!isObj || !deep) {
                    return isObj ? isArr ? slice(result) : assign({}, result) : result;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                case boolClass:
                case dateClass:
                    return new ctor(+result);
                case numberClass:
                case stringClass:
                    return new ctor(result);
                case regexpClass:
                    return ctor(result.source, reFlags.exec(result));
                }
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(result.length) : {};
                if (isArr) {
                    if (hasOwnProperty.call(value, 'index')) {
                        result.index = value.index;
                    }
                    if (hasOwnProperty.call(value, 'input')) {
                        result.input = value.input;
                    }
                }
                stackA.push(value);
                stackB.push(result);
                (isArr ? basicEach : forOwn)(value, function (objValue, key) {
                    result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
                });
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return result;
            }
            function cloneDeep(value, callback, thisArg) {
                return clone(value, true, callback, thisArg);
            }
            var defaults = createIterator(defaultsIteratorOptions);
            function findKey(object, callback, thisArg) {
                var result;
                callback = lodash.createCallback(callback, thisArg);
                forOwn(object, function (value, key, object) {
                    if (callback(value, key, object)) {
                        result = key;
                        return false;
                    }
                });
                return result;
            }
            var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, { 'useHas': false });
            var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
            function functions(object) {
                var result = [];
                forIn(object, function (value, key) {
                    if (isFunction(value)) {
                        result.push(key);
                    }
                });
                return result.sort();
            }
            function has(object, property) {
                return object ? hasOwnProperty.call(object, property) : false;
            }
            function invert(object) {
                var index = -1, props = keys(object), length = props.length, result = {};
                while (++index < length) {
                    var key = props[index];
                    result[object[key]] = key;
                }
                return result;
            }
            function isBoolean(value) {
                return value === true || value === false || toString.call(value) == boolClass;
            }
            function isDate(value) {
                return value ? typeof value == 'object' && toString.call(value) == dateClass : false;
            }
            function isElement(value) {
                return value ? value.nodeType === 1 : false;
            }
            function isEmpty(value) {
                var result = true;
                if (!value) {
                    return result;
                }
                var className = toString.call(value), length = value.length;
                if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
                    return !length;
                }
                forOwn(value, function () {
                    return result = false;
                });
                return result;
            }
            function isEqual(a, b, callback, thisArg, stackA, stackB) {
                var whereIndicator = callback === indicatorObject;
                if (typeof callback == 'function' && !whereIndicator) {
                    callback = lodash.createCallback(callback, thisArg, 2);
                    var result = callback(a, b);
                    if (typeof result != 'undefined') {
                        return !!result;
                    }
                }
                if (a === b) {
                    return a !== 0 || 1 / a == 1 / b;
                }
                var type = typeof a, otherType = typeof b;
                if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
                    return false;
                }
                if (a == null || b == null) {
                    return a === b;
                }
                var className = toString.call(a), otherClass = toString.call(b);
                if (className == argsClass) {
                    className = objectClass;
                }
                if (otherClass == argsClass) {
                    otherClass = objectClass;
                }
                if (className != otherClass) {
                    return false;
                }
                switch (className) {
                case boolClass:
                case dateClass:
                    return +a == +b;
                case numberClass:
                    return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
                case regexpClass:
                case stringClass:
                    return a == String(b);
                }
                var isArr = className == arrayClass;
                if (!isArr) {
                    if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
                        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
                    }
                    if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
                        return false;
                    }
                    var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
                    if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
                        return false;
                    }
                }
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == a) {
                        return stackB[length] == b;
                    }
                }
                var size = 0;
                result = true;
                stackA.push(a);
                stackB.push(b);
                if (isArr) {
                    length = a.length;
                    size = b.length;
                    result = size == a.length;
                    if (!result && !whereIndicator) {
                        return result;
                    }
                    while (size--) {
                        var index = length, value = b[size];
                        if (whereIndicator) {
                            while (index--) {
                                if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
                            break;
                        }
                    }
                    return result;
                }
                forIn(b, function (value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
                    }
                });
                if (result && !whereIndicator) {
                    forIn(a, function (value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return result;
            }
            function isFinite(value) {
                return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
            }
            function isFunction(value) {
                return typeof value == 'function';
            }
            if (isFunction(/x/)) {
                isFunction = function (value) {
                    return typeof value == 'function' && toString.call(value) == funcClass;
                };
            }
            function isObject(value) {
                return !!(value && objectTypes[typeof value]);
            }
            function isNaN(value) {
                return isNumber(value) && value != +value;
            }
            function isNull(value) {
                return value === null;
            }
            function isNumber(value) {
                return typeof value == 'number' || toString.call(value) == numberClass;
            }
            var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
                    if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
                        return false;
                    }
                    var valueOf = value.valueOf, objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                    return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                };
            function isRegExp(value) {
                return !!(value && objectTypes[typeof value]) && toString.call(value) == regexpClass;
            }
            function isString(value) {
                return typeof value == 'string' || toString.call(value) == stringClass;
            }
            function isUndefined(value) {
                return typeof value == 'undefined';
            }
            function merge(object, source, deepIndicator) {
                var args = arguments, index = 0, length = 2;
                if (!isObject(object)) {
                    return object;
                }
                if (deepIndicator === indicatorObject) {
                    var callback = args[3], stackA = args[4], stackB = args[5];
                } else {
                    var initedStack = true;
                    stackA = getArray();
                    stackB = getArray();
                    if (typeof deepIndicator != 'number') {
                        length = args.length;
                    }
                    if (length > 3 && typeof args[length - 2] == 'function') {
                        callback = lodash.createCallback(args[--length - 1], args[length--], 2);
                    } else if (length > 2 && typeof args[length - 1] == 'function') {
                        callback = args[--length];
                    }
                }
                while (++index < length) {
                    (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
                        var found, isArr, result = source, value = object[key];
                        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                            var stackLength = stackA.length;
                            while (stackLength--) {
                                if (found = stackA[stackLength] == source) {
                                    value = stackB[stackLength];
                                    break;
                                }
                            }
                            if (!found) {
                                var isShallow;
                                if (callback) {
                                    result = callback(value, source);
                                    if (isShallow = typeof result != 'undefined') {
                                        value = result;
                                    }
                                }
                                if (!isShallow) {
                                    value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                }
                                stackA.push(source);
                                stackB.push(value);
                                if (!isShallow) {
                                    value = merge(value, source, indicatorObject, callback, stackA, stackB);
                                }
                            }
                        } else {
                            if (callback) {
                                result = callback(value, source);
                                if (typeof result == 'undefined') {
                                    result = source;
                                }
                            }
                            if (typeof result != 'undefined') {
                                value = result;
                            }
                        }
                        object[key] = value;
                    });
                }
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return object;
            }
            function omit(object, callback, thisArg) {
                var indexOf = getIndexOf(), isFunc = typeof callback == 'function', result = {};
                if (isFunc) {
                    callback = lodash.createCallback(callback, thisArg);
                } else {
                    var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
                }
                forIn(object, function (value, key, object) {
                    if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
                        result[key] = value;
                    }
                });
                return result;
            }
            function pairs(object) {
                var index = -1, props = keys(object), length = props.length, result = Array(length);
                while (++index < length) {
                    var key = props[index];
                    result[index] = [
                        key,
                        object[key]
                    ];
                }
                return result;
            }
            function pick(object, callback, thisArg) {
                var result = {};
                if (typeof callback != 'function') {
                    var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = isObject(object) ? props.length : 0;
                    while (++index < length) {
                        var key = props[index];
                        if (key in object) {
                            result[key] = object[key];
                        }
                    }
                } else {
                    callback = lodash.createCallback(callback, thisArg);
                    forIn(object, function (value, key, object) {
                        if (callback(value, key, object)) {
                            result[key] = value;
                        }
                    });
                }
                return result;
            }
            function transform(object, callback, accumulator, thisArg) {
                var isArr = isArray(object);
                callback = lodash.createCallback(callback, thisArg, 4);
                if (accumulator == null) {
                    if (isArr) {
                        accumulator = [];
                    } else {
                        var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                        accumulator = createObject(proto);
                    }
                }
                (isArr ? basicEach : forOwn)(object, function (value, index, object) {
                    return callback(accumulator, value, index, object);
                });
                return accumulator;
            }
            function values(object) {
                var index = -1, props = keys(object), length = props.length, result = Array(length);
                while (++index < length) {
                    result[index] = object[props[index]];
                }
                return result;
            }
            function at(collection) {
                var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = props.length, result = Array(length);
                if (support.unindexedChars && isString(collection)) {
                    collection = collection.split('');
                }
                while (++index < length) {
                    result[index] = collection[props[index]];
                }
                return result;
            }
            function contains(collection, target, fromIndex) {
                var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                if (length && typeof length == 'number') {
                    result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                } else {
                    basicEach(collection, function (value) {
                        if (++index >= fromIndex) {
                            return !(result = value === target);
                        }
                    });
                }
                return result;
            }
            function countBy(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    key = String(callback(value, key, collection));
                    hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                });
                return result;
            }
            function every(collection, callback, thisArg) {
                var result = true;
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (!(result = !!callback(collection[index], index, collection))) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        return result = !!callback(value, index, collection);
                    });
                }
                return result;
            }
            function filter(collection, callback, thisArg) {
                var result = [];
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (callback(value, index, collection)) {
                            result.push(value);
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        if (callback(value, index, collection)) {
                            result.push(value);
                        }
                    });
                }
                return result;
            }
            function find(collection, callback, thisArg) {
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (callback(value, index, collection)) {
                            return value;
                        }
                    }
                } else {
                    var result;
                    basicEach(collection, function (value, index, collection) {
                        if (callback(value, index, collection)) {
                            result = value;
                            return false;
                        }
                    });
                    return result;
                }
            }
            function forEach(collection, callback, thisArg) {
                if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (callback(collection[index], index, collection) === false) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, callback, thisArg);
                }
                return collection;
            }
            function groupBy(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    key = String(callback(value, key, collection));
                    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                });
                return result;
            }
            function invoke(collection, methodName) {
                var args = nativeSlice.call(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                forEach(collection, function (value) {
                    result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                });
                return result;
            }
            function map(collection, callback, thisArg) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    while (++index < length) {
                        result[index] = callback(collection[index], index, collection);
                    }
                } else {
                    basicEach(collection, function (value, key, collection) {
                        result[++index] = callback(value, key, collection);
                    });
                }
                return result;
            }
            function max(collection, callback, thisArg) {
                var computed = -Infinity, result = computed;
                if (!callback && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (value > result) {
                            result = value;
                        }
                    }
                } else {
                    callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
                    basicEach(collection, function (value, index, collection) {
                        var current = callback(value, index, collection);
                        if (current > computed) {
                            computed = current;
                            result = value;
                        }
                    });
                }
                return result;
            }
            function min(collection, callback, thisArg) {
                var computed = Infinity, result = computed;
                if (!callback && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (value < result) {
                            result = value;
                        }
                    }
                } else {
                    callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
                    basicEach(collection, function (value, index, collection) {
                        var current = callback(value, index, collection);
                        if (current < computed) {
                            computed = current;
                            result = value;
                        }
                    });
                }
                return result;
            }
            var pluck = map;
            function reduce(collection, callback, accumulator, thisArg) {
                var noaccum = arguments.length < 3;
                callback = lodash.createCallback(callback, thisArg, 4);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    if (noaccum) {
                        accumulator = collection[++index];
                    }
                    while (++index < length) {
                        accumulator = callback(accumulator, collection[index], index, collection);
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                    });
                }
                return accumulator;
            }
            function reduceRight(collection, callback, accumulator, thisArg) {
                var iterable = collection, length = collection ? collection.length : 0, noaccum = arguments.length < 3;
                if (typeof length != 'number') {
                    var props = keys(collection);
                    length = props.length;
                } else if (support.unindexedChars && isString(collection)) {
                    iterable = collection.split('');
                }
                callback = lodash.createCallback(callback, thisArg, 4);
                forEach(collection, function (value, index, collection) {
                    index = props ? props[--length] : --length;
                    accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
                });
                return accumulator;
            }
            function reject(collection, callback, thisArg) {
                callback = lodash.createCallback(callback, thisArg);
                return filter(collection, function (value, index, collection) {
                    return !callback(value, index, collection);
                });
            }
            function shuffle(collection) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                forEach(collection, function (value) {
                    var rand = floor(nativeRandom() * (++index + 1));
                    result[index] = result[rand];
                    result[rand] = value;
                });
                return result;
            }
            function size(collection) {
                var length = collection ? collection.length : 0;
                return typeof length == 'number' ? length : keys(collection).length;
            }
            function some(collection, callback, thisArg) {
                var result;
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (result = callback(collection[index], index, collection)) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        return !(result = callback(value, index, collection));
                    });
                }
                return !!result;
            }
            function sortBy(collection, callback, thisArg) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    var object = result[++index] = getObject();
                    object.criteria = callback(value, key, collection);
                    object.index = index;
                    object.value = value;
                });
                length = result.length;
                result.sort(compareAscending);
                while (length--) {
                    var object = result[length];
                    result[length] = object.value;
                    releaseObject(object);
                }
                return result;
            }
            function toArray(collection) {
                if (collection && typeof collection.length == 'number') {
                    return support.unindexedChars && isString(collection) ? collection.split('') : slice(collection);
                }
                return values(collection);
            }
            var where = filter;
            function compact(array) {
                var index = -1, length = array ? array.length : 0, result = [];
                while (++index < length) {
                    var value = array[index];
                    if (value) {
                        result.push(value);
                    }
                }
                return result;
            }
            function difference(array) {
                var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), result = [];
                var isLarge = length >= largeArraySize && indexOf === basicIndexOf;
                if (isLarge) {
                    var cache = createCache(seen);
                    if (cache) {
                        indexOf = cacheIndexOf;
                        seen = cache;
                    } else {
                        isLarge = false;
                    }
                }
                while (++index < length) {
                    var value = array[index];
                    if (indexOf(seen, value) < 0) {
                        result.push(value);
                    }
                }
                if (isLarge) {
                    releaseObject(seen);
                }
                return result;
            }
            function findIndex(array, callback, thisArg) {
                var index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg);
                while (++index < length) {
                    if (callback(array[index], index, array)) {
                        return index;
                    }
                }
                return -1;
            }
            function first(array, callback, thisArg) {
                if (array) {
                    var n = 0, length = array.length;
                    if (typeof callback != 'number' && callback != null) {
                        var index = -1;
                        callback = lodash.createCallback(callback, thisArg);
                        while (++index < length && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array[0];
                        }
                    }
                    return slice(array, 0, nativeMin(nativeMax(0, n), length));
                }
            }
            var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
                    var index = -1, length = array ? array.length : 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (callback) {
                            value = callback(value, index, array);
                        }
                        if (isArray(value)) {
                            push.apply(result, isShallow ? value : flatten(value));
                        } else {
                            result.push(value);
                        }
                    }
                    return result;
                });
            function indexOf(array, value, fromIndex) {
                if (typeof fromIndex == 'number') {
                    var length = array ? array.length : 0;
                    fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                } else if (fromIndex) {
                    var index = sortedIndex(array, value);
                    return array[index] === value ? index : -1;
                }
                return array ? basicIndexOf(array, value, fromIndex) : -1;
            }
            function initial(array, callback, thisArg) {
                if (!array) {
                    return [];
                }
                var n = 0, length = array.length;
                if (typeof callback != 'number' && callback != null) {
                    var index = length;
                    callback = lodash.createCallback(callback, thisArg);
                    while (index-- && callback(array[index], index, array)) {
                        n++;
                    }
                } else {
                    n = callback == null || thisArg ? 1 : callback || n;
                }
                return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
            }
            function intersection(array) {
                var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray();
                while (++argsIndex < argsLength) {
                    var value = args[argsIndex];
                    caches[argsIndex] = indexOf === basicIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
                }
                outer:
                    while (++index < length) {
                        var cache = caches[0];
                        value = array[index];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                            argsIndex = argsLength;
                            (cache || seen).push(value);
                            while (--argsIndex) {
                                cache = caches[argsIndex];
                                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                    continue outer;
                                }
                            }
                            result.push(value);
                        }
                    }
                while (argsLength--) {
                    cache = caches[argsLength];
                    if (cache) {
                        releaseObject(cache);
                    }
                }
                releaseArray(caches);
                releaseArray(seen);
                return result;
            }
            function last(array, callback, thisArg) {
                if (array) {
                    var n = 0, length = array.length;
                    if (typeof callback != 'number' && callback != null) {
                        var index = length;
                        callback = lodash.createCallback(callback, thisArg);
                        while (index-- && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array[length - 1];
                        }
                    }
                    return slice(array, nativeMax(0, length - n));
                }
            }
            function lastIndexOf(array, value, fromIndex) {
                var index = array ? array.length : 0;
                if (typeof fromIndex == 'number') {
                    index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                }
                while (index--) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }
            function range(start, end, step) {
                start = +start || 0;
                step = +step || 1;
                if (end == null) {
                    end = start;
                    start = 0;
                }
                var index = -1, length = nativeMax(0, ceil((end - start) / step)), result = Array(length);
                while (++index < length) {
                    result[index] = start;
                    start += step;
                }
                return result;
            }
            function rest(array, callback, thisArg) {
                if (typeof callback != 'number' && callback != null) {
                    var n = 0, index = -1, length = array ? array.length : 0;
                    callback = lodash.createCallback(callback, thisArg);
                    while (++index < length && callback(array[index], index, array)) {
                        n++;
                    }
                } else {
                    n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                }
                return slice(array, n);
            }
            function sortedIndex(array, value, callback, thisArg) {
                var low = 0, high = array ? array.length : low;
                callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                value = callback(value);
                while (low < high) {
                    var mid = low + high >>> 1;
                    callback(array[mid]) < value ? low = mid + 1 : high = mid;
                }
                return low;
            }
            function union(array) {
                if (!isArray(array)) {
                    arguments[0] = array ? nativeSlice.call(array) : arrayRef;
                }
                return uniq(concat.apply(arrayRef, arguments));
            }
            var uniq = overloadWrapper(function (array, isSorted, callback) {
                    var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                    var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf, seen = callback || isLarge ? getArray() : result;
                    if (isLarge) {
                        var cache = createCache(seen);
                        if (cache) {
                            indexOf = cacheIndexOf;
                            seen = cache;
                        } else {
                            isLarge = false;
                            seen = callback ? seen : (releaseArray(seen), result);
                        }
                    }
                    while (++index < length) {
                        var value = array[index], computed = callback ? callback(value, index, array) : value;
                        if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                            if (callback || isLarge) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                    }
                    if (isLarge) {
                        releaseArray(seen.array);
                        releaseObject(seen);
                    } else if (callback) {
                        releaseArray(seen);
                    }
                    return result;
                });
            function unzip(array) {
                var index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
                while (++index < length) {
                    result[index] = pluck(array, index);
                }
                return result;
            }
            function without(array) {
                return difference(array, nativeSlice.call(arguments, 1));
            }
            function zip(array) {
                return array ? unzip(arguments) : [];
            }
            function zipObject(keys, values) {
                var index = -1, length = keys ? keys.length : 0, result = {};
                while (++index < length) {
                    var key = keys[index];
                    if (values) {
                        result[key] = values[index];
                    } else {
                        result[key[0]] = key[1];
                    }
                }
                return result;
            }
            function after(n, func) {
                if (n < 1) {
                    return func();
                }
                return function () {
                    if (--n < 1) {
                        return func.apply(this, arguments);
                    }
                };
            }
            function bind(func, thisArg) {
                return support.fastBind || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, nativeSlice.call(arguments, 2));
            }
            function bindAll(object) {
                var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object), index = -1, length = funcs.length;
                while (++index < length) {
                    var key = funcs[index];
                    object[key] = bind(object[key], object);
                }
                return object;
            }
            function bindKey(object, key) {
                return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
            }
            function compose() {
                var funcs = arguments;
                return function () {
                    var args = arguments, length = funcs.length;
                    while (length--) {
                        args = [funcs[length].apply(this, args)];
                    }
                    return args[0];
                };
            }
            function createCallback(func, thisArg, argCount) {
                if (func == null) {
                    return identity;
                }
                var type = typeof func;
                if (type != 'function') {
                    if (type != 'object') {
                        return function (object) {
                            return object[func];
                        };
                    }
                    var props = keys(func);
                    return function (object) {
                        var length = props.length, result = false;
                        while (length--) {
                            if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
                                break;
                            }
                        }
                        return result;
                    };
                }
                if (typeof thisArg == 'undefined' || reThis && !reThis.test(fnToString.call(func))) {
                    return func;
                }
                if (argCount === 1) {
                    return function (value) {
                        return func.call(thisArg, value);
                    };
                }
                if (argCount === 2) {
                    return function (a, b) {
                        return func.call(thisArg, a, b);
                    };
                }
                if (argCount === 4) {
                    return function (accumulator, value, index, collection) {
                        return func.call(thisArg, accumulator, value, index, collection);
                    };
                }
                return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
            }
            function debounce(func, wait, options) {
                var args, result, thisArg, callCount = 0, lastCalled = 0, maxWait = false, maxTimeoutId = null, timeoutId = null, trailing = true;
                function clear() {
                    clearTimeout(maxTimeoutId);
                    clearTimeout(timeoutId);
                    callCount = 0;
                    maxTimeoutId = timeoutId = null;
                }
                function delayed() {
                    var isCalled = trailing && (!leading || callCount > 1);
                    clear();
                    if (isCalled) {
                        if (maxWait !== false) {
                            lastCalled = new Date();
                        }
                        result = func.apply(thisArg, args);
                    }
                }
                function maxDelayed() {
                    clear();
                    if (trailing || maxWait !== wait) {
                        lastCalled = new Date();
                        result = func.apply(thisArg, args);
                    }
                }
                wait = nativeMax(0, wait || 0);
                if (options === true) {
                    var leading = true;
                    trailing = false;
                } else if (isObject(options)) {
                    leading = options.leading;
                    maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
                    trailing = 'trailing' in options ? options.trailing : trailing;
                }
                return function () {
                    args = arguments;
                    thisArg = this;
                    callCount++;
                    clearTimeout(timeoutId);
                    if (maxWait === false) {
                        if (leading && callCount < 2) {
                            result = func.apply(thisArg, args);
                        }
                    } else {
                        var now = new Date();
                        if (!maxTimeoutId && !leading) {
                            lastCalled = now;
                        }
                        var remaining = maxWait - (now - lastCalled);
                        if (remaining <= 0) {
                            clearTimeout(maxTimeoutId);
                            maxTimeoutId = null;
                            lastCalled = now;
                            result = func.apply(thisArg, args);
                        } else if (!maxTimeoutId) {
                            maxTimeoutId = setTimeout(maxDelayed, remaining);
                        }
                    }
                    if (wait !== maxWait) {
                        timeoutId = setTimeout(delayed, wait);
                    }
                    return result;
                };
            }
            function defer(func) {
                var args = nativeSlice.call(arguments, 1);
                return setTimeout(function () {
                    func.apply(undefined, args);
                }, 1);
            }
            if (isV8 && freeModule && typeof setImmediate == 'function') {
                defer = bind(setImmediate, context);
            }
            function delay(func, wait) {
                var args = nativeSlice.call(arguments, 2);
                return setTimeout(function () {
                    func.apply(undefined, args);
                }, wait);
            }
            function memoize(func, resolver) {
                function memoized() {
                    var cache = memoized.cache, key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);
                    return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                }
                memoized.cache = {};
                return memoized;
            }
            function once(func) {
                var ran, result;
                return function () {
                    if (ran) {
                        return result;
                    }
                    ran = true;
                    result = func.apply(this, arguments);
                    func = null;
                    return result;
                };
            }
            function partial(func) {
                return createBound(func, nativeSlice.call(arguments, 1));
            }
            function partialRight(func) {
                return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
            }
            function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if (options === false) {
                    leading = false;
                } else if (isObject(options)) {
                    leading = 'leading' in options ? options.leading : leading;
                    trailing = 'trailing' in options ? options.trailing : trailing;
                }
                options = getObject();
                options.leading = leading;
                options.maxWait = wait;
                options.trailing = trailing;
                var result = debounce(func, wait, options);
                releaseObject(options);
                return result;
            }
            function wrap(value, wrapper) {
                return function () {
                    var args = [value];
                    push.apply(args, arguments);
                    return wrapper.apply(this, args);
                };
            }
            function escape(string) {
                return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
            }
            function identity(value) {
                return value;
            }
            function mixin(object) {
                forEach(functions(object), function (methodName) {
                    var func = lodash[methodName] = object[methodName];
                    lodash.prototype[methodName] = function () {
                        var value = this.__wrapped__, args = [value];
                        push.apply(args, arguments);
                        var result = func.apply(lodash, args);
                        return value && typeof value == 'object' && value === result ? this : new lodashWrapper(result);
                    };
                });
            }
            function noConflict() {
                context._ = oldDash;
                return this;
            }
            var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
                    return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
                };
            function random(min, max) {
                if (min == null && max == null) {
                    max = 1;
                }
                min = +min || 0;
                if (max == null) {
                    max = min;
                    min = 0;
                } else {
                    max = +max || 0;
                }
                var rand = nativeRandom();
                return min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max) : min + floor(rand * (max - min + 1));
            }
            function result(object, property) {
                var value = object ? object[property] : undefined;
                return isFunction(value) ? object[property]() : value;
            }
            function template(text, data, options) {
                var settings = lodash.templateSettings;
                text || (text = '');
                options = defaults({}, options, settings);
                var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
                var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                    if (escapeValue) {
                        source += '\' +\n__e(' + escapeValue + ') +\n\'';
                    }
                    if (evaluateValue) {
                        isEvaluating = true;
                        source += '\';\n' + evaluateValue + ';\n__p += \'';
                    }
                    if (interpolateValue) {
                        source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                    }
                    index = offset + match.length;
                    return match;
                });
                source += '\';\n';
                var variable = options.variable, hasVariable = variable;
                if (!hasVariable) {
                    variable = 'obj';
                    source = 'with (' + variable + ') {\n' + source + '\n}\n';
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + 'var __t, __p = \'\', __e = _.escape' + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
                var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
                try {
                    var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                } catch (e) {
                    e.source = source;
                    throw e;
                }
                if (data) {
                    return result(data);
                }
                result.source = source;
                return result;
            }
            function times(n, callback, thisArg) {
                n = (n = +n) > -1 ? n : 0;
                var index = -1, result = Array(n);
                callback = lodash.createCallback(callback, thisArg, 1);
                while (++index < n) {
                    result[index] = callback(index);
                }
                return result;
            }
            function unescape(string) {
                return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
            }
            function uniqueId(prefix) {
                var id = ++idCounter;
                return String(prefix == null ? '' : prefix) + id;
            }
            function tap(value, interceptor) {
                interceptor(value);
                return value;
            }
            function wrapperToString() {
                return String(this.__wrapped__);
            }
            function wrapperValueOf() {
                return this.__wrapped__;
            }
            lodash.after = after;
            lodash.assign = assign;
            lodash.at = at;
            lodash.bind = bind;
            lodash.bindAll = bindAll;
            lodash.bindKey = bindKey;
            lodash.compact = compact;
            lodash.compose = compose;
            lodash.countBy = countBy;
            lodash.createCallback = createCallback;
            lodash.debounce = debounce;
            lodash.defaults = defaults;
            lodash.defer = defer;
            lodash.delay = delay;
            lodash.difference = difference;
            lodash.filter = filter;
            lodash.flatten = flatten;
            lodash.forEach = forEach;
            lodash.forIn = forIn;
            lodash.forOwn = forOwn;
            lodash.functions = functions;
            lodash.groupBy = groupBy;
            lodash.initial = initial;
            lodash.intersection = intersection;
            lodash.invert = invert;
            lodash.invoke = invoke;
            lodash.keys = keys;
            lodash.map = map;
            lodash.max = max;
            lodash.memoize = memoize;
            lodash.merge = merge;
            lodash.min = min;
            lodash.omit = omit;
            lodash.once = once;
            lodash.pairs = pairs;
            lodash.partial = partial;
            lodash.partialRight = partialRight;
            lodash.pick = pick;
            lodash.pluck = pluck;
            lodash.range = range;
            lodash.reject = reject;
            lodash.rest = rest;
            lodash.shuffle = shuffle;
            lodash.sortBy = sortBy;
            lodash.tap = tap;
            lodash.throttle = throttle;
            lodash.times = times;
            lodash.toArray = toArray;
            lodash.transform = transform;
            lodash.union = union;
            lodash.uniq = uniq;
            lodash.unzip = unzip;
            lodash.values = values;
            lodash.where = where;
            lodash.without = without;
            lodash.wrap = wrap;
            lodash.zip = zip;
            lodash.zipObject = zipObject;
            lodash.collect = map;
            lodash.drop = rest;
            lodash.each = forEach;
            lodash.extend = assign;
            lodash.methods = functions;
            lodash.object = zipObject;
            lodash.select = filter;
            lodash.tail = rest;
            lodash.unique = uniq;
            mixin(lodash);
            lodash.chain = lodash;
            lodash.prototype.chain = function () {
                return this;
            };
            lodash.clone = clone;
            lodash.cloneDeep = cloneDeep;
            lodash.contains = contains;
            lodash.escape = escape;
            lodash.every = every;
            lodash.find = find;
            lodash.findIndex = findIndex;
            lodash.findKey = findKey;
            lodash.has = has;
            lodash.identity = identity;
            lodash.indexOf = indexOf;
            lodash.isArguments = isArguments;
            lodash.isArray = isArray;
            lodash.isBoolean = isBoolean;
            lodash.isDate = isDate;
            lodash.isElement = isElement;
            lodash.isEmpty = isEmpty;
            lodash.isEqual = isEqual;
            lodash.isFinite = isFinite;
            lodash.isFunction = isFunction;
            lodash.isNaN = isNaN;
            lodash.isNull = isNull;
            lodash.isNumber = isNumber;
            lodash.isObject = isObject;
            lodash.isPlainObject = isPlainObject;
            lodash.isRegExp = isRegExp;
            lodash.isString = isString;
            lodash.isUndefined = isUndefined;
            lodash.lastIndexOf = lastIndexOf;
            lodash.mixin = mixin;
            lodash.noConflict = noConflict;
            lodash.parseInt = parseInt;
            lodash.random = random;
            lodash.reduce = reduce;
            lodash.reduceRight = reduceRight;
            lodash.result = result;
            lodash.runInContext = runInContext;
            lodash.size = size;
            lodash.some = some;
            lodash.sortedIndex = sortedIndex;
            lodash.template = template;
            lodash.unescape = unescape;
            lodash.uniqueId = uniqueId;
            lodash.all = every;
            lodash.any = some;
            lodash.detect = find;
            lodash.findWhere = find;
            lodash.foldl = reduce;
            lodash.foldr = reduceRight;
            lodash.include = contains;
            lodash.inject = reduce;
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    lodash.prototype[methodName] = function () {
                        var args = [this.__wrapped__];
                        push.apply(args, arguments);
                        return func.apply(lodash, args);
                    };
                }
            });
            lodash.first = first;
            lodash.last = last;
            lodash.take = first;
            lodash.head = first;
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    lodash.prototype[methodName] = function (callback, thisArg) {
                        var result = func(this.__wrapped__, callback, thisArg);
                        return callback == null || thisArg && typeof callback != 'function' ? result : new lodashWrapper(result);
                    };
                }
            });
            lodash.VERSION = '1.3.1';
            lodash.prototype.toString = wrapperToString;
            lodash.prototype.value = wrapperValueOf;
            lodash.prototype.valueOf = wrapperValueOf;
            basicEach([
                'join',
                'pop',
                'shift'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    return func.apply(this.__wrapped__, arguments);
                };
            });
            basicEach([
                'push',
                'reverse',
                'sort',
                'unshift'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    func.apply(this.__wrapped__, arguments);
                    return this;
                };
            });
            basicEach([
                'concat',
                'slice',
                'splice'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    return new lodashWrapper(func.apply(this.__wrapped__, arguments));
                };
            });
            if (!support.spliceObjects) {
                basicEach([
                    'pop',
                    'shift',
                    'splice'
                ], function (methodName) {
                    var func = arrayRef[methodName], isSplice = methodName == 'splice';
                    lodash.prototype[methodName] = function () {
                        var value = this.__wrapped__, result = func.apply(value, arguments);
                        if (value.length === 0) {
                            delete value[0];
                        }
                        return isSplice ? new lodashWrapper(result) : result;
                    };
                });
            }
            return lodash;
        }
        var _ = runInContext();
        if (true) {
            window._ = _;
            amdclean_website['underscore'] = function () {
                return _;
            }();
        } else if (freeExports && !freeExports.nodeType) {
            if (freeModule) {
                (freeModule.exports = _)._ = _;
            } else {
                freeExports._ = _;
            }
        } else {
            window._ = _;
        }
    }(this));
    (function () {
        var root = this;
        var previousBackbone = root.Backbone;
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
        var Backbone;
        if (typeof exports !== 'undefined') {
            Backbone = exports;
        } else {
            Backbone = root.Backbone = {};
        }
        Backbone.VERSION = '1.1.0';
        var _ = root._;
        if (!_ && typeof require !== 'undefined')
            _ = underscore;
        Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;
        Backbone.noConflict = function () {
            root.Backbone = previousBackbone;
            return this;
        };
        Backbone.emulateHTTP = false;
        Backbone.emulateJSON = false;
        var Events = Backbone.Events = {
                on: function (name, callback, context) {
                    if (!eventsApi(this, 'on', name, [
                            callback,
                            context
                        ]) || !callback)
                        return this;
                    this._events || (this._events = {});
                    var events = this._events[name] || (this._events[name] = []);
                    events.push({
                        callback: callback,
                        context: context,
                        ctx: context || this
                    });
                    return this;
                },
                once: function (name, callback, context) {
                    if (!eventsApi(this, 'once', name, [
                            callback,
                            context
                        ]) || !callback)
                        return this;
                    var self = this;
                    var once = _.once(function () {
                            self.off(name, once);
                            callback.apply(this, arguments);
                        });
                    once._callback = callback;
                    return this.on(name, once, context);
                },
                off: function (name, callback, context) {
                    var retain, ev, events, names, i, l, j, k;
                    if (!this._events || !eventsApi(this, 'off', name, [
                            callback,
                            context
                        ]))
                        return this;
                    if (!name && !callback && !context) {
                        this._events = {};
                        return this;
                    }
                    names = name ? [name] : _.keys(this._events);
                    for (i = 0, l = names.length; i < l; i++) {
                        name = names[i];
                        if (events = this._events[name]) {
                            this._events[name] = retain = [];
                            if (callback || context) {
                                for (j = 0, k = events.length; j < k; j++) {
                                    ev = events[j];
                                    if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                        retain.push(ev);
                                    }
                                }
                            }
                            if (!retain.length)
                                delete this._events[name];
                        }
                    }
                    return this;
                },
                trigger: function (name) {
                    if (!this._events)
                        return this;
                    var args = slice.call(arguments, 1);
                    if (!eventsApi(this, 'trigger', name, args))
                        return this;
                    var events = this._events[name];
                    var allEvents = this._events.all;
                    if (events)
                        triggerEvents(events, args);
                    if (allEvents)
                        triggerEvents(allEvents, arguments);
                    return this;
                },
                stopListening: function (obj, name, callback) {
                    var listeningTo = this._listeningTo;
                    if (!listeningTo)
                        return this;
                    var remove = !name && !callback;
                    if (!callback && typeof name === 'object')
                        callback = this;
                    if (obj)
                        (listeningTo = {})[obj._listenId] = obj;
                    for (var id in listeningTo) {
                        obj = listeningTo[id];
                        obj.off(name, callback, this);
                        if (remove || _.isEmpty(obj._events))
                            delete this._listeningTo[id];
                    }
                    return this;
                }
            };
        var eventSplitter = /\s+/;
        var eventsApi = function (obj, action, name, rest) {
            if (!name)
                return true;
            if (typeof name === 'object') {
                for (var key in name) {
                    obj[action].apply(obj, [
                        key,
                        name[key]
                    ].concat(rest));
                }
                return false;
            }
            if (eventSplitter.test(name)) {
                var names = name.split(eventSplitter);
                for (var i = 0, l = names.length; i < l; i++) {
                    obj[action].apply(obj, [names[i]].concat(rest));
                }
                return false;
            }
            return true;
        };
        var triggerEvents = function (events, args) {
            var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
            switch (args.length) {
            case 0:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx);
                return;
            case 1:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1);
                return;
            case 2:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;
            case 3:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;
            default:
                while (++i < l)
                    (ev = events[i]).callback.apply(ev.ctx, args);
            }
        };
        var listenMethods = {
                listenTo: 'on',
                listenToOnce: 'once'
            };
        _.each(listenMethods, function (implementation, method) {
            Events[method] = function (obj, name, callback) {
                var listeningTo = this._listeningTo || (this._listeningTo = {});
                var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
                listeningTo[id] = obj;
                if (!callback && typeof name === 'object')
                    callback = this;
                obj[implementation](name, callback, this);
                return this;
            };
        });
        Events.bind = Events.on;
        Events.unbind = Events.off;
        _.extend(Backbone, Events);
        var Model = Backbone.Model = function (attributes, options) {
                var attrs = attributes || {};
                options || (options = {});
                this.cid = _.uniqueId('c');
                this.attributes = {};
                if (options.collection)
                    this.collection = options.collection;
                if (options.parse)
                    attrs = this.parse(attrs, options) || {};
                attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
                this.set(attrs, options);
                this.changed = {};
                this.initialize.apply(this, arguments);
            };
        _.extend(Model.prototype, Events, {
            changed: null,
            validationError: null,
            idAttribute: 'id',
            initialize: function () {
            },
            toJSON: function (options) {
                return _.clone(this.attributes);
            },
            sync: function () {
                return Backbone.sync.apply(this, arguments);
            },
            get: function (attr) {
                return this.attributes[attr];
            },
            escape: function (attr) {
                return _.escape(this.get(attr));
            },
            has: function (attr) {
                return this.get(attr) != null;
            },
            set: function (key, val, options) {
                var attr, attrs, unset, changes, silent, changing, prev, current;
                if (key == null)
                    return this;
                if (typeof key === 'object') {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options || (options = {});
                if (!this._validate(attrs, options))
                    return false;
                unset = options.unset;
                silent = options.silent;
                changes = [];
                changing = this._changing;
                this._changing = true;
                if (!changing) {
                    this._previousAttributes = _.clone(this.attributes);
                    this.changed = {};
                }
                current = this.attributes, prev = this._previousAttributes;
                if (this.idAttribute in attrs)
                    this.id = attrs[this.idAttribute];
                for (attr in attrs) {
                    val = attrs[attr];
                    if (!_.isEqual(current[attr], val))
                        changes.push(attr);
                    if (!_.isEqual(prev[attr], val)) {
                        this.changed[attr] = val;
                    } else {
                        delete this.changed[attr];
                    }
                    unset ? delete current[attr] : current[attr] = val;
                }
                if (!silent) {
                    if (changes.length)
                        this._pending = true;
                    for (var i = 0, l = changes.length; i < l; i++) {
                        this.trigger('change:' + changes[i], this, current[changes[i]], options);
                    }
                }
                if (changing)
                    return this;
                if (!silent) {
                    while (this._pending) {
                        this._pending = false;
                        this.trigger('change', this, options);
                    }
                }
                this._pending = false;
                this._changing = false;
                return this;
            },
            unset: function (attr, options) {
                return this.set(attr, void 0, _.extend({}, options, { unset: true }));
            },
            clear: function (options) {
                var attrs = {};
                for (var key in this.attributes)
                    attrs[key] = void 0;
                return this.set(attrs, _.extend({}, options, { unset: true }));
            },
            hasChanged: function (attr) {
                if (attr == null)
                    return !_.isEmpty(this.changed);
                return _.has(this.changed, attr);
            },
            changedAttributes: function (diff) {
                if (!diff)
                    return this.hasChanged() ? _.clone(this.changed) : false;
                var val, changed = false;
                var old = this._changing ? this._previousAttributes : this.attributes;
                for (var attr in diff) {
                    if (_.isEqual(old[attr], val = diff[attr]))
                        continue;
                    (changed || (changed = {}))[attr] = val;
                }
                return changed;
            },
            previous: function (attr) {
                if (attr == null || !this._previousAttributes)
                    return null;
                return this._previousAttributes[attr];
            },
            previousAttributes: function () {
                return _.clone(this._previousAttributes);
            },
            fetch: function (options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0)
                    options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function (resp) {
                    if (!model.set(model.parse(resp, options), options))
                        return false;
                    if (success)
                        success(model, resp, options);
                    model.trigger('sync', model, resp, options);
                };
                wrapError(this, options);
                return this.sync('read', this, options);
            },
            save: function (key, val, options) {
                var attrs, method, xhr, attributes = this.attributes;
                if (key == null || typeof key === 'object') {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options = _.extend({ validate: true }, options);
                if (attrs && !options.wait) {
                    if (!this.set(attrs, options))
                        return false;
                } else {
                    if (!this._validate(attrs, options))
                        return false;
                }
                if (attrs && options.wait) {
                    this.attributes = _.extend({}, attributes, attrs);
                }
                if (options.parse === void 0)
                    options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function (resp) {
                    model.attributes = attributes;
                    var serverAttrs = model.parse(resp, options);
                    if (options.wait)
                        serverAttrs = _.extend(attrs || {}, serverAttrs);
                    if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                        return false;
                    }
                    if (success)
                        success(model, resp, options);
                    model.trigger('sync', model, resp, options);
                };
                wrapError(this, options);
                method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
                if (method === 'patch')
                    options.attrs = attrs;
                xhr = this.sync(method, this, options);
                if (attrs && options.wait)
                    this.attributes = attributes;
                return xhr;
            },
            destroy: function (options) {
                options = options ? _.clone(options) : {};
                var model = this;
                var success = options.success;
                var destroy = function () {
                    model.trigger('destroy', model, model.collection, options);
                };
                options.success = function (resp) {
                    if (options.wait || model.isNew())
                        destroy();
                    if (success)
                        success(model, resp, options);
                    if (!model.isNew())
                        model.trigger('sync', model, resp, options);
                };
                if (this.isNew()) {
                    options.success();
                    return false;
                }
                wrapError(this, options);
                var xhr = this.sync('delete', this, options);
                if (!options.wait)
                    destroy();
                return xhr;
            },
            url: function () {
                var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
                if (this.isNew())
                    return base;
                return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
            },
            parse: function (resp, options) {
                return resp;
            },
            clone: function () {
                return new this.constructor(this.attributes);
            },
            isNew: function () {
                return this.id == null;
            },
            isValid: function (options) {
                return this._validate({}, _.extend(options || {}, { validate: true }));
            },
            _validate: function (attrs, options) {
                if (!options.validate || !this.validate)
                    return true;
                attrs = _.extend({}, this.attributes, attrs);
                var error = this.validationError = this.validate(attrs, options) || null;
                if (!error)
                    return true;
                this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
                return false;
            }
        });
        var modelMethods = [
                'keys',
                'values',
                'pairs',
                'invert',
                'pick',
                'omit'
            ];
        _.each(modelMethods, function (method) {
            Model.prototype[method] = function () {
                var args = slice.call(arguments);
                args.unshift(this.attributes);
                return _[method].apply(_, args);
            };
        });
        var Collection = Backbone.Collection = function (models, options) {
                options || (options = {});
                if (options.model)
                    this.model = options.model;
                if (options.comparator !== void 0)
                    this.comparator = options.comparator;
                this._reset();
                this.initialize.apply(this, arguments);
                if (models)
                    this.reset(models, _.extend({ silent: true }, options));
            };
        var setOptions = {
                add: true,
                remove: true,
                merge: true
            };
        var addOptions = {
                add: true,
                remove: false
            };
        _.extend(Collection.prototype, Events, {
            model: Model,
            initialize: function () {
            },
            toJSON: function (options) {
                return this.map(function (model) {
                    return model.toJSON(options);
                });
            },
            sync: function () {
                return Backbone.sync.apply(this, arguments);
            },
            add: function (models, options) {
                return this.set(models, _.extend({ merge: false }, options, addOptions));
            },
            remove: function (models, options) {
                var singular = !_.isArray(models);
                models = singular ? [models] : _.clone(models);
                options || (options = {});
                var i, l, index, model;
                for (i = 0, l = models.length; i < l; i++) {
                    model = models[i] = this.get(models[i]);
                    if (!model)
                        continue;
                    delete this._byId[model.id];
                    delete this._byId[model.cid];
                    index = this.indexOf(model);
                    this.models.splice(index, 1);
                    this.length--;
                    if (!options.silent) {
                        options.index = index;
                        model.trigger('remove', model, this, options);
                    }
                    this._removeReference(model);
                }
                return singular ? models[0] : models;
            },
            set: function (models, options) {
                options = _.defaults({}, options, setOptions);
                if (options.parse)
                    models = this.parse(models, options);
                var singular = !_.isArray(models);
                models = singular ? models ? [models] : [] : _.clone(models);
                var i, l, id, model, attrs, existing, sort;
                var at = options.at;
                var targetModel = this.model;
                var sortable = this.comparator && at == null && options.sort !== false;
                var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                var toAdd = [], toRemove = [], modelMap = {};
                var add = options.add, merge = options.merge, remove = options.remove;
                var order = !sortable && add && remove ? [] : false;
                for (i = 0, l = models.length; i < l; i++) {
                    attrs = models[i];
                    if (attrs instanceof Model) {
                        id = model = attrs;
                    } else {
                        id = attrs[targetModel.prototype.idAttribute];
                    }
                    if (existing = this.get(id)) {
                        if (remove)
                            modelMap[existing.cid] = true;
                        if (merge) {
                            attrs = attrs === model ? model.attributes : attrs;
                            if (options.parse)
                                attrs = existing.parse(attrs, options);
                            existing.set(attrs, options);
                            if (sortable && !sort && existing.hasChanged(sortAttr))
                                sort = true;
                        }
                        models[i] = existing;
                    } else if (add) {
                        model = models[i] = this._prepareModel(attrs, options);
                        if (!model)
                            continue;
                        toAdd.push(model);
                        model.on('all', this._onModelEvent, this);
                        this._byId[model.cid] = model;
                        if (model.id != null)
                            this._byId[model.id] = model;
                    }
                    if (order)
                        order.push(existing || model);
                }
                if (remove) {
                    for (i = 0, l = this.length; i < l; ++i) {
                        if (!modelMap[(model = this.models[i]).cid])
                            toRemove.push(model);
                    }
                    if (toRemove.length)
                        this.remove(toRemove, options);
                }
                if (toAdd.length || order && order.length) {
                    if (sortable)
                        sort = true;
                    this.length += toAdd.length;
                    if (at != null) {
                        for (i = 0, l = toAdd.length; i < l; i++) {
                            this.models.splice(at + i, 0, toAdd[i]);
                        }
                    } else {
                        if (order)
                            this.models.length = 0;
                        var orderedModels = order || toAdd;
                        for (i = 0, l = orderedModels.length; i < l; i++) {
                            this.models.push(orderedModels[i]);
                        }
                    }
                }
                if (sort)
                    this.sort({ silent: true });
                if (!options.silent) {
                    for (i = 0, l = toAdd.length; i < l; i++) {
                        (model = toAdd[i]).trigger('add', model, this, options);
                    }
                    if (sort || order && order.length)
                        this.trigger('sort', this, options);
                }
                return singular ? models[0] : models;
            },
            reset: function (models, options) {
                options || (options = {});
                for (var i = 0, l = this.models.length; i < l; i++) {
                    this._removeReference(this.models[i]);
                }
                options.previousModels = this.models;
                this._reset();
                models = this.add(models, _.extend({ silent: true }, options));
                if (!options.silent)
                    this.trigger('reset', this, options);
                return models;
            },
            push: function (model, options) {
                return this.add(model, _.extend({ at: this.length }, options));
            },
            pop: function (options) {
                var model = this.at(this.length - 1);
                this.remove(model, options);
                return model;
            },
            unshift: function (model, options) {
                return this.add(model, _.extend({ at: 0 }, options));
            },
            shift: function (options) {
                var model = this.at(0);
                this.remove(model, options);
                return model;
            },
            slice: function () {
                return slice.apply(this.models, arguments);
            },
            get: function (obj) {
                if (obj == null)
                    return void 0;
                return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
            },
            at: function (index) {
                return this.models[index];
            },
            where: function (attrs, first) {
                if (_.isEmpty(attrs))
                    return first ? void 0 : [];
                return this[first ? 'find' : 'filter'](function (model) {
                    for (var key in attrs) {
                        if (attrs[key] !== model.get(key))
                            return false;
                    }
                    return true;
                });
            },
            findWhere: function (attrs) {
                return this.where(attrs, true);
            },
            sort: function (options) {
                if (!this.comparator)
                    throw new Error('Cannot sort a set without a comparator');
                options || (options = {});
                if (_.isString(this.comparator) || this.comparator.length === 1) {
                    this.models = this.sortBy(this.comparator, this);
                } else {
                    this.models.sort(_.bind(this.comparator, this));
                }
                if (!options.silent)
                    this.trigger('sort', this, options);
                return this;
            },
            pluck: function (attr) {
                return _.invoke(this.models, 'get', attr);
            },
            fetch: function (options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0)
                    options.parse = true;
                var success = options.success;
                var collection = this;
                options.success = function (resp) {
                    var method = options.reset ? 'reset' : 'set';
                    collection[method](resp, options);
                    if (success)
                        success(collection, resp, options);
                    collection.trigger('sync', collection, resp, options);
                };
                wrapError(this, options);
                return this.sync('read', this, options);
            },
            create: function (model, options) {
                options = options ? _.clone(options) : {};
                if (!(model = this._prepareModel(model, options)))
                    return false;
                if (!options.wait)
                    this.add(model, options);
                var collection = this;
                var success = options.success;
                options.success = function (model, resp, options) {
                    if (options.wait)
                        collection.add(model, options);
                    if (success)
                        success(model, resp, options);
                };
                model.save(null, options);
                return model;
            },
            parse: function (resp, options) {
                return resp;
            },
            clone: function () {
                return new this.constructor(this.models);
            },
            _reset: function () {
                this.length = 0;
                this.models = [];
                this._byId = {};
            },
            _prepareModel: function (attrs, options) {
                if (attrs instanceof Model) {
                    if (!attrs.collection)
                        attrs.collection = this;
                    return attrs;
                }
                options = options ? _.clone(options) : {};
                options.collection = this;
                var model = new this.model(attrs, options);
                if (!model.validationError)
                    return model;
                this.trigger('invalid', this, model.validationError, options);
                return false;
            },
            _removeReference: function (model) {
                if (this === model.collection)
                    delete model.collection;
                model.off('all', this._onModelEvent, this);
            },
            _onModelEvent: function (event, model, collection, options) {
                if ((event === 'add' || event === 'remove') && collection !== this)
                    return;
                if (event === 'destroy')
                    this.remove(model, options);
                if (model && event === 'change:' + model.idAttribute) {
                    delete this._byId[model.previous(model.idAttribute)];
                    if (model.id != null)
                        this._byId[model.id] = model;
                }
                this.trigger.apply(this, arguments);
            }
        });
        var methods = [
                'forEach',
                'each',
                'map',
                'collect',
                'reduce',
                'foldl',
                'inject',
                'reduceRight',
                'foldr',
                'find',
                'detect',
                'filter',
                'select',
                'reject',
                'every',
                'all',
                'some',
                'any',
                'include',
                'contains',
                'invoke',
                'max',
                'min',
                'toArray',
                'size',
                'first',
                'head',
                'take',
                'initial',
                'rest',
                'tail',
                'drop',
                'last',
                'without',
                'difference',
                'indexOf',
                'shuffle',
                'lastIndexOf',
                'isEmpty',
                'chain'
            ];
        _.each(methods, function (method) {
            Collection.prototype[method] = function () {
                var args = slice.call(arguments);
                args.unshift(this.models);
                return _[method].apply(_, args);
            };
        });
        var attributeMethods = [
                'groupBy',
                'countBy',
                'sortBy'
            ];
        _.each(attributeMethods, function (method) {
            Collection.prototype[method] = function (value, context) {
                var iterator = _.isFunction(value) ? value : function (model) {
                        return model.get(value);
                    };
                return _[method](this.models, iterator, context);
            };
        });
        var View = Backbone.View = function (options) {
                this.cid = _.uniqueId('view');
                options || (options = {});
                _.extend(this, _.pick(options, viewOptions));
                this._ensureElement();
                this.initialize.apply(this, arguments);
                this.delegateEvents();
            };
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
        var viewOptions = [
                'model',
                'collection',
                'el',
                'id',
                'attributes',
                'className',
                'tagName',
                'events'
            ];
        _.extend(View.prototype, Events, {
            tagName: 'div',
            $: function (selector) {
                return this.$el.find(selector);
            },
            initialize: function () {
            },
            render: function () {
                return this;
            },
            remove: function () {
                this.$el.remove();
                this.stopListening();
                return this;
            },
            setElement: function (element, delegate) {
                if (this.$el)
                    this.undelegateEvents();
                this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                this.el = this.$el[0];
                if (delegate !== false)
                    this.delegateEvents();
                return this;
            },
            delegateEvents: function (events) {
                if (!(events || (events = _.result(this, 'events'))))
                    return this;
                this.undelegateEvents();
                for (var key in events) {
                    var method = events[key];
                    if (!_.isFunction(method))
                        method = this[events[key]];
                    if (!method)
                        continue;
                    var match = key.match(delegateEventSplitter);
                    var eventName = match[1], selector = match[2];
                    method = _.bind(method, this);
                    eventName += '.delegateEvents' + this.cid;
                    if (selector === '') {
                        this.$el.on(eventName, method);
                    } else {
                        this.$el.on(eventName, selector, method);
                    }
                }
                return this;
            },
            undelegateEvents: function () {
                this.$el.off('.delegateEvents' + this.cid);
                return this;
            },
            _ensureElement: function () {
                if (!this.el) {
                    var attrs = _.extend({}, _.result(this, 'attributes'));
                    if (this.id)
                        attrs.id = _.result(this, 'id');
                    if (this.className)
                        attrs['class'] = _.result(this, 'className');
                    var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
                    this.setElement($el, false);
                } else {
                    this.setElement(_.result(this, 'el'), false);
                }
            }
        });
        Backbone.sync = function (method, model, options) {
            var type = methodMap[method];
            _.defaults(options || (options = {}), {
                emulateHTTP: Backbone.emulateHTTP,
                emulateJSON: Backbone.emulateJSON
            });
            var params = {
                    type: type,
                    dataType: 'json'
                };
            if (!options.url) {
                params.url = _.result(model, 'url') || urlError();
            }
            if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
                params.contentType = 'application/json';
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            if (options.emulateJSON) {
                params.contentType = 'application/x-www-form-urlencoded';
                params.data = params.data ? { model: params.data } : {};
            }
            if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
                params.type = 'POST';
                if (options.emulateJSON)
                    params.data._method = type;
                var beforeSend = options.beforeSend;
                options.beforeSend = function (xhr) {
                    xhr.setRequestHeader('X-HTTP-Method-Override', type);
                    if (beforeSend)
                        return beforeSend.apply(this, arguments);
                };
            }
            if (params.type !== 'GET' && !options.emulateJSON) {
                params.processData = false;
            }
            if (params.type === 'PATCH' && noXhrPatch) {
                params.xhr = function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                };
            }
            var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
            model.trigger('request', model, xhr, options);
            return xhr;
        };
        var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent);
        var methodMap = {
                'create': 'POST',
                'update': 'PUT',
                'patch': 'PATCH',
                'delete': 'DELETE',
                'read': 'GET'
            };
        Backbone.ajax = function () {
            return Backbone.$.ajax.apply(Backbone.$, arguments);
        };
        var Router = Backbone.Router = function (options) {
                options || (options = {});
                if (options.routes)
                    this.routes = options.routes;
                this._bindRoutes();
                this.initialize.apply(this, arguments);
            };
        var optionalParam = /\((.*?)\)/g;
        var namedParam = /(\(\?)?:\w+/g;
        var splatParam = /\*\w+/g;
        var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
        _.extend(Router.prototype, Events, {
            initialize: function () {
            },
            route: function (route, name, callback) {
                if (!_.isRegExp(route))
                    route = this._routeToRegExp(route);
                if (_.isFunction(name)) {
                    callback = name;
                    name = '';
                }
                if (!callback)
                    callback = this[name];
                var router = this;
                Backbone.history.route(route, function (fragment) {
                    var args = router._extractParameters(route, fragment);
                    callback && callback.apply(router, args);
                    router.trigger.apply(router, ['route:' + name].concat(args));
                    router.trigger('route', name, args);
                    Backbone.history.trigger('route', router, name, args);
                });
                return this;
            },
            navigate: function (fragment, options) {
                Backbone.history.navigate(fragment, options);
                return this;
            },
            _bindRoutes: function () {
                if (!this.routes)
                    return;
                this.routes = _.result(this, 'routes');
                var route, routes = _.keys(this.routes);
                while ((route = routes.pop()) != null) {
                    this.route(route, this.routes[route]);
                }
            },
            _routeToRegExp: function (route) {
                route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
                    return optional ? match : '([^/]+)';
                }).replace(splatParam, '(.*?)');
                return new RegExp('^' + route + '$');
            },
            _extractParameters: function (route, fragment) {
                var params = route.exec(fragment).slice(1);
                return _.map(params, function (param) {
                    return param ? decodeURIComponent(param) : null;
                });
            }
        });
        var History = Backbone.History = function () {
                this.handlers = [];
                _.bindAll(this, 'checkUrl');
                if (typeof window !== 'undefined') {
                    this.location = window.location;
                    this.history = window.history;
                }
            };
        var routeStripper = /^[#\/]|\s+$/g;
        var rootStripper = /^\/+|\/+$/g;
        var isExplorer = /msie [\w.]+/;
        var trailingSlash = /\/$/;
        var pathStripper = /[?#].*$/;
        History.started = false;
        _.extend(History.prototype, Events, {
            interval: 50,
            getHash: function (window) {
                var match = (window || this).location.href.match(/#(.*)$/);
                return match ? match[1] : '';
            },
            getFragment: function (fragment, forcePushState) {
                if (fragment == null) {
                    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                        fragment = this.location.pathname;
                        var root = this.root.replace(trailingSlash, '');
                        if (!fragment.indexOf(root))
                            fragment = fragment.slice(root.length);
                    } else {
                        fragment = this.getHash();
                    }
                }
                return fragment.replace(routeStripper, '');
            },
            start: function (options) {
                if (History.started)
                    throw new Error('Backbone.history has already been started');
                History.started = true;
                this.options = _.extend({ root: '/' }, this.options, options);
                this.root = this.options.root;
                this._wantsHashChange = this.options.hashChange !== false;
                this._wantsPushState = !!this.options.pushState;
                this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
                var fragment = this.getFragment();
                var docMode = document.documentMode;
                var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
                this.root = ('/' + this.root + '/').replace(rootStripper, '/');
                if (oldIE && this._wantsHashChange) {
                    this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
                    this.navigate(fragment);
                }
                if (this._hasPushState) {
                    Backbone.$(window).on('popstate', this.checkUrl);
                } else if (this._wantsHashChange && 'onhashchange' in window && !oldIE) {
                    Backbone.$(window).on('hashchange', this.checkUrl);
                } else if (this._wantsHashChange) {
                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                }
                this.fragment = fragment;
                var loc = this.location;
                var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;
                if (this._wantsHashChange && this._wantsPushState) {
                    if (!this._hasPushState && !atRoot) {
                        this.fragment = this.getFragment(null, true);
                        this.location.replace(this.root + this.location.search + '#' + this.fragment);
                        return true;
                    } else if (this._hasPushState && atRoot && loc.hash) {
                        this.fragment = this.getHash().replace(routeStripper, '');
                        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
                    }
                }
                if (!this.options.silent)
                    return this.loadUrl();
            },
            stop: function () {
                Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
                clearInterval(this._checkUrlInterval);
                History.started = false;
            },
            route: function (route, callback) {
                this.handlers.unshift({
                    route: route,
                    callback: callback
                });
            },
            checkUrl: function (e) {
                var current = this.getFragment();
                if (current === this.fragment && this.iframe) {
                    current = this.getFragment(this.getHash(this.iframe));
                }
                if (current === this.fragment)
                    return false;
                if (this.iframe)
                    this.navigate(current);
                this.loadUrl();
            },
            loadUrl: function (fragment) {
                fragment = this.fragment = this.getFragment(fragment);
                return _.any(this.handlers, function (handler) {
                    if (handler.route.test(fragment)) {
                        handler.callback(fragment);
                        return true;
                    }
                });
            },
            navigate: function (fragment, options) {
                if (!History.started)
                    return false;
                if (!options || options === true)
                    options = { trigger: !!options };
                var url = this.root + (fragment = this.getFragment(fragment || ''));
                fragment = fragment.replace(pathStripper, '');
                if (this.fragment === fragment)
                    return;
                this.fragment = fragment;
                if (fragment === '' && url !== '/')
                    url = url.slice(0, -1);
                if (this._hasPushState) {
                    this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
                } else if (this._wantsHashChange) {
                    this._updateHash(this.location, fragment, options.replace);
                    if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                        if (!options.replace)
                            this.iframe.document.open().close();
                        this._updateHash(this.iframe.location, fragment, options.replace);
                    }
                } else {
                    return this.location.assign(url);
                }
                if (options.trigger)
                    return this.loadUrl(fragment);
            },
            _updateHash: function (location, fragment, replace) {
                if (replace) {
                    var href = location.href.replace(/(javascript:|#).*$/, '');
                    location.replace(href + '#' + fragment);
                } else {
                    location.hash = '#' + fragment;
                }
            }
        });
        Backbone.history = new History();
        var extend = function (protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && _.has(protoProps, 'constructor')) {
                child = protoProps.constructor;
            } else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            _.extend(child, parent, staticProps);
            var Surrogate = function () {
                this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps)
                _.extend(child.prototype, protoProps);
            child.__super__ = parent.prototype;
            return child;
        };
        Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
        var urlError = function () {
            throw new Error('A "url" property or function must be specified');
        };
        var wrapError = function (model, options) {
            var error = options.error;
            options.error = function (resp) {
                if (error)
                    error(model, resp, options);
                model.trigger('error', model, resp, options);
            };
        };
    }.call(this));
    amdclean_website['backbone'] = window.Backbone;
    (function (root, factory) {
        
        if (true) {
            amdclean_website['esprima'] = function (module) {
                return factory();
            }({});
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory(root.esprima = {});
        }
    }(this, function (exports) {
        exports = exports || {};
        
        var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
        Token = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
        };
        TokenName = {};
        TokenName[Token.BooleanLiteral] = 'Boolean';
        TokenName[Token.EOF] = '<end>';
        TokenName[Token.Identifier] = 'Identifier';
        TokenName[Token.Keyword] = 'Keyword';
        TokenName[Token.NullLiteral] = 'Null';
        TokenName[Token.NumericLiteral] = 'Numeric';
        TokenName[Token.Punctuator] = 'Punctuator';
        TokenName[Token.StringLiteral] = 'String';
        TokenName[Token.RegularExpression] = 'RegularExpression';
        FnExprTokens = [
            '(',
            '{',
            '[',
            'in',
            'typeof',
            'instanceof',
            'new',
            'return',
            'case',
            'delete',
            'throw',
            'void',
            '=',
            '+=',
            '-=',
            '*=',
            '/=',
            '%=',
            '<<=',
            '>>=',
            '>>>=',
            '&=',
            '|=',
            '^=',
            ',',
            '+',
            '-',
            '*',
            '/',
            '%',
            '++',
            '--',
            '<<',
            '>>',
            '>>>',
            '&',
            '|',
            '^',
            '!',
            '~',
            '&&',
            '||',
            '?',
            ':',
            '===',
            '==',
            '>=',
            '<=',
            '<',
            '>',
            '!=',
            '!=='
        ];
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            ArrayExpression: 'ArrayExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DoWhileStatement: 'DoWhileStatement',
            DebuggerStatement: 'DebuggerStatement',
            EmptyStatement: 'EmptyStatement',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            Program: 'Program',
            Property: 'Property',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement'
        };
        PropertyKind = {
            Data: 1,
            Get: 2,
            Set: 4
        };
        Messages = {
            UnexpectedToken: 'Unexpected token %0',
            UnexpectedNumber: 'Unexpected number',
            UnexpectedString: 'Unexpected string',
            UnexpectedIdentifier: 'Unexpected identifier',
            UnexpectedReserved: 'Unexpected reserved word',
            UnexpectedEOS: 'Unexpected end of input',
            NewlineAfterThrow: 'Illegal newline after throw',
            InvalidRegExp: 'Invalid regular expression',
            UnterminatedRegExp: 'Invalid regular expression: missing /',
            InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
            InvalidLHSInForIn: 'Invalid left-hand side in for-in',
            MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
            NoCatchOrFinally: 'Missing catch or finally after try',
            UnknownLabel: 'Undefined label \'%0\'',
            Redeclaration: '%0 \'%1\' has already been declared',
            IllegalContinue: 'Illegal continue statement',
            IllegalBreak: 'Illegal break statement',
            IllegalReturn: 'Illegal return statement',
            StrictModeWith: 'Strict mode code may not include a with statement',
            StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
            StrictVarName: 'Variable name may not be eval or arguments in strict mode',
            StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
            StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
            StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
            StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
            StrictDelete: 'Delete of an unqualified identifier in strict mode.',
            StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
            AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
            AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
            StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
            StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
            StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
            StrictReservedWord: 'Use of future reserved word in strict mode'
        };
        Regex = {
            NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
            NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
        };
        function assert(condition, message) {
            if (!condition) {
                throw new Error('ASSERT: ' + message);
            }
        }
        function isDecimalDigit(ch) {
            return ch >= 48 && ch <= 57;
        }
        function isHexDigit(ch) {
            return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
        }
        function isOctalDigit(ch) {
            return '01234567'.indexOf(ch) >= 0;
        }
        function isWhiteSpace(ch) {
            return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
                5760,
                6158,
                8192,
                8193,
                8194,
                8195,
                8196,
                8197,
                8198,
                8199,
                8200,
                8201,
                8202,
                8239,
                8287,
                12288,
                65279
            ].indexOf(ch) >= 0;
        }
        function isLineTerminator(ch) {
            return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
        }
        function isIdentifierStart(ch) {
            return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
        }
        function isIdentifierPart(ch) {
            return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
        }
        function isFutureReservedWord(id) {
            switch (id) {
            case 'class':
            case 'enum':
            case 'export':
            case 'extends':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
            }
        }
        function isStrictModeReservedWord(id) {
            switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
            }
        }
        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }
        function isKeyword(id) {
            if (strict && isStrictModeReservedWord(id)) {
                return true;
            }
            switch (id.length) {
            case 2:
                return id === 'if' || id === 'in' || id === 'do';
            case 3:
                return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
            case 4:
                return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
            case 5:
                return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
            case 6:
                return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
            case 7:
                return id === 'default' || id === 'finally' || id === 'extends';
            case 8:
                return id === 'function' || id === 'continue' || id === 'debugger';
            case 10:
                return id === 'instanceof';
            default:
                return false;
            }
        }
        function addComment(type, value, start, end, loc) {
            var comment, attacher;
            assert(typeof start === 'number', 'Comment must have valid position');
            if (state.lastCommentStart >= start) {
                return;
            }
            state.lastCommentStart = start;
            comment = {
                type: type,
                value: value
            };
            if (extra.range) {
                comment.range = [
                    start,
                    end
                ];
            }
            if (extra.loc) {
                comment.loc = loc;
            }
            extra.comments.push(comment);
            if (extra.attachComment) {
                attacher = {
                    comment: comment,
                    leading: null,
                    trailing: null,
                    range: [
                        start,
                        end
                    ]
                };
                extra.pendingComments.push(attacher);
            }
        }
        function skipSingleLineComment() {
            var start, loc, ch, comment;
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
            while (index < length) {
                ch = source.charCodeAt(index);
                ++index;
                if (isLineTerminator(ch)) {
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 1);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart - 1
                        };
                        addComment('Line', comment, start, index - 1, loc);
                    }
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    return;
                }
            }
            if (extra.comments) {
                comment = source.slice(start + 2, index);
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                addComment('Line', comment, start, index, loc);
            }
        }
        function skipMultiLineComment() {
            var start, loc, ch, comment;
            if (extra.comments) {
                start = index - 2;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart - 2
                    }
                };
            }
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isLineTerminator(ch)) {
                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else if (ch === 42) {
                    if (source.charCodeAt(index + 1) === 47) {
                        ++index;
                        ++index;
                        if (extra.comments) {
                            comment = source.slice(start + 2, index - 2);
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                        }
                        return;
                    }
                    ++index;
                } else {
                    ++index;
                }
            }
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        function skipComment() {
            var ch, start;
            start = index === 0;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isWhiteSpace(ch)) {
                    ++index;
                } else if (isLineTerminator(ch)) {
                    ++index;
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    start = true;
                } else if (ch === 47) {
                    ch = source.charCodeAt(index + 1);
                    if (ch === 47) {
                        ++index;
                        ++index;
                        skipSingleLineComment();
                        start = true;
                    } else if (ch === 42) {
                        ++index;
                        ++index;
                        skipMultiLineComment();
                    } else {
                        break;
                    }
                } else if (start && ch === 45) {
                    if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
                        index += 3;
                        skipSingleLineComment();
                    } else {
                        break;
                    }
                } else if (ch === 60) {
                    if (source.slice(index + 1, index + 4) === '!--') {
                        ++index;
                        ++index;
                        ++index;
                        ++index;
                        skipSingleLineComment();
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
        function scanHexEscape(prefix) {
            var i, len, ch, code = 0;
            len = prefix === 'u' ? 4 : 2;
            for (i = 0; i < len; ++i) {
                if (index < length && isHexDigit(source[index])) {
                    ch = source[index++];
                    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                } else {
                    return '';
                }
            }
            return String.fromCharCode(code);
        }
        function getEscapedIdentifier() {
            var ch, id;
            ch = source.charCodeAt(index++);
            id = String.fromCharCode(ch);
            if (ch === 92) {
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id = ch;
            }
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!isIdentifierPart(ch)) {
                    break;
                }
                ++index;
                id += String.fromCharCode(ch);
                if (ch === 92) {
                    id = id.substr(0, id.length - 1);
                    if (source.charCodeAt(index) !== 117) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    ++index;
                    ch = scanHexEscape('u');
                    if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    id += ch;
                }
            }
            return id;
        }
        function getIdentifier() {
            var start, ch;
            start = index++;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (ch === 92) {
                    index = start;
                    return getEscapedIdentifier();
                }
                if (isIdentifierPart(ch)) {
                    ++index;
                } else {
                    break;
                }
            }
            return source.slice(start, index);
        }
        function scanIdentifier() {
            var start, id, type;
            start = index;
            id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
            if (id.length === 1) {
                type = Token.Identifier;
            } else if (isKeyword(id)) {
                type = Token.Keyword;
            } else if (id === 'null') {
                type = Token.NullLiteral;
            } else if (id === 'true' || id === 'false') {
                type = Token.BooleanLiteral;
            } else {
                type = Token.Identifier;
            }
            return {
                type: type,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanPunctuator() {
            var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
            switch (code) {
            case 46:
            case 40:
            case 41:
            case 59:
            case 44:
            case 123:
            case 125:
            case 91:
            case 93:
            case 58:
            case 63:
            case 126:
                ++index;
                if (extra.tokenize) {
                    if (code === 40) {
                        extra.openParenToken = extra.tokens.length;
                    } else if (code === 123) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            default:
                code2 = source.charCodeAt(index + 1);
                if (code2 === 61) {
                    switch (code) {
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: String.fromCharCode(code) + String.fromCharCode(code2),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [
                                start,
                                index
                            ]
                        };
                    case 33:
                    case 61:
                        index += 2;
                        if (source.charCodeAt(index) === 61) {
                            ++index;
                        }
                        return {
                            type: Token.Punctuator,
                            value: source.slice(start, index),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [
                                start,
                                index
                            ]
                        };
                    default:
                        break;
                    }
                }
                break;
            }
            ch2 = source[index + 1];
            ch3 = source[index + 2];
            ch4 = source[index + 3];
            if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
                if (ch4 === '=') {
                    index += 4;
                    return {
                        type: Token.Punctuator,
                        value: '>>>=',
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [
                            start,
                            index
                        ]
                    };
                }
            }
            if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>>',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '<<=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                ++index;
                return {
                    type: Token.Punctuator,
                    value: ch1,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        function scanHexLiteral(start) {
            var number = '';
            while (index < length) {
                if (!isHexDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
            if (number.length === 0) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseInt('0x' + number, 16),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanOctalLiteral(start) {
            var number = '0' + source[index++];
            while (index < length) {
                if (!isOctalDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
            if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 8),
                octal: true,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanNumericLiteral() {
            var number, start, ch;
            ch = source[index];
            assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
            start = index;
            number = '';
            if (ch !== '.') {
                number = source[index++];
                ch = source[index];
                if (number === '0') {
                    if (ch === 'x' || ch === 'X') {
                        ++index;
                        return scanHexLiteral(start);
                    }
                    if (isOctalDigit(ch)) {
                        return scanOctalLiteral(start);
                    }
                    if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                }
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
            if (ch === '.') {
                number += source[index++];
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
            if (ch === 'e' || ch === 'E') {
                number += source[index++];
                ch = source[index];
                if (ch === '+' || ch === '-') {
                    number += source[index++];
                }
                if (isDecimalDigit(source.charCodeAt(index))) {
                    while (isDecimalDigit(source.charCodeAt(index))) {
                        number += source[index++];
                    }
                } else {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseFloat(number),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanStringLiteral() {
            var str = '', quote, start, ch, code, unescaped, restore, octal = false;
            quote = source[index];
            assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
            start = index;
            ++index;
            while (index < length) {
                ch = source[index++];
                if (ch === quote) {
                    quote = '';
                    break;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'u':
                        case 'x':
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);
                                if (code !== 0) {
                                    octal = true;
                                }
                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                    if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            } else {
                                str += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    break;
                } else {
                    str += ch;
                }
            }
            if (quote !== '') {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.StringLiteral,
                value: str,
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanRegExp() {
            var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;
            lookahead = null;
            skipComment();
            start = index;
            ch = source[index];
            assert(ch === '/', 'Regular expression literal must start with a slash');
            str = source[index++];
            while (index < length) {
                ch = source[index++];
                str += ch;
                if (ch === '\\') {
                    ch = source[index++];
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                } else if (classMarker) {
                    if (ch === ']') {
                        classMarker = false;
                    }
                } else {
                    if (ch === '/') {
                        terminated = true;
                        break;
                    } else if (ch === '[') {
                        classMarker = true;
                    }
                }
            }
            if (!terminated) {
                throwError({}, Messages.UnterminatedRegExp);
            }
            pattern = str.substr(1, str.length - 2);
            flags = '';
            while (index < length) {
                ch = source[index];
                if (!isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                }
                ++index;
                if (ch === '\\' && index < length) {
                    ch = source[index];
                    if (ch === 'u') {
                        ++index;
                        restore = index;
                        ch = scanHexEscape('u');
                        if (ch) {
                            flags += ch;
                            for (str += '\\u'; restore < index; ++restore) {
                                str += source[restore];
                            }
                        } else {
                            index = restore;
                            flags += 'u';
                            str += '\\u';
                        }
                    } else {
                        str += '\\';
                    }
                } else {
                    flags += ch;
                    str += ch;
                }
            }
            try {
                value = new RegExp(pattern, flags);
            } catch (e) {
                throwError({}, Messages.InvalidRegExp);
            }
            peek();
            if (extra.tokenize) {
                return {
                    type: Token.RegularExpression,
                    value: value,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            return {
                literal: str,
                value: value,
                range: [
                    start,
                    index
                ]
            };
        }
        function collectRegex() {
            var pos, loc, regex, token;
            skipComment();
            pos = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            regex = scanRegExp();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            if (!extra.tokenize) {
                if (extra.tokens.length > 0) {
                    token = extra.tokens[extra.tokens.length - 1];
                    if (token.range[0] === pos && token.type === 'Punctuator') {
                        if (token.value === '/' || token.value === '/=') {
                            extra.tokens.pop();
                        }
                    }
                }
                extra.tokens.push({
                    type: 'RegularExpression',
                    value: regex.literal,
                    range: [
                        pos,
                        index
                    ],
                    loc: loc
                });
            }
            return regex;
        }
        function isIdentifierName(token) {
            return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
        }
        function advanceSlash() {
            var prevToken, checkToken;
            prevToken = extra.tokens[extra.tokens.length - 1];
            if (!prevToken) {
                return collectRegex();
            }
            if (prevToken.type === 'Punctuator') {
                if (prevToken.value === ')') {
                    checkToken = extra.tokens[extra.openParenToken - 1];
                    if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
                        return collectRegex();
                    }
                    return scanPunctuator();
                }
                if (prevToken.value === '}') {
                    if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                        checkToken = extra.tokens[extra.openCurlyToken - 4];
                        if (!checkToken) {
                            return scanPunctuator();
                        }
                    } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                        checkToken = extra.tokens[extra.openCurlyToken - 5];
                        if (!checkToken) {
                            return collectRegex();
                        }
                    } else {
                        return scanPunctuator();
                    }
                    if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                        return scanPunctuator();
                    }
                    return collectRegex();
                }
                return collectRegex();
            }
            if (prevToken.type === 'Keyword') {
                return collectRegex();
            }
            return scanPunctuator();
        }
        function advance() {
            var ch;
            skipComment();
            if (index >= length) {
                return {
                    type: Token.EOF,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        index,
                        index
                    ]
                };
            }
            ch = source.charCodeAt(index);
            if (ch === 40 || ch === 41 || ch === 58) {
                return scanPunctuator();
            }
            if (ch === 39 || ch === 34) {
                return scanStringLiteral();
            }
            if (isIdentifierStart(ch)) {
                return scanIdentifier();
            }
            if (ch === 46) {
                if (isDecimalDigit(source.charCodeAt(index + 1))) {
                    return scanNumericLiteral();
                }
                return scanPunctuator();
            }
            if (isDecimalDigit(ch)) {
                return scanNumericLiteral();
            }
            if (extra.tokenize && ch === 47) {
                return advanceSlash();
            }
            return scanPunctuator();
        }
        function collectToken() {
            var start, loc, token, range, value;
            skipComment();
            start = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            token = advance();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            if (token.type !== Token.EOF) {
                range = [
                    token.range[0],
                    token.range[1]
                ];
                value = source.slice(token.range[0], token.range[1]);
                extra.tokens.push({
                    type: TokenName[token.type],
                    value: value,
                    range: range,
                    loc: loc
                });
            }
            return token;
        }
        function lex() {
            var token;
            token = lookahead;
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
            return token;
        }
        function peek() {
            var pos, line, start;
            pos = index;
            line = lineNumber;
            start = lineStart;
            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
            index = pos;
            lineNumber = line;
            lineStart = start;
        }
        SyntaxTreeDelegate = {
            name: 'SyntaxTree',
            markStart: function () {
                if (extra.loc) {
                    state.markerStack.push(index - lineStart);
                    state.markerStack.push(lineNumber);
                }
                if (extra.range) {
                    state.markerStack.push(index);
                }
            },
            processComment: function (node) {
                var i, attacher, pos, len, candidate;
                if (typeof node.type === 'undefined' || node.type === Syntax.Program) {
                    return;
                }
                peek();
                for (i = 0; i < extra.pendingComments.length; ++i) {
                    attacher = extra.pendingComments[i];
                    if (node.range[0] >= attacher.comment.range[1]) {
                        candidate = attacher.leading;
                        if (candidate) {
                            pos = candidate.range[0];
                            len = candidate.range[1] - pos;
                            if (node.range[0] <= pos && node.range[1] - node.range[0] >= len) {
                                attacher.leading = node;
                            }
                        } else {
                            attacher.leading = node;
                        }
                    }
                    if (node.range[1] <= attacher.comment.range[0]) {
                        candidate = attacher.trailing;
                        if (candidate) {
                            pos = candidate.range[0];
                            len = candidate.range[1] - pos;
                            if (node.range[0] <= pos && node.range[1] - node.range[0] >= len) {
                                attacher.trailing = node;
                            }
                        } else {
                            attacher.trailing = node;
                        }
                    }
                }
            },
            markEnd: function (node) {
                if (extra.range) {
                    node.range = [
                        state.markerStack.pop(),
                        index
                    ];
                }
                if (extra.loc) {
                    node.loc = {
                        start: {
                            line: state.markerStack.pop(),
                            column: state.markerStack.pop()
                        },
                        end: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    this.postProcess(node);
                }
                if (extra.attachComment) {
                    this.processComment(node);
                }
                return node;
            },
            markEndIf: function (node) {
                if (node.range || node.loc) {
                    if (extra.loc) {
                        state.markerStack.pop();
                        state.markerStack.pop();
                    }
                    if (extra.range) {
                        state.markerStack.pop();
                    }
                } else {
                    this.markEnd(node);
                }
                return node;
            },
            postProcess: function (node) {
                if (extra.source) {
                    node.loc.source = extra.source;
                }
                return node;
            },
            createArrayExpression: function (elements) {
                return {
                    type: Syntax.ArrayExpression,
                    elements: elements
                };
            },
            createAssignmentExpression: function (operator, left, right) {
                return {
                    type: Syntax.AssignmentExpression,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
            createBinaryExpression: function (operator, left, right) {
                var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
                return {
                    type: type,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
            createBlockStatement: function (body) {
                return {
                    type: Syntax.BlockStatement,
                    body: body
                };
            },
            createBreakStatement: function (label) {
                return {
                    type: Syntax.BreakStatement,
                    label: label
                };
            },
            createCallExpression: function (callee, args) {
                return {
                    type: Syntax.CallExpression,
                    callee: callee,
                    'arguments': args
                };
            },
            createCatchClause: function (param, body) {
                return {
                    type: Syntax.CatchClause,
                    param: param,
                    body: body
                };
            },
            createConditionalExpression: function (test, consequent, alternate) {
                return {
                    type: Syntax.ConditionalExpression,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
            createContinueStatement: function (label) {
                return {
                    type: Syntax.ContinueStatement,
                    label: label
                };
            },
            createDebuggerStatement: function () {
                return { type: Syntax.DebuggerStatement };
            },
            createDoWhileStatement: function (body, test) {
                return {
                    type: Syntax.DoWhileStatement,
                    body: body,
                    test: test
                };
            },
            createEmptyStatement: function () {
                return { type: Syntax.EmptyStatement };
            },
            createExpressionStatement: function (expression) {
                return {
                    type: Syntax.ExpressionStatement,
                    expression: expression
                };
            },
            createForStatement: function (init, test, update, body) {
                return {
                    type: Syntax.ForStatement,
                    init: init,
                    test: test,
                    update: update,
                    body: body
                };
            },
            createForInStatement: function (left, right, body) {
                return {
                    type: Syntax.ForInStatement,
                    left: left,
                    right: right,
                    body: body,
                    each: false
                };
            },
            createFunctionDeclaration: function (id, params, defaults, body) {
                return {
                    type: Syntax.FunctionDeclaration,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            },
            createFunctionExpression: function (id, params, defaults, body) {
                return {
                    type: Syntax.FunctionExpression,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            },
            createIdentifier: function (name) {
                return {
                    type: Syntax.Identifier,
                    name: name
                };
            },
            createIfStatement: function (test, consequent, alternate) {
                return {
                    type: Syntax.IfStatement,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
            createLabeledStatement: function (label, body) {
                return {
                    type: Syntax.LabeledStatement,
                    label: label,
                    body: body
                };
            },
            createLiteral: function (token) {
                return {
                    type: Syntax.Literal,
                    value: token.value,
                    raw: source.slice(token.range[0], token.range[1])
                };
            },
            createMemberExpression: function (accessor, object, property) {
                return {
                    type: Syntax.MemberExpression,
                    computed: accessor === '[',
                    object: object,
                    property: property
                };
            },
            createNewExpression: function (callee, args) {
                return {
                    type: Syntax.NewExpression,
                    callee: callee,
                    'arguments': args
                };
            },
            createObjectExpression: function (properties) {
                return {
                    type: Syntax.ObjectExpression,
                    properties: properties
                };
            },
            createPostfixExpression: function (operator, argument) {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: false
                };
            },
            createProgram: function (body) {
                return {
                    type: Syntax.Program,
                    body: body
                };
            },
            createProperty: function (kind, key, value) {
                return {
                    type: Syntax.Property,
                    key: key,
                    value: value,
                    kind: kind
                };
            },
            createReturnStatement: function (argument) {
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            },
            createSequenceExpression: function (expressions) {
                return {
                    type: Syntax.SequenceExpression,
                    expressions: expressions
                };
            },
            createSwitchCase: function (test, consequent) {
                return {
                    type: Syntax.SwitchCase,
                    test: test,
                    consequent: consequent
                };
            },
            createSwitchStatement: function (discriminant, cases) {
                return {
                    type: Syntax.SwitchStatement,
                    discriminant: discriminant,
                    cases: cases
                };
            },
            createThisExpression: function () {
                return { type: Syntax.ThisExpression };
            },
            createThrowStatement: function (argument) {
                return {
                    type: Syntax.ThrowStatement,
                    argument: argument
                };
            },
            createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
                return {
                    type: Syntax.TryStatement,
                    block: block,
                    guardedHandlers: guardedHandlers,
                    handlers: handlers,
                    finalizer: finalizer
                };
            },
            createUnaryExpression: function (operator, argument) {
                if (operator === '++' || operator === '--') {
                    return {
                        type: Syntax.UpdateExpression,
                        operator: operator,
                        argument: argument,
                        prefix: true
                    };
                }
                return {
                    type: Syntax.UnaryExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            },
            createVariableDeclaration: function (declarations, kind) {
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: declarations,
                    kind: kind
                };
            },
            createVariableDeclarator: function (id, init) {
                return {
                    type: Syntax.VariableDeclarator,
                    id: id,
                    init: init
                };
            },
            createWhileStatement: function (test, body) {
                return {
                    type: Syntax.WhileStatement,
                    test: test,
                    body: body
                };
            },
            createWithStatement: function (object, body) {
                return {
                    type: Syntax.WithStatement,
                    object: object,
                    body: body
                };
            }
        };
        function peekLineTerminator() {
            var pos, line, start, found;
            pos = index;
            line = lineNumber;
            start = lineStart;
            skipComment();
            found = lineNumber !== line;
            index = pos;
            lineNumber = line;
            lineStart = start;
            return found;
        }
        function throwError(token, messageFormat) {
            var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                });
            if (typeof token.lineNumber === 'number') {
                error = new Error('Line ' + token.lineNumber + ': ' + msg);
                error.index = token.range[0];
                error.lineNumber = token.lineNumber;
                error.column = token.range[0] - lineStart + 1;
            } else {
                error = new Error('Line ' + lineNumber + ': ' + msg);
                error.index = index;
                error.lineNumber = lineNumber;
                error.column = index - lineStart + 1;
            }
            error.description = msg;
            throw error;
        }
        function throwErrorTolerant() {
            try {
                throwError.apply(null, arguments);
            } catch (e) {
                if (extra.errors) {
                    extra.errors.push(e);
                } else {
                    throw e;
                }
            }
        }
        function throwUnexpected(token) {
            if (token.type === Token.EOF) {
                throwError(token, Messages.UnexpectedEOS);
            }
            if (token.type === Token.NumericLiteral) {
                throwError(token, Messages.UnexpectedNumber);
            }
            if (token.type === Token.StringLiteral) {
                throwError(token, Messages.UnexpectedString);
            }
            if (token.type === Token.Identifier) {
                throwError(token, Messages.UnexpectedIdentifier);
            }
            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    throwError(token, Messages.UnexpectedReserved);
                } else if (strict && isStrictModeReservedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictReservedWord);
                    return;
                }
                throwError(token, Messages.UnexpectedToken, token.value);
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }
        function expect(value) {
            var token = lex();
            if (token.type !== Token.Punctuator || token.value !== value) {
                throwUnexpected(token);
            }
        }
        function expectKeyword(keyword) {
            var token = lex();
            if (token.type !== Token.Keyword || token.value !== keyword) {
                throwUnexpected(token);
            }
        }
        function match(value) {
            return lookahead.type === Token.Punctuator && lookahead.value === value;
        }
        function matchKeyword(keyword) {
            return lookahead.type === Token.Keyword && lookahead.value === keyword;
        }
        function matchAssign() {
            var op;
            if (lookahead.type !== Token.Punctuator) {
                return false;
            }
            op = lookahead.value;
            return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
        }
        function consumeSemicolon() {
            var line;
            if (source.charCodeAt(index) === 59) {
                lex();
                return;
            }
            line = lineNumber;
            skipComment();
            if (lineNumber !== line) {
                return;
            }
            if (match(';')) {
                lex();
                return;
            }
            if (lookahead.type !== Token.EOF && !match('}')) {
                throwUnexpected(lookahead);
            }
        }
        function isLeftHandSide(expr) {
            return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
        }
        function parseArrayInitialiser() {
            var elements = [];
            expect('[');
            while (!match(']')) {
                if (match(',')) {
                    lex();
                    elements.push(null);
                } else {
                    elements.push(parseAssignmentExpression());
                    if (!match(']')) {
                        expect(',');
                    }
                }
            }
            expect(']');
            return delegate.createArrayExpression(elements);
        }
        function parsePropertyFunction(param, first) {
            var previousStrict, body;
            previousStrict = strict;
            skipComment();
            delegate.markStart();
            body = parseFunctionSourceElements();
            if (first && strict && isRestrictedWord(param[0].name)) {
                throwErrorTolerant(first, Messages.StrictParamName);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));
        }
        function parseObjectPropertyKey() {
            var token;
            skipComment();
            delegate.markStart();
            token = lex();
            if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
                if (strict && token.octal) {
                    throwErrorTolerant(token, Messages.StrictOctalLiteral);
                }
                return delegate.markEnd(delegate.createLiteral(token));
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseObjectProperty() {
            var token, key, id, value, param;
            token = lookahead;
            skipComment();
            delegate.markStart();
            if (token.type === Token.Identifier) {
                id = parseObjectPropertyKey();
                if (token.value === 'get' && !match(':')) {
                    key = parseObjectPropertyKey();
                    expect('(');
                    expect(')');
                    value = parsePropertyFunction([]);
                    return delegate.markEnd(delegate.createProperty('get', key, value));
                }
                if (token.value === 'set' && !match(':')) {
                    key = parseObjectPropertyKey();
                    expect('(');
                    token = lookahead;
                    if (token.type !== Token.Identifier) {
                        expect(')');
                        throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                        value = parsePropertyFunction([]);
                    } else {
                        param = [parseVariableIdentifier()];
                        expect(')');
                        value = parsePropertyFunction(param, token);
                    }
                    return delegate.markEnd(delegate.createProperty('set', key, value));
                }
                expect(':');
                value = parseAssignmentExpression();
                return delegate.markEnd(delegate.createProperty('init', id, value));
            }
            if (token.type === Token.EOF || token.type === Token.Punctuator) {
                throwUnexpected(token);
            } else {
                key = parseObjectPropertyKey();
                expect(':');
                value = parseAssignmentExpression();
                return delegate.markEnd(delegate.createProperty('init', key, value));
            }
        }
        function parseObjectInitialiser() {
            var properties = [], property, name, key, kind, map = {}, toString = String;
            expect('{');
            while (!match('}')) {
                property = parseObjectProperty();
                if (property.key.type === Syntax.Identifier) {
                    name = property.key.name;
                } else {
                    name = toString(property.key.value);
                }
                kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
                key = '$' + name;
                if (Object.prototype.hasOwnProperty.call(map, key)) {
                    if (map[key] === PropertyKind.Data) {
                        if (strict && kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                        } else if (kind !== PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        }
                    } else {
                        if (kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        } else if (map[key] & kind) {
                            throwErrorTolerant({}, Messages.AccessorGetSet);
                        }
                    }
                    map[key] |= kind;
                } else {
                    map[key] = kind;
                }
                properties.push(property);
                if (!match('}')) {
                    expect(',');
                }
            }
            expect('}');
            return delegate.createObjectExpression(properties);
        }
        function parseGroupExpression() {
            var expr;
            expect('(');
            expr = parseExpression();
            expect(')');
            return expr;
        }
        function parsePrimaryExpression() {
            var type, token, expr;
            if (match('(')) {
                return parseGroupExpression();
            }
            type = lookahead.type;
            delegate.markStart();
            if (type === Token.Identifier) {
                expr = delegate.createIdentifier(lex().value);
            } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                if (strict && lookahead.octal) {
                    throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
                }
                expr = delegate.createLiteral(lex());
            } else if (type === Token.Keyword) {
                if (matchKeyword('this')) {
                    lex();
                    expr = delegate.createThisExpression();
                } else if (matchKeyword('function')) {
                    expr = parseFunctionExpression();
                }
            } else if (type === Token.BooleanLiteral) {
                token = lex();
                token.value = token.value === 'true';
                expr = delegate.createLiteral(token);
            } else if (type === Token.NullLiteral) {
                token = lex();
                token.value = null;
                expr = delegate.createLiteral(token);
            } else if (match('[')) {
                expr = parseArrayInitialiser();
            } else if (match('{')) {
                expr = parseObjectInitialiser();
            } else if (match('/') || match('/=')) {
                if (typeof extra.tokens !== 'undefined') {
                    expr = delegate.createLiteral(collectRegex());
                } else {
                    expr = delegate.createLiteral(scanRegExp());
                }
            }
            if (expr) {
                return delegate.markEnd(expr);
            }
            throwUnexpected(lex());
        }
        function parseArguments() {
            var args = [];
            expect('(');
            if (!match(')')) {
                while (index < length) {
                    args.push(parseAssignmentExpression());
                    if (match(')')) {
                        break;
                    }
                    expect(',');
                }
            }
            expect(')');
            return args;
        }
        function parseNonComputedProperty() {
            var token;
            delegate.markStart();
            token = lex();
            if (!isIdentifierName(token)) {
                throwUnexpected(token);
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseNonComputedMember() {
            expect('.');
            return parseNonComputedProperty();
        }
        function parseComputedMember() {
            var expr;
            expect('[');
            expr = parseExpression();
            expect(']');
            return expr;
        }
        function parseNewExpression() {
            var callee, args;
            delegate.markStart();
            expectKeyword('new');
            callee = parseLeftHandSideExpression();
            args = match('(') ? parseArguments() : [];
            return delegate.markEnd(delegate.createNewExpression(callee, args));
        }
        function parseLeftHandSideExpressionAllowCall() {
            var marker, previousAllowIn, expr, args, property;
            marker = createLocationMarker();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
            state.allowIn = previousAllowIn;
            while (match('.') || match('[') || match('(')) {
                if (match('(')) {
                    args = parseArguments();
                    expr = delegate.createCallExpression(expr, args);
                } else if (match('[')) {
                    property = parseComputedMember();
                    expr = delegate.createMemberExpression('[', expr, property);
                } else {
                    property = parseNonComputedMember();
                    expr = delegate.createMemberExpression('.', expr, property);
                }
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        function parseLeftHandSideExpression() {
            var marker, previousAllowIn, expr, property;
            marker = createLocationMarker();
            previousAllowIn = state.allowIn;
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
            state.allowIn = previousAllowIn;
            while (match('.') || match('[')) {
                if (match('[')) {
                    property = parseComputedMember();
                    expr = delegate.createMemberExpression('[', expr, property);
                } else {
                    property = parseNonComputedMember();
                    expr = delegate.createMemberExpression('.', expr, property);
                }
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        function parsePostfixExpression() {
            var expr, token;
            delegate.markStart();
            expr = parseLeftHandSideExpressionAllowCall();
            if (lookahead.type === Token.Punctuator) {
                if ((match('++') || match('--')) && !peekLineTerminator()) {
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        throwErrorTolerant({}, Messages.StrictLHSPostfix);
                    }
                    if (!isLeftHandSide(expr)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                    }
                    token = lex();
                    expr = delegate.createPostfixExpression(token.value, expr);
                }
            }
            return delegate.markEndIf(expr);
        }
        function parseUnaryExpression() {
            var token, expr;
            delegate.markStart();
            if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                expr = parsePostfixExpression();
            } else if (match('++') || match('--')) {
                token = lex();
                expr = parseUnaryExpression();
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPrefix);
                }
                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }
                expr = delegate.createUnaryExpression(token.value, expr);
            } else if (match('+') || match('-') || match('~') || match('!')) {
                token = lex();
                expr = parseUnaryExpression();
                expr = delegate.createUnaryExpression(token.value, expr);
            } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                token = lex();
                expr = parseUnaryExpression();
                expr = delegate.createUnaryExpression(token.value, expr);
                if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                    throwErrorTolerant({}, Messages.StrictDelete);
                }
            } else {
                expr = parsePostfixExpression();
            }
            return delegate.markEndIf(expr);
        }
        function binaryPrecedence(token, allowIn) {
            var prec = 0;
            if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                return 0;
            }
            switch (token.value) {
            case '||':
                prec = 1;
                break;
            case '&&':
                prec = 2;
                break;
            case '|':
                prec = 3;
                break;
            case '^':
                prec = 4;
                break;
            case '&':
                prec = 5;
                break;
            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;
            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;
            case 'in':
                prec = allowIn ? 7 : 0;
                break;
            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;
            case '+':
            case '-':
                prec = 9;
                break;
            case '*':
            case '/':
            case '%':
                prec = 11;
                break;
            default:
                break;
            }
            return prec;
        }
        function parseBinaryExpression() {
            var marker, markers, expr, token, prec, stack, right, operator, left, i;
            marker = createLocationMarker();
            left = parseUnaryExpression();
            token = lookahead;
            prec = binaryPrecedence(token, state.allowIn);
            if (prec === 0) {
                return left;
            }
            token.prec = prec;
            lex();
            markers = [
                marker,
                createLocationMarker()
            ];
            right = parseUnaryExpression();
            stack = [
                left,
                token,
                right
            ];
            while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
                while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                    right = stack.pop();
                    operator = stack.pop().value;
                    left = stack.pop();
                    expr = delegate.createBinaryExpression(operator, left, right);
                    markers.pop();
                    marker = markers.pop();
                    if (marker) {
                        marker.end();
                        marker.apply(expr);
                    }
                    stack.push(expr);
                    markers.push(marker);
                }
                token = lex();
                token.prec = prec;
                stack.push(token);
                markers.push(createLocationMarker());
                expr = parseUnaryExpression();
                stack.push(expr);
            }
            i = stack.length - 1;
            expr = stack[i];
            markers.pop();
            while (i > 1) {
                expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                i -= 2;
                marker = markers.pop();
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        function parseConditionalExpression() {
            var expr, previousAllowIn, consequent, alternate;
            delegate.markStart();
            expr = parseBinaryExpression();
            if (match('?')) {
                lex();
                previousAllowIn = state.allowIn;
                state.allowIn = true;
                consequent = parseAssignmentExpression();
                state.allowIn = previousAllowIn;
                expect(':');
                alternate = parseAssignmentExpression();
                expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));
            } else {
                delegate.markEnd({});
            }
            return expr;
        }
        function parseAssignmentExpression() {
            var token, left, right, node;
            token = lookahead;
            delegate.markStart();
            node = left = parseConditionalExpression();
            if (matchAssign()) {
                if (!isLeftHandSide(left)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }
                if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                    throwErrorTolerant(token, Messages.StrictLHSAssignment);
                }
                token = lex();
                right = parseAssignmentExpression();
                node = delegate.createAssignmentExpression(token.value, left, right);
            }
            return delegate.markEndIf(node);
        }
        function parseExpression() {
            var expr;
            delegate.markStart();
            expr = parseAssignmentExpression();
            if (match(',')) {
                expr = delegate.createSequenceExpression([expr]);
                while (index < length) {
                    if (!match(',')) {
                        break;
                    }
                    lex();
                    expr.expressions.push(parseAssignmentExpression());
                }
            }
            return delegate.markEndIf(expr);
        }
        function parseStatementList() {
            var list = [], statement;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                statement = parseSourceElement();
                if (typeof statement === 'undefined') {
                    break;
                }
                list.push(statement);
            }
            return list;
        }
        function parseBlock() {
            var block;
            skipComment();
            delegate.markStart();
            expect('{');
            block = parseStatementList();
            expect('}');
            return delegate.markEnd(delegate.createBlockStatement(block));
        }
        function parseVariableIdentifier() {
            var token;
            skipComment();
            delegate.markStart();
            token = lex();
            if (token.type !== Token.Identifier) {
                throwUnexpected(token);
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseVariableDeclaration(kind) {
            var init = null, id;
            skipComment();
            delegate.markStart();
            id = parseVariableIdentifier();
            if (strict && isRestrictedWord(id.name)) {
                throwErrorTolerant({}, Messages.StrictVarName);
            }
            if (kind === 'const') {
                expect('=');
                init = parseAssignmentExpression();
            } else if (match('=')) {
                lex();
                init = parseAssignmentExpression();
            }
            return delegate.markEnd(delegate.createVariableDeclarator(id, init));
        }
        function parseVariableDeclarationList(kind) {
            var list = [];
            do {
                list.push(parseVariableDeclaration(kind));
                if (!match(',')) {
                    break;
                }
                lex();
            } while (index < length);
            return list;
        }
        function parseVariableStatement() {
            var declarations;
            expectKeyword('var');
            declarations = parseVariableDeclarationList();
            consumeSemicolon();
            return delegate.createVariableDeclaration(declarations, 'var');
        }
        function parseConstLetDeclaration(kind) {
            var declarations;
            skipComment();
            delegate.markStart();
            expectKeyword(kind);
            declarations = parseVariableDeclarationList(kind);
            consumeSemicolon();
            return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind));
        }
        function parseEmptyStatement() {
            expect(';');
            return delegate.createEmptyStatement();
        }
        function parseExpressionStatement() {
            var expr = parseExpression();
            consumeSemicolon();
            return delegate.createExpressionStatement(expr);
        }
        function parseIfStatement() {
            var test, consequent, alternate;
            expectKeyword('if');
            expect('(');
            test = parseExpression();
            expect(')');
            consequent = parseStatement();
            if (matchKeyword('else')) {
                lex();
                alternate = parseStatement();
            } else {
                alternate = null;
            }
            return delegate.createIfStatement(test, consequent, alternate);
        }
        function parseDoWhileStatement() {
            var body, test, oldInIteration;
            expectKeyword('do');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            expectKeyword('while');
            expect('(');
            test = parseExpression();
            expect(')');
            if (match(';')) {
                lex();
            }
            return delegate.createDoWhileStatement(body, test);
        }
        function parseWhileStatement() {
            var test, body, oldInIteration;
            expectKeyword('while');
            expect('(');
            test = parseExpression();
            expect(')');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            return delegate.createWhileStatement(test, body);
        }
        function parseForVariableDeclaration() {
            var token, declarations;
            delegate.markStart();
            token = lex();
            declarations = parseVariableDeclarationList();
            return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value));
        }
        function parseForStatement() {
            var init, test, update, left, right, body, oldInIteration;
            init = test = update = null;
            expectKeyword('for');
            expect('(');
            if (match(';')) {
                lex();
            } else {
                if (matchKeyword('var') || matchKeyword('let')) {
                    state.allowIn = false;
                    init = parseForVariableDeclaration();
                    state.allowIn = true;
                    if (init.declarations.length === 1 && matchKeyword('in')) {
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                } else {
                    state.allowIn = false;
                    init = parseExpression();
                    state.allowIn = true;
                    if (matchKeyword('in')) {
                        if (!isLeftHandSide(init)) {
                            throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                        }
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                }
                if (typeof left === 'undefined') {
                    expect(';');
                }
            }
            if (typeof left === 'undefined') {
                if (!match(';')) {
                    test = parseExpression();
                }
                expect(';');
                if (!match(')')) {
                    update = parseExpression();
                }
            }
            expect(')');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
        }
        function parseContinueStatement() {
            var label = null, key;
            expectKeyword('continue');
            if (source.charCodeAt(index) === 59) {
                lex();
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
                return delegate.createContinueStatement(null);
            }
            if (peekLineTerminator()) {
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
                return delegate.createContinueStatement(null);
            }
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
            consumeSemicolon();
            if (label === null && !state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }
            return delegate.createContinueStatement(label);
        }
        function parseBreakStatement() {
            var label = null, key;
            expectKeyword('break');
            if (source.charCodeAt(index) === 59) {
                lex();
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
                return delegate.createBreakStatement(null);
            }
            if (peekLineTerminator()) {
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
                return delegate.createBreakStatement(null);
            }
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
            consumeSemicolon();
            if (label === null && !(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }
            return delegate.createBreakStatement(label);
        }
        function parseReturnStatement() {
            var argument = null;
            expectKeyword('return');
            if (!state.inFunctionBody) {
                throwErrorTolerant({}, Messages.IllegalReturn);
            }
            if (source.charCodeAt(index) === 32) {
                if (isIdentifierStart(source.charCodeAt(index + 1))) {
                    argument = parseExpression();
                    consumeSemicolon();
                    return delegate.createReturnStatement(argument);
                }
            }
            if (peekLineTerminator()) {
                return delegate.createReturnStatement(null);
            }
            if (!match(';')) {
                if (!match('}') && lookahead.type !== Token.EOF) {
                    argument = parseExpression();
                }
            }
            consumeSemicolon();
            return delegate.createReturnStatement(argument);
        }
        function parseWithStatement() {
            var object, body;
            if (strict) {
                throwErrorTolerant({}, Messages.StrictModeWith);
            }
            expectKeyword('with');
            expect('(');
            object = parseExpression();
            expect(')');
            body = parseStatement();
            return delegate.createWithStatement(object, body);
        }
        function parseSwitchCase() {
            var test, consequent = [], statement;
            skipComment();
            delegate.markStart();
            if (matchKeyword('default')) {
                lex();
                test = null;
            } else {
                expectKeyword('case');
                test = parseExpression();
            }
            expect(':');
            while (index < length) {
                if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                    break;
                }
                statement = parseStatement();
                consequent.push(statement);
            }
            return delegate.markEnd(delegate.createSwitchCase(test, consequent));
        }
        function parseSwitchStatement() {
            var discriminant, cases, clause, oldInSwitch, defaultFound;
            expectKeyword('switch');
            expect('(');
            discriminant = parseExpression();
            expect(')');
            expect('{');
            cases = [];
            if (match('}')) {
                lex();
                return delegate.createSwitchStatement(discriminant, cases);
            }
            oldInSwitch = state.inSwitch;
            state.inSwitch = true;
            defaultFound = false;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                clause = parseSwitchCase();
                if (clause.test === null) {
                    if (defaultFound) {
                        throwError({}, Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                }
                cases.push(clause);
            }
            state.inSwitch = oldInSwitch;
            expect('}');
            return delegate.createSwitchStatement(discriminant, cases);
        }
        function parseThrowStatement() {
            var argument;
            expectKeyword('throw');
            if (peekLineTerminator()) {
                throwError({}, Messages.NewlineAfterThrow);
            }
            argument = parseExpression();
            consumeSemicolon();
            return delegate.createThrowStatement(argument);
        }
        function parseCatchClause() {
            var param, body;
            skipComment();
            delegate.markStart();
            expectKeyword('catch');
            expect('(');
            if (match(')')) {
                throwUnexpected(lookahead);
            }
            param = parseVariableIdentifier();
            if (strict && isRestrictedWord(param.name)) {
                throwErrorTolerant({}, Messages.StrictCatchVariable);
            }
            expect(')');
            body = parseBlock();
            return delegate.markEnd(delegate.createCatchClause(param, body));
        }
        function parseTryStatement() {
            var block, handlers = [], finalizer = null;
            expectKeyword('try');
            block = parseBlock();
            if (matchKeyword('catch')) {
                handlers.push(parseCatchClause());
            }
            if (matchKeyword('finally')) {
                lex();
                finalizer = parseBlock();
            }
            if (handlers.length === 0 && !finalizer) {
                throwError({}, Messages.NoCatchOrFinally);
            }
            return delegate.createTryStatement(block, [], handlers, finalizer);
        }
        function parseDebuggerStatement() {
            expectKeyword('debugger');
            consumeSemicolon();
            return delegate.createDebuggerStatement();
        }
        function parseStatement() {
            var type = lookahead.type, expr, labeledBody, key;
            if (type === Token.EOF) {
                throwUnexpected(lookahead);
            }
            skipComment();
            delegate.markStart();
            if (type === Token.Punctuator) {
                switch (lookahead.value) {
                case ';':
                    return delegate.markEnd(parseEmptyStatement());
                case '{':
                    return delegate.markEnd(parseBlock());
                case '(':
                    return delegate.markEnd(parseExpressionStatement());
                default:
                    break;
                }
            }
            if (type === Token.Keyword) {
                switch (lookahead.value) {
                case 'break':
                    return delegate.markEnd(parseBreakStatement());
                case 'continue':
                    return delegate.markEnd(parseContinueStatement());
                case 'debugger':
                    return delegate.markEnd(parseDebuggerStatement());
                case 'do':
                    return delegate.markEnd(parseDoWhileStatement());
                case 'for':
                    return delegate.markEnd(parseForStatement());
                case 'function':
                    return delegate.markEnd(parseFunctionDeclaration());
                case 'if':
                    return delegate.markEnd(parseIfStatement());
                case 'return':
                    return delegate.markEnd(parseReturnStatement());
                case 'switch':
                    return delegate.markEnd(parseSwitchStatement());
                case 'throw':
                    return delegate.markEnd(parseThrowStatement());
                case 'try':
                    return delegate.markEnd(parseTryStatement());
                case 'var':
                    return delegate.markEnd(parseVariableStatement());
                case 'while':
                    return delegate.markEnd(parseWhileStatement());
                case 'with':
                    return delegate.markEnd(parseWithStatement());
                default:
                    break;
                }
            }
            expr = parseExpression();
            if (expr.type === Syntax.Identifier && match(':')) {
                lex();
                key = '$' + expr.name;
                if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.Redeclaration, 'Label', expr.name);
                }
                state.labelSet[key] = true;
                labeledBody = parseStatement();
                delete state.labelSet[key];
                return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody));
            }
            consumeSemicolon();
            return delegate.markEnd(delegate.createExpressionStatement(expr));
        }
        function parseFunctionSourceElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;
            skipComment();
            delegate.markStart();
            expect('{');
            while (index < length) {
                if (lookahead.type !== Token.StringLiteral) {
                    break;
                }
                token = lookahead;
                sourceElement = parseSourceElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
            oldLabelSet = state.labelSet;
            oldInIteration = state.inIteration;
            oldInSwitch = state.inSwitch;
            oldInFunctionBody = state.inFunctionBody;
            state.labelSet = {};
            state.inIteration = false;
            state.inSwitch = false;
            state.inFunctionBody = true;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
            expect('}');
            state.labelSet = oldLabelSet;
            state.inIteration = oldInIteration;
            state.inSwitch = oldInSwitch;
            state.inFunctionBody = oldInFunctionBody;
            return delegate.markEnd(delegate.createBlockStatement(sourceElements));
        }
        function parseParams(firstRestricted) {
            var param, params = [], token, stricted, paramSet, key, message;
            expect('(');
            if (!match(')')) {
                paramSet = {};
                while (index < length) {
                    token = lookahead;
                    param = parseVariableIdentifier();
                    key = '$' + token.value;
                    if (strict) {
                        if (isRestrictedWord(token.value)) {
                            stricted = token;
                            message = Messages.StrictParamName;
                        }
                        if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                            stricted = token;
                            message = Messages.StrictParamDupe;
                        }
                    } else if (!firstRestricted) {
                        if (isRestrictedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictParamName;
                        } else if (isStrictModeReservedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictReservedWord;
                        } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                            firstRestricted = token;
                            message = Messages.StrictParamDupe;
                        }
                    }
                    params.push(param);
                    paramSet[key] = true;
                    if (match(')')) {
                        break;
                    }
                    expect(',');
                }
            }
            expect(')');
            return {
                params: params,
                stricted: stricted,
                firstRestricted: firstRestricted,
                message: message
            };
        }
        function parseFunctionDeclaration() {
            var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;
            skipComment();
            delegate.markStart();
            expectKeyword('function');
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && stricted) {
                throwErrorTolerant(stricted, message);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body));
        }
        function parseFunctionExpression() {
            var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;
            delegate.markStart();
            expectKeyword('function');
            if (!match('(')) {
                token = lookahead;
                id = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && stricted) {
                throwErrorTolerant(stricted, message);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body));
        }
        function parseSourceElement() {
            if (lookahead.type === Token.Keyword) {
                switch (lookahead.value) {
                case 'const':
                case 'let':
                    return parseConstLetDeclaration(lookahead.value);
                case 'function':
                    return parseFunctionDeclaration();
                default:
                    return parseStatement();
                }
            }
            if (lookahead.type !== Token.EOF) {
                return parseStatement();
            }
        }
        function parseSourceElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted;
            while (index < length) {
                token = lookahead;
                if (token.type !== Token.StringLiteral) {
                    break;
                }
                sourceElement = parseSourceElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
            while (index < length) {
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
            return sourceElements;
        }
        function parseProgram() {
            var body;
            skipComment();
            delegate.markStart();
            strict = false;
            peek();
            body = parseSourceElements();
            return delegate.markEnd(delegate.createProgram(body));
        }
        function attachComments() {
            var i, attacher, comment, leading, trailing;
            for (i = 0; i < extra.pendingComments.length; ++i) {
                attacher = extra.pendingComments[i];
                comment = attacher.comment;
                leading = attacher.leading;
                if (leading) {
                    if (typeof leading.leadingComments === 'undefined') {
                        leading.leadingComments = [];
                    }
                    leading.leadingComments.push(attacher.comment);
                }
                trailing = attacher.trailing;
                if (trailing) {
                    if (typeof trailing.trailingComments === 'undefined') {
                        trailing.trailingComments = [];
                    }
                    trailing.trailingComments.push(attacher.comment);
                }
            }
            extra.pendingComments = [];
        }
        function filterTokenLocation() {
            var i, entry, token, tokens = [];
            for (i = 0; i < extra.tokens.length; ++i) {
                entry = extra.tokens[i];
                token = {
                    type: entry.type,
                    value: entry.value
                };
                if (extra.range) {
                    token.range = entry.range;
                }
                if (extra.loc) {
                    token.loc = entry.loc;
                }
                tokens.push(token);
            }
            extra.tokens = tokens;
        }
        function LocationMarker() {
            this.marker = [
                index,
                lineNumber,
                index - lineStart,
                0,
                0,
                0
            ];
        }
        LocationMarker.prototype = {
            constructor: LocationMarker,
            end: function () {
                this.marker[3] = index;
                this.marker[4] = lineNumber;
                this.marker[5] = index - lineStart;
            },
            apply: function (node) {
                if (extra.range) {
                    node.range = [
                        this.marker[0],
                        this.marker[3]
                    ];
                }
                if (extra.loc) {
                    node.loc = {
                        start: {
                            line: this.marker[1],
                            column: this.marker[2]
                        },
                        end: {
                            line: this.marker[4],
                            column: this.marker[5]
                        }
                    };
                    node = delegate.postProcess(node);
                }
                if (extra.attachComment) {
                    delegate.processComment(node);
                }
            }
        };
        function createLocationMarker() {
            if (!extra.loc && !extra.range) {
                return null;
            }
            skipComment();
            return new LocationMarker();
        }
        function tokenize(code, options) {
            var toString, token, tokens;
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = source.length > 0 ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1
            };
            extra = {};
            options = options || {};
            options.tokens = true;
            extra.tokens = [];
            extra.tokenize = true;
            extra.openParenToken = -1;
            extra.openCurlyToken = -1;
            extra.range = typeof options.range === 'boolean' && options.range;
            extra.loc = typeof options.loc === 'boolean' && options.loc;
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (length > 0) {
                if (typeof source[0] === 'undefined') {
                    if (code instanceof String) {
                        source = code.valueOf();
                    }
                }
            }
            try {
                peek();
                if (lookahead.type === Token.EOF) {
                    return extra.tokens;
                }
                token = lex();
                while (lookahead.type !== Token.EOF) {
                    try {
                        token = lex();
                    } catch (lexError) {
                        token = lookahead;
                        if (extra.errors) {
                            extra.errors.push(lexError);
                            break;
                        } else {
                            throw lexError;
                        }
                    }
                }
                filterTokenLocation();
                tokens = extra.tokens;
                if (typeof extra.comments !== 'undefined') {
                    tokens.comments = extra.comments;
                }
                if (typeof extra.errors !== 'undefined') {
                    tokens.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
            return tokens;
        }
        function parse(code, options) {
            var program, toString;
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = source.length > 0 ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1,
                markerStack: []
            };
            extra = {};
            if (typeof options !== 'undefined') {
                extra.range = typeof options.range === 'boolean' && options.range;
                extra.loc = typeof options.loc === 'boolean' && options.loc;
                extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
                if (extra.loc && options.source !== null && options.source !== undefined) {
                    extra.source = toString(options.source);
                }
                if (typeof options.tokens === 'boolean' && options.tokens) {
                    extra.tokens = [];
                }
                if (typeof options.comment === 'boolean' && options.comment) {
                    extra.comments = [];
                }
                if (typeof options.tolerant === 'boolean' && options.tolerant) {
                    extra.errors = [];
                }
                if (extra.attachComment) {
                    extra.range = true;
                    extra.pendingComments = [];
                    extra.comments = [];
                }
            }
            if (length > 0) {
                if (typeof source[0] === 'undefined') {
                    if (code instanceof String) {
                        source = code.valueOf();
                    }
                }
            }
            try {
                program = parseProgram();
                if (typeof extra.comments !== 'undefined') {
                    program.comments = extra.comments;
                }
                if (typeof extra.tokens !== 'undefined') {
                    filterTokenLocation();
                    program.tokens = extra.tokens;
                }
                if (typeof extra.errors !== 'undefined') {
                    program.errors = extra.errors;
                }
                if (extra.attachComment) {
                    attachComments();
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
            return program;
        }
        exports.version = '1.1.0-dev';
        exports.tokenize = tokenize;
        exports.parse = parse;
        exports.Syntax = function () {
            var name, types = {};
            if (typeof Object.create === 'function') {
                types = Object.create(null);
            }
            for (name in Syntax) {
                if (Syntax.hasOwnProperty(name)) {
                    types[name] = Syntax[name];
                }
            }
            if (typeof Object.freeze === 'function') {
                Object.freeze(types);
            }
            return types;
        }();
        return exports;
    }));
    (function (root, factory) {
        
        if (true) {
            amdclean_website['estraverse'] = function (module) {
                return factory();
            }({});
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory(root.estraverse = {});
        }
    }(this, function (exports) {
        exports = exports || {};
        
        var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            ArrayExpression: 'ArrayExpression',
            ArrowFunctionExpression: 'ArrowFunctionExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DebuggerStatement: 'DebuggerStatement',
            DirectiveStatement: 'DirectiveStatement',
            DoWhileStatement: 'DoWhileStatement',
            EmptyStatement: 'EmptyStatement',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            Program: 'Program',
            Property: 'Property',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement',
            YieldExpression: 'YieldExpression'
        };
        function ignoreJSHintError() {
        }
        isArray = Array.isArray;
        if (!isArray) {
            isArray = function isArray(array) {
                return Object.prototype.toString.call(array) === '[object Array]';
            };
        }
        function deepCopy(obj) {
            var ret = {}, key, val;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    val = obj[key];
                    if (typeof val === 'object' && val !== null) {
                        ret[key] = deepCopy(val);
                    } else {
                        ret[key] = val;
                    }
                }
            }
            return ret;
        }
        function shallowCopy(obj) {
            var ret = {}, key;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        ignoreJSHintError(shallowCopy);
        function upperBound(array, func) {
            var diff, len, i, current;
            len = array.length;
            i = 0;
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    len = diff;
                } else {
                    i = current + 1;
                    len -= diff + 1;
                }
            }
            return i;
        }
        function lowerBound(array, func) {
            var diff, len, i, current;
            len = array.length;
            i = 0;
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    i = current + 1;
                    len -= diff + 1;
                } else {
                    len = diff;
                }
            }
            return i;
        }
        ignoreJSHintError(lowerBound);
        VisitorKeys = {
            AssignmentExpression: [
                'left',
                'right'
            ],
            ArrayExpression: ['elements'],
            ArrowFunctionExpression: [
                'params',
                'body'
            ],
            BlockStatement: ['body'],
            BinaryExpression: [
                'left',
                'right'
            ],
            BreakStatement: ['label'],
            CallExpression: [
                'callee',
                'arguments'
            ],
            CatchClause: [
                'param',
                'body'
            ],
            ConditionalExpression: [
                'test',
                'consequent',
                'alternate'
            ],
            ContinueStatement: ['label'],
            DebuggerStatement: [],
            DirectiveStatement: [],
            DoWhileStatement: [
                'body',
                'test'
            ],
            EmptyStatement: [],
            ExpressionStatement: ['expression'],
            ForStatement: [
                'init',
                'test',
                'update',
                'body'
            ],
            ForInStatement: [
                'left',
                'right',
                'body'
            ],
            FunctionDeclaration: [
                'id',
                'params',
                'body'
            ],
            FunctionExpression: [
                'id',
                'params',
                'body'
            ],
            Identifier: [],
            IfStatement: [
                'test',
                'consequent',
                'alternate'
            ],
            Literal: [],
            LabeledStatement: [
                'label',
                'body'
            ],
            LogicalExpression: [
                'left',
                'right'
            ],
            MemberExpression: [
                'object',
                'property'
            ],
            NewExpression: [
                'callee',
                'arguments'
            ],
            ObjectExpression: ['properties'],
            Program: ['body'],
            Property: [
                'key',
                'value'
            ],
            ReturnStatement: ['argument'],
            SequenceExpression: ['expressions'],
            SwitchStatement: [
                'discriminant',
                'cases'
            ],
            SwitchCase: [
                'test',
                'consequent'
            ],
            ThisExpression: [],
            ThrowStatement: ['argument'],
            TryStatement: [
                'block',
                'handlers',
                'handler',
                'guardedHandlers',
                'finalizer'
            ],
            UnaryExpression: ['argument'],
            UpdateExpression: ['argument'],
            VariableDeclaration: ['declarations'],
            VariableDeclarator: [
                'id',
                'init'
            ],
            WhileStatement: [
                'test',
                'body'
            ],
            WithStatement: [
                'object',
                'body'
            ],
            YieldExpression: ['argument']
        };
        BREAK = {};
        SKIP = {};
        VisitorOption = {
            Break: BREAK,
            Skip: SKIP
        };
        function Reference(parent, key) {
            this.parent = parent;
            this.key = key;
        }
        Reference.prototype.replace = function replace(node) {
            this.parent[this.key] = node;
        };
        function Element(node, path, wrap, ref) {
            this.node = node;
            this.path = path;
            this.wrap = wrap;
            this.ref = ref;
        }
        function Controller() {
        }
        Controller.prototype.path = function path() {
            var i, iz, j, jz, result, element;
            function addToPath(result, path) {
                if (isArray(path)) {
                    for (j = 0, jz = path.length; j < jz; ++j) {
                        result.push(path[j]);
                    }
                } else {
                    result.push(path);
                }
            }
            if (!this.__current.path) {
                return null;
            }
            result = [];
            for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                element = this.__leavelist[i];
                addToPath(result, element.path);
            }
            addToPath(result, this.__current.path);
            return result;
        };
        Controller.prototype.parents = function parents() {
            var i, iz, result;
            result = [];
            for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                result.push(this.__leavelist[i].node);
            }
            return result;
        };
        Controller.prototype.current = function current() {
            return this.__current.node;
        };
        Controller.prototype.__execute = function __execute(callback, element) {
            var previous, result;
            result = undefined;
            previous = this.__current;
            this.__current = element;
            this.__state = null;
            if (callback) {
                result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
            }
            this.__current = previous;
            return result;
        };
        Controller.prototype.notify = function notify(flag) {
            this.__state = flag;
        };
        Controller.prototype.skip = function () {
            this.notify(SKIP);
        };
        Controller.prototype['break'] = function () {
            this.notify(BREAK);
        };
        Controller.prototype.__initialize = function (root, visitor) {
            this.visitor = visitor;
            this.root = root;
            this.__worklist = [];
            this.__leavelist = [];
            this.__current = null;
            this.__state = null;
        };
        Controller.prototype.traverse = function traverse(root, visitor) {
            var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
            this.__initialize(root, visitor);
            sentinel = {};
            worklist = this.__worklist;
            leavelist = this.__leavelist;
            worklist.push(new Element(root, null, null, null));
            leavelist.push(new Element(null, null, null, null));
            while (worklist.length) {
                element = worklist.pop();
                if (element === sentinel) {
                    element = leavelist.pop();
                    ret = this.__execute(visitor.leave, element);
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
                    continue;
                }
                if (element.node) {
                    ret = this.__execute(visitor.enter, element);
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
                    worklist.push(sentinel);
                    leavelist.push(element);
                    if (this.__state === SKIP || ret === SKIP) {
                        continue;
                    }
                    node = element.node;
                    nodeType = element.wrap || node.type;
                    candidates = VisitorKeys[nodeType];
                    current = candidates.length;
                    while ((current -= 1) >= 0) {
                        key = candidates[current];
                        candidate = node[key];
                        if (!candidate) {
                            continue;
                        }
                        if (!isArray(candidate)) {
                            worklist.push(new Element(candidate, key, null, null));
                            continue;
                        }
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                                element = new Element(candidate[current2], [
                                    key,
                                    current2
                                ], 'Property', null);
                            } else {
                                element = new Element(candidate[current2], [
                                    key,
                                    current2
                                ], null, null);
                            }
                            worklist.push(element);
                        }
                    }
                }
            }
        };
        Controller.prototype.replace = function replace(root, visitor) {
            var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
            this.__initialize(root, visitor);
            sentinel = {};
            worklist = this.__worklist;
            leavelist = this.__leavelist;
            outer = { root: root };
            element = new Element(root, null, null, new Reference(outer, 'root'));
            worklist.push(element);
            leavelist.push(element);
            while (worklist.length) {
                element = worklist.pop();
                if (element === sentinel) {
                    element = leavelist.pop();
                    target = this.__execute(visitor.leave, element);
                    if (target !== undefined && target !== BREAK && target !== SKIP) {
                        element.ref.replace(target);
                    }
                    if (this.__state === BREAK || target === BREAK) {
                        return outer.root;
                    }
                    continue;
                }
                target = this.__execute(visitor.enter, element);
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    element.ref.replace(target);
                    element.node = target;
                }
                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                node = element.node;
                if (!node) {
                    continue;
                }
                worklist.push(sentinel);
                leavelist.push(element);
                if (this.__state === SKIP || target === SKIP) {
                    continue;
                }
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];
                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }
                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                        continue;
                    }
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [
                                key,
                                current2
                            ], 'Property', new Reference(candidate, current2));
                        } else {
                            element = new Element(candidate[current2], [
                                key,
                                current2
                            ], null, new Reference(candidate, current2));
                        }
                        worklist.push(element);
                    }
                }
            }
            return outer.root;
        };
        function traverse(root, visitor) {
            var controller = new Controller();
            return controller.traverse(root, visitor);
        }
        function replace(root, visitor) {
            var controller = new Controller();
            return controller.replace(root, visitor);
        }
        function extendCommentRange(comment, tokens) {
            var target, token;
            target = upperBound(tokens, function search(token) {
                return token.range[0] > comment.range[0];
            });
            comment.extendedRange = [
                comment.range[0],
                comment.range[1]
            ];
            if (target !== tokens.length) {
                comment.extendedRange[1] = tokens[target].range[0];
            }
            target -= 1;
            if (target >= 0) {
                if (target < tokens.length) {
                    comment.extendedRange[0] = tokens[target].range[1];
                } else if (token.length) {
                    comment.extendedRange[1] = tokens[tokens.length - 1].range[0];
                }
            }
            return comment;
        }
        function attachComments(tree, providedComments, tokens) {
            var comments = [], comment, len, i, cursor;
            if (!tree.range) {
                throw new Error('attachComments needs range information');
            }
            if (!tokens.length) {
                if (providedComments.length) {
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comment = deepCopy(providedComments[i]);
                        comment.extendedRange = [
                            0,
                            tree.range[0]
                        ];
                        comments.push(comment);
                    }
                    tree.leadingComments = comments;
                }
                return tree;
            }
            for (i = 0, len = providedComments.length; i < len; i += 1) {
                comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
            }
            cursor = 0;
            traverse(tree, {
                enter: function (node) {
                    var comment;
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (comment.extendedRange[1] > node.range[0]) {
                            break;
                        }
                        if (comment.extendedRange[1] === node.range[0]) {
                            if (!node.leadingComments) {
                                node.leadingComments = [];
                            }
                            node.leadingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
            cursor = 0;
            traverse(tree, {
                leave: function (node) {
                    var comment;
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (node.range[1] < comment.extendedRange[0]) {
                            break;
                        }
                        if (node.range[1] === comment.extendedRange[0]) {
                            if (!node.trailingComments) {
                                node.trailingComments = [];
                            }
                            node.trailingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
            return tree;
        }
        exports.version = '1.3.2-dev';
        exports.Syntax = Syntax;
        exports.traverse = traverse;
        exports.replace = replace;
        exports.attachComments = attachComments;
        exports.VisitorKeys = VisitorKeys;
        exports.VisitorOption = VisitorOption;
        exports.Controller = Controller;
        return exports;
    }));
    (function () {
        var require = function (file, cwd) {
            var resolved = require.resolve(file, cwd || '/');
            var mod = require.modules[resolved];
            if (!mod)
                throw new Error('Failed to resolve module ' + file + ', tried ' + resolved);
            var cached = require.cache[resolved];
            var res = cached ? cached.exports : mod();
            return res;
        };
        require.paths = [];
        require.modules = {};
        require.cache = {};
        require.extensions = [
            '.js',
            '.coffee',
            '.json'
        ];
        require._core = {
            'assert': true,
            'events': true,
            'fs': true,
            'path': true,
            'vm': true
        };
        require.resolve = function () {
            return function (x, cwd) {
                if (!cwd)
                    cwd = '/';
                if (require._core[x])
                    return x;
                var path = require.modules.path();
                cwd = path.resolve('/', cwd);
                var y = cwd || '/';
                if (x.match(/^(?:\.\.?\/|\/)/)) {
                    var m = loadAsFileSync(path.resolve(y, x)) || loadAsDirectorySync(path.resolve(y, x));
                    if (m)
                        return m;
                }
                var n = loadNodeModulesSync(x, y);
                if (n)
                    return n;
                throw new Error('Cannot find module \'' + x + '\'');
                function loadAsFileSync(x) {
                    x = path.normalize(x);
                    if (require.modules[x]) {
                        return x;
                    }
                    for (var i = 0; i < require.extensions.length; i++) {
                        var ext = require.extensions[i];
                        if (require.modules[x + ext])
                            return x + ext;
                    }
                }
                function loadAsDirectorySync(x) {
                    x = x.replace(/\/+$/, '');
                    var pkgfile = path.normalize(x + '/package.json');
                    if (require.modules[pkgfile]) {
                        var pkg = require.modules[pkgfile]();
                        var b = pkg.browserify;
                        if (typeof b === 'object' && b.main) {
                            var m = loadAsFileSync(path.resolve(x, b.main));
                            if (m)
                                return m;
                        } else if (typeof b === 'string') {
                            var m = loadAsFileSync(path.resolve(x, b));
                            if (m)
                                return m;
                        } else if (pkg.main) {
                            var m = loadAsFileSync(path.resolve(x, pkg.main));
                            if (m)
                                return m;
                        }
                    }
                    return loadAsFileSync(x + '/index');
                }
                function loadNodeModulesSync(x, start) {
                    var dirs = nodeModulesPathsSync(start);
                    for (var i = 0; i < dirs.length; i++) {
                        var dir = dirs[i];
                        var m = loadAsFileSync(dir + '/' + x);
                        if (m)
                            return m;
                        var n = loadAsDirectorySync(dir + '/' + x);
                        if (n)
                            return n;
                    }
                    var m = loadAsFileSync(x);
                    if (m)
                        return m;
                }
                function nodeModulesPathsSync(start) {
                    var parts;
                    if (start === '/')
                        parts = [''];
                    else
                        parts = path.normalize(start).split('/');
                    var dirs = [];
                    for (var i = parts.length - 1; i >= 0; i--) {
                        if (parts[i] === 'node_modules')
                            continue;
                        var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                        dirs.push(dir);
                    }
                    return dirs;
                }
            };
        }();
        require.alias = function (from, to) {
            var path = require.modules.path();
            var res = null;
            try {
                res = require.resolve(from + '/package.json', '/');
            } catch (err) {
                res = require.resolve(from, '/');
            }
            var basedir = path.dirname(res);
            var keys = (Object.keys || function (obj) {
                    var res = [];
                    for (var key in obj)
                        res.push(key);
                    return res;
                })(require.modules);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key.slice(0, basedir.length + 1) === basedir + '/') {
                    var f = key.slice(basedir.length);
                    require.modules[to + f] = require.modules[basedir + f];
                } else if (key === basedir) {
                    require.modules[to] = require.modules[basedir];
                }
            }
        };
        (function () {
            var process = {};
            var global = typeof window !== 'undefined' ? window : {};
            var definedProcess = false;
            require.define = function (filename, fn) {
                if (!definedProcess && require.modules.__browserify_process) {
                    process = require.modules.__browserify_process();
                    definedProcess = true;
                }
                var dirname = require._core[filename] ? '' : require.modules.path().dirname(filename);
                var require_ = function (file) {
                    var requiredModule = require(file, dirname);
                    var cached = require.cache[require.resolve(file, dirname)];
                    if (cached && cached.parent === null) {
                        cached.parent = module_;
                    }
                    return requiredModule;
                };
                require_.resolve = function (name) {
                    return require.resolve(name, dirname);
                };
                require_.modules = require.modules;
                require_.define = require.define;
                require_.cache = require.cache;
                var module_ = {
                        id: filename,
                        filename: filename,
                        exports: {},
                        loaded: false,
                        parent: null
                    };
                require.modules[filename] = function () {
                    require.cache[filename] = module_;
                    fn.call(module_.exports, require_, module_, module_.exports, dirname, filename, process, global);
                    module_.loaded = true;
                    return module_.exports;
                };
            };
        }());
        require.define('path', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            function filter(xs, fn) {
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    if (fn(xs[i], i, xs))
                        res.push(xs[i]);
                }
                return res;
            }
            function normalizeArray(parts, allowAboveRoot) {
                var up = 0;
                for (var i = parts.length; i >= 0; i--) {
                    var last = parts[i];
                    if (last == '.') {
                        parts.splice(i, 1);
                    } else if (last === '..') {
                        parts.splice(i, 1);
                        up++;
                    } else if (up) {
                        parts.splice(i, 1);
                        up--;
                    }
                }
                if (allowAboveRoot) {
                    for (; up--; up) {
                        parts.unshift('..');
                    }
                }
                return parts;
            }
            var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
            exports.resolve = function () {
                var resolvedPath = '', resolvedAbsolute = false;
                for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : process.cwd();
                    if (typeof path !== 'string' || !path) {
                        continue;
                    }
                    resolvedPath = path + '/' + resolvedPath;
                    resolvedAbsolute = path.charAt(0) === '/';
                }
                resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
                    return !!p;
                }), !resolvedAbsolute).join('/');
                return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
            };
            exports.normalize = function (path) {
                var isAbsolute = path.charAt(0) === '/', trailingSlash = path.slice(-1) === '/';
                path = normalizeArray(filter(path.split('/'), function (p) {
                    return !!p;
                }), !isAbsolute).join('/');
                if (!path && !isAbsolute) {
                    path = '.';
                }
                if (path && trailingSlash) {
                    path += '/';
                }
                return (isAbsolute ? '/' : '') + path;
            };
            exports.join = function () {
                var paths = Array.prototype.slice.call(arguments, 0);
                return exports.normalize(filter(paths, function (p, index) {
                    return p && typeof p === 'string';
                }).join('/'));
            };
            exports.dirname = function (path) {
                var dir = splitPathRe.exec(path)[1] || '';
                var isWindows = false;
                if (!dir) {
                    return '.';
                } else if (dir.length === 1 || isWindows && dir.length <= 3 && dir.charAt(1) === ':') {
                    return dir;
                } else {
                    return dir.substring(0, dir.length - 1);
                }
            };
            exports.basename = function (path, ext) {
                var f = splitPathRe.exec(path)[2] || '';
                if (ext && f.substr(-1 * ext.length) === ext) {
                    f = f.substr(0, f.length - ext.length);
                }
                return f;
            };
            exports.extname = function (path) {
                return splitPathRe.exec(path)[3] || '';
            };
            exports.relative = function (from, to) {
                from = exports.resolve(from).substr(1);
                to = exports.resolve(to).substr(1);
                function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== '')
                            break;
                    }
                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== '')
                            break;
                    }
                    if (start > end)
                        return [];
                    return arr.slice(start, end - start + 1);
                }
                var fromParts = trim(from.split('/'));
                var toParts = trim(to.split('/'));
                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }
                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                    outputParts.push('..');
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join('/');
            };
            return exports;
        });
        require.define('__browserify_process', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            var process = module.exports = {};
            process.nextTick = function () {
                var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
                var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;
                if (canSetImmediate) {
                    return function (f) {
                        return window.setImmediate(f);
                    };
                }
                if (canPost) {
                    var queue = [];
                    window.addEventListener('message', function (ev) {
                        if (ev.source === window && ev.data === 'browserify-tick') {
                            ev.stopPropagation();
                            if (queue.length > 0) {
                                var fn = queue.shift();
                                fn();
                            }
                        }
                    }, true);
                    return function nextTick(fn) {
                        queue.push(fn);
                        window.postMessage('browserify-tick', '*');
                    };
                }
                return function nextTick(fn) {
                    setTimeout(fn, 0);
                };
            }();
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.binding = function (name) {
                if (name === 'evals')
                    return vm;
                else
                    throw new Error('No such module. (Possibly not yet loaded)');
            };
            (function () {
                var cwd = '/';
                var path;
                process.cwd = function () {
                    return cwd;
                };
                process.chdir = function (dir) {
                    if (!path)
                        path = path;
                    cwd = path.resolve(dir, cwd);
                };
            }());
            return exports;
        });
        require.define('/package.json', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            module.exports = { 'main': 'escodegen.js' };
            return exports;
        });
        require.define('/escodegen.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            (function () {
                
                var Syntax, Precedence, BinaryPrecedence, Regex, VisitorKeys, VisitorOption, SourceNode, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, traverse;
                traverse = estraverse.traverse;
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    ArrayPattern: 'ArrayPattern',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ComprehensionBlock: 'ComprehensionBlock',
                    ComprehensionExpression: 'ComprehensionExpression',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    ObjectPattern: 'ObjectPattern',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement',
                    YieldExpression: 'YieldExpression'
                };
                Precedence = {
                    Sequence: 0,
                    Assignment: 1,
                    Conditional: 2,
                    LogicalOR: 3,
                    LogicalAND: 4,
                    BitwiseOR: 5,
                    BitwiseXOR: 6,
                    BitwiseAND: 7,
                    Equality: 8,
                    Relational: 9,
                    BitwiseSHIFT: 10,
                    Additive: 11,
                    Multiplicative: 12,
                    Unary: 13,
                    Postfix: 14,
                    Call: 15,
                    New: 16,
                    Member: 17,
                    Primary: 18
                };
                BinaryPrecedence = {
                    '||': Precedence.LogicalOR,
                    '&&': Precedence.LogicalAND,
                    '|': Precedence.BitwiseOR,
                    '^': Precedence.BitwiseXOR,
                    '&': Precedence.BitwiseAND,
                    '==': Precedence.Equality,
                    '!=': Precedence.Equality,
                    '===': Precedence.Equality,
                    '!==': Precedence.Equality,
                    'is': Precedence.Equality,
                    'isnt': Precedence.Equality,
                    '<': Precedence.Relational,
                    '>': Precedence.Relational,
                    '<=': Precedence.Relational,
                    '>=': Precedence.Relational,
                    'in': Precedence.Relational,
                    'instanceof': Precedence.Relational,
                    '<<': Precedence.BitwiseSHIFT,
                    '>>': Precedence.BitwiseSHIFT,
                    '>>>': Precedence.BitwiseSHIFT,
                    '+': Precedence.Additive,
                    '-': Precedence.Additive,
                    '*': Precedence.Multiplicative,
                    '%': Precedence.Multiplicative,
                    '/': Precedence.Multiplicative
                };
                Regex = { NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]') };
                function getDefaultOptions() {
                    return {
                        indent: null,
                        base: null,
                        parse: null,
                        comment: false,
                        format: {
                            indent: {
                                style: '    ',
                                base: 0,
                                adjustMultilineComment: false
                            },
                            json: false,
                            renumber: false,
                            hexadecimal: false,
                            quotes: 'single',
                            escapeless: false,
                            compact: false,
                            parentheses: true,
                            semicolons: true,
                            safeConcatenation: false
                        },
                        moz: {
                            starlessGenerator: false,
                            parenthesizedComprehensionBlock: false
                        },
                        sourceMap: null,
                        sourceMapRoot: null,
                        sourceMapWithCode: false,
                        directive: false,
                        verbatim: null
                    };
                }
                function stringToArray(str) {
                    var length = str.length, result = [], i;
                    for (i = 0; i < length; i += 1) {
                        result[i] = str.charAt(i);
                    }
                    return result;
                }
                function stringRepeat(str, num) {
                    var result = '';
                    for (num |= 0; num > 0; num >>>= 1, str += str) {
                        if (num & 1) {
                            result += str;
                        }
                    }
                    return result;
                }
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                function SourceNodeMock(line, column, filename, chunk) {
                    var result = [];
                    function flatten(input) {
                        var i, iz;
                        if (isArray(input)) {
                            for (i = 0, iz = input.length; i < iz; ++i) {
                                flatten(input[i]);
                            }
                        } else if (input instanceof SourceNodeMock) {
                            result.push(input);
                        } else if (typeof input === 'string' && input) {
                            result.push(input);
                        }
                    }
                    flatten(chunk);
                    this.children = result;
                }
                SourceNodeMock.prototype.toString = function toString() {
                    var res = '', i, iz, node;
                    for (i = 0, iz = this.children.length; i < iz; ++i) {
                        node = this.children[i];
                        if (node instanceof SourceNodeMock) {
                            res += node.toString();
                        } else {
                            res += node;
                        }
                    }
                    return res;
                };
                SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {
                    var last = this.children[this.children.length - 1];
                    if (last instanceof SourceNodeMock) {
                        last.replaceRight(pattern, replacement);
                    } else if (typeof last === 'string') {
                        this.children[this.children.length - 1] = last.replace(pattern, replacement);
                    } else {
                        this.children.push(''.replace(pattern, replacement));
                    }
                    return this;
                };
                SourceNodeMock.prototype.join = function join(sep) {
                    var i, iz, result;
                    result = [];
                    iz = this.children.length;
                    if (iz > 0) {
                        for (i = 0, iz -= 1; i < iz; ++i) {
                            result.push(this.children[i], sep);
                        }
                        result.push(this.children[iz]);
                        this.children = result;
                    }
                    return this;
                };
                function hasLineTerminator(str) {
                    return /[\r\n]/g.test(str);
                }
                function endsWithLineTerminator(str) {
                    var ch = str.charAt(str.length - 1);
                    return ch === '\r' || ch === '\n';
                }
                function shallowCopy(obj) {
                    var ret = {}, key;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            ret[key] = obj[key];
                        }
                    }
                    return ret;
                }
                function deepCopy(obj) {
                    var ret = {}, key, val;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            val = obj[key];
                            if (typeof val === 'object' && val !== null) {
                                ret[key] = deepCopy(val);
                            } else {
                                ret[key] = val;
                            }
                        }
                    }
                    return ret;
                }
                function updateDeeply(target, override) {
                    var key, val;
                    function isHashObject(target) {
                        return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
                    }
                    for (key in override) {
                        if (override.hasOwnProperty(key)) {
                            val = override[key];
                            if (isHashObject(val)) {
                                if (isHashObject(target[key])) {
                                    updateDeeply(target[key], val);
                                } else {
                                    target[key] = updateDeeply({}, val);
                                }
                            } else {
                                target[key] = val;
                            }
                        }
                    }
                    return target;
                }
                function generateNumber(value) {
                    var result, point, temp, exponent, pos;
                    if (value !== value) {
                        throw new Error('Numeric literal whose value is NaN');
                    }
                    if (value < 0 || value === 0 && 1 / value < 0) {
                        throw new Error('Numeric literal whose value is negative');
                    }
                    if (value === 1 / 0) {
                        return json ? 'null' : renumber ? '1e400' : '1e+400';
                    }
                    result = '' + value;
                    if (!renumber || result.length < 3) {
                        return result;
                    }
                    point = result.indexOf('.');
                    if (!json && result.charAt(0) === '0' && point === 1) {
                        point = 0;
                        result = result.slice(1);
                    }
                    temp = result;
                    result = result.replace('e+', 'e');
                    exponent = 0;
                    if ((pos = temp.indexOf('e')) > 0) {
                        exponent = +temp.slice(pos + 1);
                        temp = temp.slice(0, pos);
                    }
                    if (point >= 0) {
                        exponent -= temp.length - point - 1;
                        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
                    }
                    pos = 0;
                    while (temp.charAt(temp.length + pos - 1) === '0') {
                        pos -= 1;
                    }
                    if (pos !== 0) {
                        exponent -= pos;
                        temp = temp.slice(0, pos);
                    }
                    if (exponent !== 0) {
                        temp += 'e' + exponent;
                    }
                    if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
                        result = temp;
                    }
                    return result;
                }
                function escapeAllowedCharacter(ch, next) {
                    var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';
                    switch (ch) {
                    case '\b':
                        result += 'b';
                        break;
                    case '\f':
                        result += 'f';
                        break;
                    case '\t':
                        result += 't';
                        break;
                    default:
                        if (json || code > 255) {
                            result += 'u' + '0000'.slice(hex.length) + hex;
                        } else if (ch === '\0' && '0123456789'.indexOf(next) < 0) {
                            result += '0';
                        } else if (ch === '\x0B') {
                            result += 'v';
                        } else {
                            result += 'x' + '00'.slice(hex.length) + hex;
                        }
                        break;
                    }
                    return result;
                }
                function escapeDisallowedCharacter(ch) {
                    var result = '\\';
                    switch (ch) {
                    case '\\':
                        result += '\\';
                        break;
                    case '\n':
                        result += 'n';
                        break;
                    case '\r':
                        result += 'r';
                        break;
                    case '\u2028':
                        result += 'u2028';
                        break;
                    case '\u2029':
                        result += 'u2029';
                        break;
                    default:
                        throw new Error('Incorrectly classified character');
                    }
                    return result;
                }
                function escapeDirective(str) {
                    var i, iz, ch, single, buf, quote;
                    buf = str;
                    if (typeof buf[0] === 'undefined') {
                        buf = stringToArray(buf);
                    }
                    quote = quotes === 'double' ? '"' : '\'';
                    for (i = 0, iz = buf.length; i < iz; i += 1) {
                        ch = buf[i];
                        if (ch === '\'') {
                            quote = '"';
                            break;
                        } else if (ch === '"') {
                            quote = '\'';
                            break;
                        } else if (ch === '\\') {
                            i += 1;
                        }
                    }
                    return quote + str + quote;
                }
                function escapeString(str) {
                    var result = '', i, len, ch, next, singleQuotes = 0, doubleQuotes = 0, single;
                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }
                    for (i = 0, len = str.length; i < len; i += 1) {
                        ch = str[i];
                        if (ch === '\'') {
                            singleQuotes += 1;
                        } else if (ch === '"') {
                            doubleQuotes += 1;
                        } else if (ch === '/' && json) {
                            result += '\\';
                        } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
                            result += escapeDisallowedCharacter(ch);
                            continue;
                        } else if (json && ch < ' ' || !(json || escapeless || ch >= ' ' && ch <= '~')) {
                            result += escapeAllowedCharacter(ch, str[i + 1]);
                            continue;
                        }
                        result += ch;
                    }
                    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
                    str = result;
                    result = single ? '\'' : '"';
                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }
                    for (i = 0, len = str.length; i < len; i += 1) {
                        ch = str[i];
                        if (ch === '\'' && single || ch === '"' && !single) {
                            result += '\\';
                        }
                        result += ch;
                    }
                    return result + (single ? '\'' : '"');
                }
                function isWhiteSpace(ch) {
                    return '\t\x0B\f \xa0'.indexOf(ch) >= 0 || ch.charCodeAt(0) >= 5760 && '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\ufeff'.indexOf(ch) >= 0;
                }
                function isLineTerminator(ch) {
                    return '\n\r\u2028\u2029'.indexOf(ch) >= 0;
                }
                function isIdentifierPart(ch) {
                    return ch === '$' || ch === '_' || ch === '\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierPart.test(ch);
                }
                function toSourceNode(generated, node) {
                    if (node == null) {
                        if (generated instanceof SourceNode) {
                            return generated;
                        } else {
                            node = {};
                        }
                    }
                    if (node.loc == null) {
                        return new SourceNode(null, null, sourceMap, generated);
                    }
                    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated);
                }
                function join(left, right) {
                    var leftSource = toSourceNode(left).toString(), rightSource = toSourceNode(right).toString(), leftChar = leftSource.charAt(leftSource.length - 1), rightChar = rightSource.charAt(0);
                    if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {
                        return [
                            left,
                            ' ',
                            right
                        ];
                    } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {
                        return [
                            left,
                            right
                        ];
                    }
                    return [
                        left,
                        space,
                        right
                    ];
                }
                function addIndent(stmt) {
                    return [
                        base,
                        stmt
                    ];
                }
                function withIndent(fn) {
                    var previousBase, result;
                    previousBase = base;
                    base += indent;
                    result = fn.call(this, base);
                    base = previousBase;
                    return result;
                }
                function calculateSpaces(str) {
                    var i;
                    for (i = str.length - 1; i >= 0; i -= 1) {
                        if (isLineTerminator(str.charAt(i))) {
                            break;
                        }
                    }
                    return str.length - 1 - i;
                }
                function adjustMultilineComment(value, specialBase) {
                    var array, i, len, line, j, ch, spaces, previousBase;
                    array = value.split(/\r\n|[\r\n]/);
                    spaces = Number.MAX_VALUE;
                    for (i = 1, len = array.length; i < len; i += 1) {
                        line = array[i];
                        j = 0;
                        while (j < line.length && isWhiteSpace(line[j])) {
                            j += 1;
                        }
                        if (spaces > j) {
                            spaces = j;
                        }
                    }
                    if (typeof specialBase !== 'undefined') {
                        previousBase = base;
                        if (array[1][spaces] === '*') {
                            specialBase += ' ';
                        }
                        base = specialBase;
                    } else {
                        if (spaces & 1) {
                            spaces -= 1;
                        }
                        previousBase = base;
                    }
                    for (i = 1, len = array.length; i < len; i += 1) {
                        array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');
                    }
                    base = previousBase;
                    return array.join('\n');
                }
                function generateComment(comment, specialBase) {
                    if (comment.type === 'Line') {
                        if (endsWithLineTerminator(comment.value)) {
                            return '//' + comment.value;
                        } else {
                            return '//' + comment.value + '\n';
                        }
                    }
                    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
                        return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
                    }
                    return '/*' + comment.value + '*/';
                }
                function addCommentsToStatement(stmt, result) {
                    var i, len, comment, save, node, tailingToStatement, specialBase, fragment;
                    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
                        save = result;
                        comment = stmt.leadingComments[0];
                        result = [];
                        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                            result.push('\n');
                        }
                        result.push(generateComment(comment));
                        if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push('\n');
                        }
                        for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {
                            comment = stmt.leadingComments[i];
                            fragment = [generateComment(comment)];
                            if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                fragment.push('\n');
                            }
                            result.push(addIndent(fragment));
                        }
                        result.push(addIndent(save));
                    }
                    if (stmt.trailingComments) {
                        tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());
                        specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([
                            base,
                            result,
                            indent
                        ]).toString()));
                        for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {
                            comment = stmt.trailingComments[i];
                            if (tailingToStatement) {
                                if (i === 0) {
                                    result = [
                                        result,
                                        indent
                                    ];
                                } else {
                                    result = [
                                        result,
                                        specialBase
                                    ];
                                }
                                result.push(generateComment(comment, specialBase));
                            } else {
                                result = [
                                    result,
                                    addIndent(generateComment(comment))
                                ];
                            }
                            if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {
                                result = [
                                    result,
                                    '\n'
                                ];
                            }
                        }
                    }
                    return result;
                }
                function parenthesize(text, current, should) {
                    if (current < should) {
                        return [
                            '(',
                            text,
                            ')'
                        ];
                    }
                    return text;
                }
                function maybeBlock(stmt, semicolonOptional, functionBody) {
                    var result, noLeadingComment;
                    noLeadingComment = !extra.comment || !stmt.leadingComments;
                    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
                        return [
                            space,
                            generateStatement(stmt, { functionBody: functionBody })
                        ];
                    }
                    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
                        return ';';
                    }
                    withIndent(function () {
                        result = [
                            newline,
                            addIndent(generateStatement(stmt, {
                                semicolonOptional: semicolonOptional,
                                functionBody: functionBody
                            }))
                        ];
                    });
                    return result;
                }
                function maybeBlockSuffix(stmt, result) {
                    var ends = endsWithLineTerminator(toSourceNode(result).toString());
                    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
                        return [
                            result,
                            space
                        ];
                    }
                    if (ends) {
                        return [
                            result,
                            base
                        ];
                    }
                    return [
                        result,
                        newline,
                        base
                    ];
                }
                function generateVerbatim(expr, option) {
                    var i, result;
                    result = expr[extra.verbatim].split(/\r\n|\n/);
                    for (i = 1; i < result.length; i++) {
                        result[i] = newline + base + result[i];
                    }
                    result = parenthesize(result, Precedence.Sequence, option.precedence);
                    return toSourceNode(result, expr);
                }
                function generateFunctionBody(node) {
                    var result, i, len, expr;
                    result = ['('];
                    for (i = 0, len = node.params.length; i < len; i += 1) {
                        result.push(node.params[i].name);
                        if (i + 1 < len) {
                            result.push(',' + space);
                        }
                    }
                    result.push(')');
                    if (node.expression) {
                        result.push(space);
                        expr = generateExpression(node.body, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        });
                        if (expr.toString().charAt(0) === '{') {
                            expr = [
                                '(',
                                expr,
                                ')'
                            ];
                        }
                        result.push(expr);
                    } else {
                        result.push(maybeBlock(node.body, false, true));
                    }
                    return result;
                }
                function generateExpression(expr, option) {
                    var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftChar, leftSource, rightChar, rightSource, allowIn, allowCall, allowUnparenthesizedNew, property, key, value;
                    precedence = option.precedence;
                    allowIn = option.allowIn;
                    allowCall = option.allowCall;
                    type = expr.type || option.type;
                    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
                        return generateVerbatim(expr, option);
                    }
                    switch (type) {
                    case Syntax.SequenceExpression:
                        result = [];
                        allowIn |= Precedence.Sequence < precedence;
                        for (i = 0, len = expr.expressions.length; i < len; i += 1) {
                            result.push(generateExpression(expr.expressions[i], {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result = parenthesize(result, Precedence.Sequence, precedence);
                        break;
                    case Syntax.AssignmentExpression:
                        allowIn |= Precedence.Assignment < precedence;
                        result = parenthesize([
                            generateExpression(expr.left, {
                                precedence: Precedence.Call,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + expr.operator + space,
                            generateExpression(expr.right, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            })
                        ], Precedence.Assignment, precedence);
                        break;
                    case Syntax.ConditionalExpression:
                        allowIn |= Precedence.Conditional < precedence;
                        result = parenthesize([
                            generateExpression(expr.test, {
                                precedence: Precedence.LogicalOR,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + '?' + space,
                            generateExpression(expr.consequent, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + ':' + space,
                            generateExpression(expr.alternate, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            })
                        ], Precedence.Conditional, precedence);
                        break;
                    case Syntax.LogicalExpression:
                    case Syntax.BinaryExpression:
                        currentPrecedence = BinaryPrecedence[expr.operator];
                        allowIn |= currentPrecedence < precedence;
                        fragment = generateExpression(expr.left, {
                            precedence: currentPrecedence,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        leftSource = fragment.toString();
                        if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {
                            result = [
                                fragment,
                                ' ',
                                expr.operator
                            ];
                        } else {
                            result = join(fragment, expr.operator);
                        }
                        fragment = generateExpression(expr.right, {
                            precedence: currentPrecedence + 1,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        if (expr.operator === '/' && fragment.toString().charAt(0) === '/') {
                            result.push(' ', fragment);
                        } else {
                            result = join(result, fragment);
                        }
                        if (expr.operator === 'in' && !allowIn) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, currentPrecedence, precedence);
                        }
                        break;
                    case Syntax.CallExpression:
                        result = [generateExpression(expr.callee, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true,
                                allowUnparenthesizedNew: false
                            })];
                        result.push('(');
                        for (i = 0, len = expr['arguments'].length; i < len; i += 1) {
                            result.push(generateExpression(expr['arguments'][i], {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result.push(')');
                        if (!allowCall) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, Precedence.Call, precedence);
                        }
                        break;
                    case Syntax.NewExpression:
                        len = expr['arguments'].length;
                        allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;
                        result = join('new', generateExpression(expr.callee, {
                            precedence: Precedence.New,
                            allowIn: true,
                            allowCall: false,
                            allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                        }));
                        if (!allowUnparenthesizedNew || parentheses || len > 0) {
                            result.push('(');
                            for (i = 0; i < len; i += 1) {
                                result.push(generateExpression(expr['arguments'][i], {
                                    precedence: Precedence.Assignment,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + space);
                                }
                            }
                            result.push(')');
                        }
                        result = parenthesize(result, Precedence.New, precedence);
                        break;
                    case Syntax.MemberExpression:
                        result = [generateExpression(expr.object, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: allowCall,
                                allowUnparenthesizedNew: false
                            })];
                        if (expr.computed) {
                            result.push('[', generateExpression(expr.property, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: allowCall
                            }), ']');
                        } else {
                            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                                if (result.indexOf('.') < 0) {
                                    if (!/[eExX]/.test(result) && !(result.length >= 2 && result[0] === '0')) {
                                        result.push('.');
                                    }
                                }
                            }
                            result.push('.' + expr.property.name);
                        }
                        result = parenthesize(result, Precedence.Member, precedence);
                        break;
                    case Syntax.UnaryExpression:
                        fragment = generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        });
                        if (space === '') {
                            result = join(expr.operator, fragment);
                        } else {
                            result = [expr.operator];
                            if (expr.operator.length > 2) {
                                result = join(result, fragment);
                            } else {
                                leftSource = toSourceNode(result).toString();
                                leftChar = leftSource.charAt(leftSource.length - 1);
                                rightChar = fragment.toString().charAt(0);
                                if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {
                                    result.push(' ', fragment);
                                } else {
                                    result.push(fragment);
                                }
                            }
                        }
                        result = parenthesize(result, Precedence.Unary, precedence);
                        break;
                    case Syntax.YieldExpression:
                        if (expr.delegate) {
                            result = 'yield*';
                        } else {
                            result = 'yield';
                        }
                        if (expr.argument) {
                            result = join(result, generateExpression(expr.argument, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        break;
                    case Syntax.UpdateExpression:
                        if (expr.prefix) {
                            result = parenthesize([
                                expr.operator,
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Unary,
                                    allowIn: true,
                                    allowCall: true
                                })
                            ], Precedence.Unary, precedence);
                        } else {
                            result = parenthesize([
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Postfix,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                expr.operator
                            ], Precedence.Postfix, precedence);
                        }
                        break;
                    case Syntax.FunctionExpression:
                        result = 'function';
                        if (expr.id) {
                            result += ' ' + expr.id.name;
                        } else {
                            result += space;
                        }
                        result = [
                            result,
                            generateFunctionBody(expr)
                        ];
                        break;
                    case Syntax.ArrayPattern:
                    case Syntax.ArrayExpression:
                        if (!expr.elements.length) {
                            result = '[]';
                            break;
                        }
                        multiline = expr.elements.length > 1;
                        result = [
                            '[',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                                if (!expr.elements[i]) {
                                    if (multiline) {
                                        result.push(indent);
                                    }
                                    if (i + 1 === len) {
                                        result.push(',');
                                    }
                                } else {
                                    result.push(multiline ? indent : '', generateExpression(expr.elements[i], {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    }));
                                }
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '', ']');
                        break;
                    case Syntax.Property:
                        if (expr.kind === 'get' || expr.kind === 'set') {
                            result = [
                                expr.kind + ' ',
                                generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                generateFunctionBody(expr.value)
                            ];
                        } else {
                            if (expr.shorthand) {
                                result = generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                            } else if (expr.method) {
                                result = [];
                                if (expr.value.generator) {
                                    result.push('*');
                                }
                                result.push(generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), generateFunctionBody(expr.value));
                            } else {
                                result = [
                                    generateExpression(expr.key, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    }),
                                    ':' + space,
                                    generateExpression(expr.value, {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    })
                                ];
                            }
                        }
                        break;
                    case Syntax.ObjectExpression:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = expr.properties.length > 1;
                        withIndent(function (indent) {
                            fragment = generateExpression(expr.properties[0], {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true,
                                type: Syntax.Property
                            });
                        });
                        if (!multiline) {
                            if (!hasLineTerminator(toSourceNode(fragment).toString())) {
                                result = [
                                    '{',
                                    space,
                                    fragment,
                                    space,
                                    '}'
                                ];
                                break;
                            }
                        }
                        withIndent(function (indent) {
                            result = [
                                '{',
                                newline,
                                indent,
                                fragment
                            ];
                            if (multiline) {
                                result.push(',' + newline);
                                for (i = 1, len = expr.properties.length; i < len; i += 1) {
                                    result.push(indent, generateExpression(expr.properties[i], {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true,
                                        type: Syntax.Property
                                    }));
                                    if (i + 1 < len) {
                                        result.push(',' + newline);
                                    }
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base, '}');
                        break;
                    case Syntax.ObjectPattern:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = false;
                        if (expr.properties.length === 1) {
                            property = expr.properties[0];
                            if (property.value.type !== Syntax.Identifier) {
                                multiline = true;
                            }
                        } else {
                            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                                property = expr.properties[i];
                                if (!property.shorthand) {
                                    multiline = true;
                                    break;
                                }
                            }
                        }
                        result = [
                            '{',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                                result.push(multiline ? indent : '', generateExpression(expr.properties[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '', '}');
                        break;
                    case Syntax.ThisExpression:
                        result = 'this';
                        break;
                    case Syntax.Identifier:
                        result = expr.name;
                        break;
                    case Syntax.Literal:
                        if (expr.hasOwnProperty('raw') && parse) {
                            try {
                                raw = parse(expr.raw).body[0].expression;
                                if (raw.type === Syntax.Literal) {
                                    if (raw.value === expr.value) {
                                        result = expr.raw;
                                        break;
                                    }
                                }
                            } catch (e) {
                            }
                        }
                        if (expr.value === null) {
                            result = 'null';
                            break;
                        }
                        if (typeof expr.value === 'string') {
                            result = escapeString(expr.value);
                            break;
                        }
                        if (typeof expr.value === 'number') {
                            result = generateNumber(expr.value);
                            break;
                        }
                        result = expr.value.toString();
                        break;
                    case Syntax.ComprehensionExpression:
                        result = [
                            '[',
                            generateExpression(expr.body, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            })
                        ];
                        if (expr.blocks) {
                            for (i = 0, len = expr.blocks.length; i < len; i += 1) {
                                fragment = generateExpression(expr.blocks[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                                result = join(result, fragment);
                            }
                        }
                        if (expr.filter) {
                            result = join(result, 'if' + space);
                            fragment = generateExpression(expr.filter, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            });
                            if (extra.moz.parenthesizedComprehensionBlock) {
                                result = join(result, [
                                    '(',
                                    fragment,
                                    ')'
                                ]);
                            } else {
                                result = join(result, fragment);
                            }
                        }
                        result.push(']');
                        break;
                    case Syntax.ComprehensionBlock:
                        if (expr.left.type === Syntax.VariableDeclaration) {
                            fragment = [
                                expr.left.kind + ' ',
                                generateStatement(expr.left.declarations[0], { allowIn: false })
                            ];
                        } else {
                            fragment = generateExpression(expr.left, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true
                            });
                        }
                        fragment = join(fragment, expr.of ? 'of' : 'in');
                        fragment = join(fragment, generateExpression(expr.right, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }));
                        if (extra.moz.parenthesizedComprehensionBlock) {
                            result = [
                                'for' + space + '(',
                                fragment,
                                ')'
                            ];
                        } else {
                            result = join('for' + space, fragment);
                        }
                        break;
                    default:
                        throw new Error('Unknown expression type: ' + expr.type);
                    }
                    return toSourceNode(result, expr);
                }
                function generateStatement(stmt, option) {
                    var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;
                    allowIn = true;
                    semicolon = ';';
                    functionBody = false;
                    directiveContext = false;
                    if (option) {
                        allowIn = option.allowIn === undefined || option.allowIn;
                        if (!semicolons && option.semicolonOptional === true) {
                            semicolon = '';
                        }
                        functionBody = option.functionBody;
                        directiveContext = option.directiveContext;
                    }
                    switch (stmt.type) {
                    case Syntax.BlockStatement:
                        result = [
                            '{',
                            newline
                        ];
                        withIndent(function () {
                            for (i = 0, len = stmt.body.length; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.body[i], {
                                    semicolonOptional: i === len - 1,
                                    directiveContext: functionBody
                                }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        result.push(addIndent('}'));
                        break;
                    case Syntax.BreakStatement:
                        if (stmt.label) {
                            result = 'break ' + stmt.label.name + semicolon;
                        } else {
                            result = 'break' + semicolon;
                        }
                        break;
                    case Syntax.ContinueStatement:
                        if (stmt.label) {
                            result = 'continue ' + stmt.label.name + semicolon;
                        } else {
                            result = 'continue' + semicolon;
                        }
                        break;
                    case Syntax.DirectiveStatement:
                        if (stmt.raw) {
                            result = stmt.raw + semicolon;
                        } else {
                            result = escapeDirective(stmt.directive) + semicolon;
                        }
                        break;
                    case Syntax.DoWhileStatement:
                        result = join('do', maybeBlock(stmt.body));
                        result = maybeBlockSuffix(stmt.body, result);
                        result = join(result, [
                            'while' + space + '(',
                            generateExpression(stmt.test, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            }),
                            ')' + semicolon
                        ]);
                        break;
                    case Syntax.CatchClause:
                        withIndent(function () {
                            result = [
                                'catch' + space + '(',
                                generateExpression(stmt.param, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body));
                        break;
                    case Syntax.DebuggerStatement:
                        result = 'debugger' + semicolon;
                        break;
                    case Syntax.EmptyStatement:
                        result = ';';
                        break;
                    case Syntax.ExpressionStatement:
                        result = [generateExpression(stmt.expression, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })];
                        if (result.toString().charAt(0) === '{' || result.toString().slice(0, 8) === 'function' && ' ('.indexOf(result.toString().charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
                            result = [
                                '(',
                                result,
                                ')' + semicolon
                            ];
                        } else {
                            result.push(semicolon);
                        }
                        break;
                    case Syntax.VariableDeclarator:
                        if (stmt.init) {
                            result = [
                                generateExpression(stmt.id, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                }) + space + '=' + space,
                                generateExpression(stmt.init, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                })
                            ];
                        } else {
                            result = stmt.id.name;
                        }
                        break;
                    case Syntax.VariableDeclaration:
                        result = [stmt.kind];
                        if (stmt.declarations.length === 1 && stmt.declarations[0].init && stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                            result.push(' ', generateStatement(stmt.declarations[0], { allowIn: allowIn }));
                        } else {
                            withIndent(function () {
                                node = stmt.declarations[0];
                                if (extra.comment && node.leadingComments) {
                                    result.push('\n', addIndent(generateStatement(node, { allowIn: allowIn })));
                                } else {
                                    result.push(' ', generateStatement(node, { allowIn: allowIn }));
                                }
                                for (i = 1, len = stmt.declarations.length; i < len; i += 1) {
                                    node = stmt.declarations[i];
                                    if (extra.comment && node.leadingComments) {
                                        result.push(',' + newline, addIndent(generateStatement(node, { allowIn: allowIn })));
                                    } else {
                                        result.push(',' + space, generateStatement(node, { allowIn: allowIn }));
                                    }
                                }
                            });
                        }
                        result.push(semicolon);
                        break;
                    case Syntax.ThrowStatement:
                        result = [
                            join('throw', generateExpression(stmt.argument, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })),
                            semicolon
                        ];
                        break;
                    case Syntax.TryStatement:
                        result = [
                            'try',
                            maybeBlock(stmt.block)
                        ];
                        result = maybeBlockSuffix(stmt.block, result);
                        for (i = 0, len = stmt.handlers.length; i < len; i += 1) {
                            result = join(result, generateStatement(stmt.handlers[i]));
                            if (stmt.finalizer || i + 1 !== len) {
                                result = maybeBlockSuffix(stmt.handlers[i].body, result);
                            }
                        }
                        if (stmt.finalizer) {
                            result = join(result, [
                                'finally',
                                maybeBlock(stmt.finalizer)
                            ]);
                        }
                        break;
                    case Syntax.SwitchStatement:
                        withIndent(function () {
                            result = [
                                'switch' + space + '(',
                                generateExpression(stmt.discriminant, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')' + space + '{' + newline
                            ];
                        });
                        if (stmt.cases) {
                            for (i = 0, len = stmt.cases.length; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.cases[i], { semicolonOptional: i === len - 1 }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        }
                        result.push(addIndent('}'));
                        break;
                    case Syntax.SwitchCase:
                        withIndent(function () {
                            if (stmt.test) {
                                result = [
                                    join('case', generateExpression(stmt.test, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    })),
                                    ':'
                                ];
                            } else {
                                result = ['default:'];
                            }
                            i = 0;
                            len = stmt.consequent.length;
                            if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                                fragment = maybeBlock(stmt.consequent[0]);
                                result.push(fragment);
                                i = 1;
                            }
                            if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {
                                result.push(newline);
                            }
                            for (; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.consequent[i], { semicolonOptional: i === len - 1 && semicolon === '' }));
                                result.push(fragment);
                                if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        break;
                    case Syntax.IfStatement:
                        withIndent(function () {
                            result = [
                                'if' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        if (stmt.alternate) {
                            result.push(maybeBlock(stmt.consequent));
                            result = maybeBlockSuffix(stmt.consequent, result);
                            if (stmt.alternate.type === Syntax.IfStatement) {
                                result = join(result, [
                                    'else ',
                                    generateStatement(stmt.alternate, { semicolonOptional: semicolon === '' })
                                ]);
                            } else {
                                result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                            }
                        } else {
                            result.push(maybeBlock(stmt.consequent, semicolon === ''));
                        }
                        break;
                    case Syntax.ForStatement:
                        withIndent(function () {
                            result = ['for' + space + '('];
                            if (stmt.init) {
                                if (stmt.init.type === Syntax.VariableDeclaration) {
                                    result.push(generateStatement(stmt.init, { allowIn: false }));
                                } else {
                                    result.push(generateExpression(stmt.init, {
                                        precedence: Precedence.Sequence,
                                        allowIn: false,
                                        allowCall: true
                                    }), ';');
                                }
                            } else {
                                result.push(';');
                            }
                            if (stmt.test) {
                                result.push(space, generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), ';');
                            } else {
                                result.push(';');
                            }
                            if (stmt.update) {
                                result.push(space, generateExpression(stmt.update, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), ')');
                            } else {
                                result.push(')');
                            }
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.ForInStatement:
                        result = ['for' + space + '('];
                        withIndent(function () {
                            if (stmt.left.type === Syntax.VariableDeclaration) {
                                withIndent(function () {
                                    result.push(stmt.left.kind + ' ', generateStatement(stmt.left.declarations[0], { allowIn: false }));
                                });
                            } else {
                                result.push(generateExpression(stmt.left, {
                                    precedence: Precedence.Call,
                                    allowIn: true,
                                    allowCall: true
                                }));
                            }
                            result = join(result, 'in');
                            result = [
                                join(result, generateExpression(stmt.right, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.LabeledStatement:
                        result = [
                            stmt.label.name + ':',
                            maybeBlock(stmt.body, semicolon === '')
                        ];
                        break;
                    case Syntax.Program:
                        len = stmt.body.length;
                        result = [safeConcatenation && len > 0 ? '\n' : ''];
                        for (i = 0; i < len; i += 1) {
                            fragment = addIndent(generateStatement(stmt.body[i], {
                                semicolonOptional: !safeConcatenation && i === len - 1,
                                directiveContext: true
                            }));
                            result.push(fragment);
                            if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                result.push(newline);
                            }
                        }
                        break;
                    case Syntax.FunctionDeclaration:
                        result = [
                            (stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function ') + stmt.id.name,
                            generateFunctionBody(stmt)
                        ];
                        break;
                    case Syntax.ReturnStatement:
                        if (stmt.argument) {
                            result = [
                                join('return', generateExpression(stmt.argument, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                semicolon
                            ];
                        } else {
                            result = ['return' + semicolon];
                        }
                        break;
                    case Syntax.WhileStatement:
                        withIndent(function () {
                            result = [
                                'while' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.WithStatement:
                        withIndent(function () {
                            result = [
                                'with' + space + '(',
                                generateExpression(stmt.object, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    default:
                        throw new Error('Unknown statement type: ' + stmt.type);
                    }
                    if (extra.comment) {
                        result = addCommentsToStatement(stmt, result);
                    }
                    fragment = toSourceNode(result).toString();
                    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
                        result = toSourceNode(result).replaceRight(/\s+$/, '');
                    }
                    return toSourceNode(result, stmt);
                }
                function generate(node, options) {
                    var defaultOptions = getDefaultOptions(), result, pair;
                    if (options != null) {
                        if (typeof options.indent === 'string') {
                            defaultOptions.format.indent.style = options.indent;
                        }
                        if (typeof options.base === 'number') {
                            defaultOptions.format.indent.base = options.base;
                        }
                        options = updateDeeply(defaultOptions, options);
                        indent = options.format.indent.style;
                        if (typeof options.base === 'string') {
                            base = options.base;
                        } else {
                            base = stringRepeat(indent, options.format.indent.base);
                        }
                    } else {
                        options = defaultOptions;
                        indent = options.format.indent.style;
                        base = stringRepeat(indent, options.format.indent.base);
                    }
                    json = options.format.json;
                    renumber = options.format.renumber;
                    hexadecimal = json ? false : options.format.hexadecimal;
                    quotes = json ? 'double' : options.format.quotes;
                    escapeless = options.format.escapeless;
                    if (options.format.compact) {
                        newline = space = indent = base = '';
                    } else {
                        newline = '\n';
                        space = ' ';
                    }
                    parentheses = options.format.parentheses;
                    semicolons = options.format.semicolons;
                    safeConcatenation = options.format.safeConcatenation;
                    directive = options.directive;
                    parse = json ? null : options.parse;
                    sourceMap = options.sourceMap;
                    extra = options;
                    if (sourceMap) {
                        if (!exports.browser) {
                            SourceNode = source_map.SourceNode;
                        } else {
                            SourceNode = global.sourceMap.SourceNode;
                        }
                    } else {
                        SourceNode = SourceNodeMock;
                    }
                    switch (node.type) {
                    case Syntax.BlockStatement:
                    case Syntax.BreakStatement:
                    case Syntax.CatchClause:
                    case Syntax.ContinueStatement:
                    case Syntax.DirectiveStatement:
                    case Syntax.DoWhileStatement:
                    case Syntax.DebuggerStatement:
                    case Syntax.EmptyStatement:
                    case Syntax.ExpressionStatement:
                    case Syntax.ForStatement:
                    case Syntax.ForInStatement:
                    case Syntax.FunctionDeclaration:
                    case Syntax.IfStatement:
                    case Syntax.LabeledStatement:
                    case Syntax.Program:
                    case Syntax.ReturnStatement:
                    case Syntax.SwitchStatement:
                    case Syntax.SwitchCase:
                    case Syntax.ThrowStatement:
                    case Syntax.TryStatement:
                    case Syntax.VariableDeclaration:
                    case Syntax.VariableDeclarator:
                    case Syntax.WhileStatement:
                    case Syntax.WithStatement:
                        result = generateStatement(node);
                        break;
                    case Syntax.AssignmentExpression:
                    case Syntax.ArrayExpression:
                    case Syntax.ArrayPattern:
                    case Syntax.BinaryExpression:
                    case Syntax.CallExpression:
                    case Syntax.ConditionalExpression:
                    case Syntax.FunctionExpression:
                    case Syntax.Identifier:
                    case Syntax.Literal:
                    case Syntax.LogicalExpression:
                    case Syntax.MemberExpression:
                    case Syntax.NewExpression:
                    case Syntax.ObjectExpression:
                    case Syntax.ObjectPattern:
                    case Syntax.Property:
                    case Syntax.SequenceExpression:
                    case Syntax.ThisExpression:
                    case Syntax.UnaryExpression:
                    case Syntax.UpdateExpression:
                    case Syntax.YieldExpression:
                        result = generateExpression(node, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });
                        break;
                    default:
                        throw new Error('Unknown node type: ' + node.type);
                    }
                    if (!sourceMap) {
                        return result.toString();
                    }
                    pair = result.toStringWithSourceMap({
                        file: options.sourceMap,
                        sourceRoot: options.sourceMapRoot
                    });
                    if (options.sourceMapWithCode) {
                        return pair;
                    }
                    return pair.map.toString();
                }
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    ArrayPattern: ['elements'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    DebuggerStatement: [],
                    EmptyStatement: [],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    ObjectPattern: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ],
                    YieldExpression: ['argument']
                };
                VisitorOption = {
                    Break: 1,
                    Skip: 2
                };
                function upperBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            len = diff;
                        } else {
                            i = current + 1;
                            len -= diff + 1;
                        }
                    }
                    return i;
                }
                function lowerBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            i = current + 1;
                            len -= diff + 1;
                        } else {
                            len = diff;
                        }
                    }
                    return i;
                }
                function extendCommentRange(comment, tokens) {
                    var target, token;
                    target = upperBound(tokens, function search(token) {
                        return token.range[0] > comment.range[0];
                    });
                    comment.extendedRange = [
                        comment.range[0],
                        comment.range[1]
                    ];
                    if (target !== tokens.length) {
                        comment.extendedRange[1] = tokens[target].range[0];
                    }
                    target -= 1;
                    if (target >= 0) {
                        if (target < tokens.length) {
                            comment.extendedRange[0] = tokens[target].range[1];
                        } else if (token.length) {
                            comment.extendedRange[1] = tokens[tokens.length - 1].range[0];
                        }
                    }
                    return comment;
                }
                function attachComments(tree, providedComments, tokens) {
                    var comments = [], comment, len, i;
                    if (!tree.range) {
                        throw new Error('attachComments needs range information');
                    }
                    if (!tokens.length) {
                        if (providedComments.length) {
                            for (i = 0, len = providedComments.length; i < len; i += 1) {
                                comment = deepCopy(providedComments[i]);
                                comment.extendedRange = [
                                    0,
                                    tree.range[0]
                                ];
                                comments.push(comment);
                            }
                            tree.leadingComments = comments;
                        }
                        return tree;
                    }
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
                    }
                    traverse(tree, {
                        cursor: 0,
                        enter: function (node) {
                            var comment;
                            while (this.cursor < comments.length) {
                                comment = comments[this.cursor];
                                if (comment.extendedRange[1] > node.range[0]) {
                                    break;
                                }
                                if (comment.extendedRange[1] === node.range[0]) {
                                    if (!node.leadingComments) {
                                        node.leadingComments = [];
                                    }
                                    node.leadingComments.push(comment);
                                    comments.splice(this.cursor, 1);
                                } else {
                                    this.cursor += 1;
                                }
                            }
                            if (this.cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[this.cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    traverse(tree, {
                        cursor: 0,
                        leave: function (node) {
                            var comment;
                            while (this.cursor < comments.length) {
                                comment = comments[this.cursor];
                                if (node.range[1] < comment.extendedRange[0]) {
                                    break;
                                }
                                if (node.range[1] === comment.extendedRange[0]) {
                                    if (!node.trailingComments) {
                                        node.trailingComments = [];
                                    }
                                    node.trailingComments.push(comment);
                                    comments.splice(this.cursor, 1);
                                } else {
                                    this.cursor += 1;
                                }
                            }
                            if (this.cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[this.cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    return tree;
                }
                exports.version = '0.0.17';
                exports.generate = generate;
                exports.attachComments = attachComments;
                exports.browser = false;
            }());
            return exports;
        });
        require.define('/node_modules/estraverse/package.json', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            module.exports = { 'main': 'estraverse.js' };
            return exports;
        });
        require.define('/node_modules/estraverse/estraverse.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            (function (factory) {
                
                if (true) {
                    amdclean_website['escodegen'] = function (module) {
                        return factory();
                    }({});
                } else if (typeof exports !== 'undefined') {
                    factory(exports);
                } else {
                    factory(window.estraverse = {});
                }
            }(function (exports) {
                exports = exports || {};
                
                var Syntax, isArray, VisitorOption, VisitorKeys, wrappers;
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement'
                };
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DebuggerStatement: [],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    EmptyStatement: [],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ]
                };
                VisitorOption = {
                    Break: 1,
                    Skip: 2
                };
                wrappers = { PropertyWrapper: 'Property' };
                function traverse(top, visitor) {
                    var worklist, leavelist, node, nodeType, ret, current, current2, candidates, candidate, marker = {};
                    worklist = [top];
                    leavelist = [null];
                    while (worklist.length) {
                        node = worklist.pop();
                        nodeType = node.type;
                        if (node === marker) {
                            node = leavelist.pop();
                            if (visitor.leave) {
                                ret = visitor.leave(node, leavelist[leavelist.length - 1]);
                            } else {
                                ret = undefined;
                            }
                            if (ret === VisitorOption.Break) {
                                return;
                            }
                        } else if (node) {
                            if (wrappers.hasOwnProperty(nodeType)) {
                                node = node.node;
                                nodeType = wrappers[nodeType];
                            }
                            if (visitor.enter) {
                                ret = visitor.enter(node, leavelist[leavelist.length - 1]);
                            } else {
                                ret = undefined;
                            }
                            if (ret === VisitorOption.Break) {
                                return;
                            }
                            worklist.push(marker);
                            leavelist.push(node);
                            if (ret !== VisitorOption.Skip) {
                                candidates = VisitorKeys[nodeType];
                                current = candidates.length;
                                while ((current -= 1) >= 0) {
                                    candidate = node[candidates[current]];
                                    if (candidate) {
                                        if (isArray(candidate)) {
                                            current2 = candidate.length;
                                            while ((current2 -= 1) >= 0) {
                                                if (candidate[current2]) {
                                                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {
                                                        worklist.push({
                                                            type: 'PropertyWrapper',
                                                            node: candidate[current2]
                                                        });
                                                    } else {
                                                        worklist.push(candidate[current2]);
                                                    }
                                                }
                                            }
                                        } else {
                                            worklist.push(candidate);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                function replace(top, visitor) {
                    var worklist, leavelist, node, nodeType, target, tuple, ret, current, current2, candidates, candidate, marker = {}, result;
                    result = { top: top };
                    tuple = [
                        top,
                        result,
                        'top'
                    ];
                    worklist = [tuple];
                    leavelist = [tuple];
                    function notify(v) {
                        ret = v;
                    }
                    while (worklist.length) {
                        tuple = worklist.pop();
                        if (tuple === marker) {
                            tuple = leavelist.pop();
                            ret = undefined;
                            if (visitor.leave) {
                                node = tuple[0];
                                target = visitor.leave(tuple[0], leavelist[leavelist.length - 1][0], notify);
                                if (target !== undefined) {
                                    node = target;
                                }
                                tuple[1][tuple[2]] = node;
                            }
                            if (ret === VisitorOption.Break) {
                                return result.top;
                            }
                        } else if (tuple[0]) {
                            ret = undefined;
                            node = tuple[0];
                            nodeType = node.type;
                            if (wrappers.hasOwnProperty(nodeType)) {
                                tuple[0] = node = node.node;
                                nodeType = wrappers[nodeType];
                            }
                            if (visitor.enter) {
                                target = visitor.enter(tuple[0], leavelist[leavelist.length - 1][0], notify);
                                if (target !== undefined) {
                                    node = target;
                                }
                                tuple[1][tuple[2]] = node;
                                tuple[0] = node;
                            }
                            if (ret === VisitorOption.Break) {
                                return result.top;
                            }
                            if (tuple[0]) {
                                worklist.push(marker);
                                leavelist.push(tuple);
                                if (ret !== VisitorOption.Skip) {
                                    candidates = VisitorKeys[nodeType];
                                    current = candidates.length;
                                    while ((current -= 1) >= 0) {
                                        candidate = node[candidates[current]];
                                        if (candidate) {
                                            if (isArray(candidate)) {
                                                current2 = candidate.length;
                                                while ((current2 -= 1) >= 0) {
                                                    if (candidate[current2]) {
                                                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {
                                                            worklist.push([
                                                                {
                                                                    type: 'PropertyWrapper',
                                                                    node: candidate[current2]
                                                                },
                                                                candidate,
                                                                current2
                                                            ]);
                                                        } else {
                                                            worklist.push([
                                                                candidate[current2],
                                                                candidate,
                                                                current2
                                                            ]);
                                                        }
                                                    }
                                                }
                                            } else {
                                                worklist.push([
                                                    candidate,
                                                    node,
                                                    candidates[current]
                                                ]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return result.top;
                }
                exports.version = '0.0.4';
                exports.Syntax = Syntax;
                exports.traverse = traverse;
                exports.replace = replace;
                exports.VisitorKeys = VisitorKeys;
                exports.VisitorOption = VisitorOption;
                return exports;
            }));
            return exports;
        });
        require.define('/tools/entry-point.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            (function () {
                
                var escodegen;
                escodegen = global.escodegen = escodegen;
                escodegen.browser = true;
            }());
            return exports;
        });
    }());
    (function (root, factory, undefined) {
        
        if (true) {
            if (typeof exports !== 'undefined') {
                factory.env = 'node';
            } else {
                factory.env = 'web';
            }
            factory.amd = true;
            amdclean_website['amdclean'] = function (esprima, estraverse, escodegen, underscore) {
                return factory({
                    'esprima': esprima,
                    'estraverse': estraverse,
                    'escodegen': escodegen,
                    'underscore': underscore
                });
            }(amdclean_website['esprima'], amdclean_website['estraverse'], amdclean_website['escodegen'], amdclean_website['underscore']);
        } else if (typeof exports !== 'undefined') {
            factory.env = 'node';
            factory();
        } else {
            factory.env = 'web';
            root.amdclean = factory();
        }
    }(this, function cleanamd(amdDependencies) {
        var codeEnv = cleanamd.env, esprima = cleanamd.amd ? amdDependencies.esprima : codeEnv === 'node' ? esprima : window.esprima, estraverse = cleanamd.amd ? amdDependencies.estraverse : codeEnv === 'node' ? estraverse : window.estraverse, escodegen = cleanamd.amd ? amdDependencies.escodegen && amdDependencies.escodegen.generate ? amdDependencies.escodegen : codeEnv === 'node' ? escodegen : window.escodegen : escodegen, _ = cleanamd.amd ? amdDependencies.underscore : codeEnv === 'node' ? lodash : window._, fs = codeEnv === 'node' ? fs : {}, publicAPI = {
                'VERSION': '0.7.1',
                'defaultOptions': {
                    'globalObject': false,
                    'globalObjectName': 'amdclean',
                    'rememberGlobalObject': true,
                    'removeAllRequires': false,
                    'ignoreModules': [],
                    'escodegen': { 'comment': true },
                    'esprima': {
                        'comment': true,
                        'loc': true,
                        'range': true,
                        'tokens': true
                    },
                    'globalModules': [],
                    'commentCleanName': 'amdclean',
                    'shimOverrides': {}
                },
                'env': codeEnv,
                'errorMsgs': {
                    'emptyCode': 'There is no code to generate the AST with',
                    'emptyAst': function (methodName) {
                        return 'An AST is not being passed to the ' + methodName + '() method';
                    },
                    'invalidObject': function (methodName) {
                        return 'An object is not being passed as the first parameter to the ' + methodName + '() method';
                    },
                    'lodash': 'There is not an _.isPlainObject() method.  Make sure you have included lodash (https://github.com/lodash/lodash).',
                    'esprima': 'There is not an esprima.parse() method.  Make sure you have included esprima (https://github.com/ariya/esprima).',
                    'estraverse': 'There is not an estraverse.replace() method.  Make sure you have included estraverse (https://github.com/Constellation/estraverse).',
                    'escodegen': 'There is not an escodegen.generate() method.  Make sure you have included escodegen (https://github.com/Constellation/escodegen).'
                },
                'dependencyBlacklist': {
                    'require': true,
                    'exports': true,
                    'module': true
                },
                'readFile': function (path) {
                    if (publicAPI.env !== 'node') {
                        return '';
                    }
                    return fs.readFileSync(path, 'utf8');
                },
                'isDefine': function (node) {
                    var expression = node.expression || {}, callee = expression.callee;
                    return _.isObject(node) && node.type === 'ExpressionStatement' && _.isObject(expression) && expression.type === 'CallExpression' && callee.type === 'Identifier' && callee.name === 'define';
                },
                'isRequire': function (node) {
                    var expression = node.expression || {}, callee = expression.callee;
                    return _.isObject(node) && node.type === 'ExpressionStatement' && _.isObject(expression) && expression.type === 'CallExpression' && callee.type === 'Identifier' && callee.name === 'require';
                },
                'isRequireExpression': function (node) {
                    return node.type === 'CallExpression' && node.callee && node.callee.name === 'require';
                },
                'isObjectExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'ObjectExpression';
                },
                'isFunctionExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'FunctionExpression';
                },
                'isFunctionCallExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'CallExpression' && _.isPlainObject(expression.callee) && expression.callee.type === 'FunctionExpression';
                },
                'isAMDConditional': function (node) {
                    if (node && node.type !== 'IfStatement' || !_.isObject(node.test) || !_.isObject(node.test.left) || _.isNull(node.test.left.value)) {
                        return false;
                    }
                    var matchObject = {
                            'left': {
                                'operator': 'typeof',
                                'argument': {
                                    'type': 'Identifier',
                                    'name': 'define'
                                }
                            },
                            'right': {
                                'type': 'Literal',
                                'value': 'function'
                            }
                        };
                    return _.where(node.test, matchObject).length || _.where([node.test], matchObject).length || _.where(node.test.left, matchObject).length || _.where([node.test.left], matchObject).length;
                },
                'prefixReservedWords': function (name) {
                    var reservedWord = false;
                    try {
                        if (name.length) {
                            eval('var ' + name + ' = 1;');
                        }
                    } catch (e) {
                        reservedWord = true;
                    }
                    if (reservedWord === true) {
                        return '_' + name;
                    } else {
                        return name;
                    }
                },
                'normalizeModuleName': function (name) {
                    name = name || '';
                    if (name === '{}') {
                        return name;
                    }
                    var normalized = name.replace(/\./g, '').replace(/[^A-Za-z0-9_$]/g, '_').replace(/^_+/, '');
                    return publicAPI.prefixReservedWords(normalized);
                },
                'returnExpressionIdentifier': function (name) {
                    return {
                        'type': 'ExpressionStatement',
                        'expression': {
                            'type': 'Identifier',
                            'name': name
                        }
                    };
                },
                'convertToObjectDeclaration': function (obj, type) {
                    var node = obj.node, moduleName = obj.moduleName, moduleReturnValue = function () {
                            var modReturnValue, callee, params, returnStatement, nestedReturnStatement, internalFunctionExpression;
                            if (type === 'functionCallExpression') {
                                modReturnValue = obj.moduleReturnValue;
                                callee = modReturnValue.callee;
                                params = callee.params;
                                if (params && params.length && _.isArray(params) && _.where(params, { 'name': 'global' })) {
                                    if (_.isObject(callee.body)) {
                                        if (_.isArray(callee.body.body)) {
                                            returnStatement = _.where(callee.body.body, { 'type': 'ReturnStatement' })[0];
                                            if (_.isObject(returnStatement) && _.isObject(returnStatement.argument) && returnStatement.argument.type === 'FunctionExpression') {
                                                internalFunctionExpression = returnStatement.argument;
                                                if (_.isObject(internalFunctionExpression.body) && _.isArray(internalFunctionExpression.body.body)) {
                                                    nestedReturnStatement = _.where(internalFunctionExpression.body.body, { 'type': 'ReturnStatement' })[0];
                                                    if (_.isObject(nestedReturnStatement.argument) && _.isObject(nestedReturnStatement.argument.right) && _.isObject(nestedReturnStatement.argument.right.property)) {
                                                        if (nestedReturnStatement.argument.right.property.name) {
                                                            modReturnValue = {
                                                                'type': 'MemberExpression',
                                                                'computed': false,
                                                                'object': {
                                                                    'type': 'Identifier',
                                                                    'name': 'window'
                                                                },
                                                                'property': {
                                                                    'type': 'Identifier',
                                                                    'name': nestedReturnStatement.argument.right.property.name
                                                                }
                                                            };
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            modReturnValue = modReturnValue || obj.moduleReturnValue;
                            return modReturnValue;
                        }(), options = publicAPI.options, updatedNode = function () {
                            if (options.globalObject === true && options.globalObjectName) {
                                return {
                                    'type': 'ExpressionStatement',
                                    'expression': {
                                        'type': 'AssignmentExpression',
                                        'operator': '=',
                                        'left': {
                                            'type': 'MemberExpression',
                                            'computed': true,
                                            'object': {
                                                'type': 'Identifier',
                                                'name': options.globalObjectName
                                            },
                                            'property': {
                                                'type': 'Literal',
                                                'value': moduleName,
                                                'raw': '' + moduleName + ''
                                            }
                                        },
                                        'right': moduleReturnValue
                                    }
                                };
                            } else {
                                return {
                                    'type': 'VariableDeclaration',
                                    'declarations': [{
                                            'type': 'VariableDeclarator',
                                            'id': {
                                                'type': 'Identifier',
                                                'name': moduleName
                                            },
                                            'init': moduleReturnValue
                                        }],
                                    'kind': 'var'
                                };
                            }
                        }();
                    return updatedNode;
                },
                'convertToIIFE': function (obj) {
                    var callbackFuncParams = obj.callbackFuncParams, callbackFunc = obj.callbackFunc, dependencyNames = obj.dependencyNames;
                    return {
                        'type': 'ExpressionStatement',
                        'expression': {
                            'type': 'CallExpression',
                            'callee': {
                                'type': 'FunctionExpression',
                                'id': null,
                                'params': callbackFuncParams,
                                'defaults': [],
                                'body': callbackFunc.body,
                                'rest': callbackFunc.rest,
                                'generator': callbackFunc.generator,
                                'expression': callbackFunc.expression
                            },
                            'arguments': dependencyNames
                        }
                    };
                },
                'convertToIIFEDeclaration': function (obj) {
                    var moduleName = obj.moduleName, callbackFuncParams = obj.callbackFuncParams, isOptimized = obj.isOptimized, callbackFunc = function () {
                            var cbFunc = obj.callbackFunc;
                            if (cbFunc.type === 'Identifier') {
                                cbFunc = {
                                    'type': 'FunctionExpression',
                                    'id': null,
                                    'params': [],
                                    'defaults': [],
                                    'body': {
                                        'type': 'BlockStatement',
                                        'body': [{
                                                'type': 'ReturnStatement',
                                                'argument': {
                                                    'type': 'CallExpression',
                                                    'callee': {
                                                        'type': 'Identifier',
                                                        'name': cbFunc.name
                                                    },
                                                    'arguments': []
                                                }
                                            }]
                                    },
                                    'rest': null,
                                    'generator': false,
                                    'expression': false
                                };
                            }
                            return cbFunc;
                        }(), dependencyNames = obj.dependencyNames, options = publicAPI.options, cb = function () {
                            if (callbackFunc.type === 'Literal' || isOptimized === true) {
                                return callbackFunc;
                            } else {
                                return {
                                    'type': 'CallExpression',
                                    'callee': {
                                        'type': 'FunctionExpression',
                                        'id': {
                                            'type': 'Identifier',
                                            'name': ''
                                        },
                                        'params': callbackFuncParams,
                                        'defaults': [],
                                        'body': callbackFunc.body,
                                        'rest': callbackFunc.rest,
                                        'generator': callbackFunc.generator,
                                        'expression': callbackFunc.expression
                                    },
                                    'arguments': dependencyNames
                                };
                            }
                        }(), updatedNode = function () {
                            if (options.globalObject === true && options.globalObjectName) {
                                return {
                                    'type': 'ExpressionStatement',
                                    'expression': {
                                        'type': 'AssignmentExpression',
                                        'operator': '=',
                                        'left': {
                                            'type': 'MemberExpression',
                                            'computed': true,
                                            'object': {
                                                'type': 'Identifier',
                                                'name': options.globalObjectName
                                            },
                                            'property': {
                                                'type': 'Literal',
                                                'value': moduleName,
                                                'raw': '' + moduleName + ''
                                            }
                                        },
                                        'right': cb
                                    }
                                };
                            } else {
                                return {
                                    'type': 'VariableDeclaration',
                                    'declarations': [{
                                            'type': 'VariableDeclarator',
                                            'id': {
                                                'type': 'Identifier',
                                                'name': moduleName
                                            },
                                            'init': cb
                                        }],
                                    'kind': 'var'
                                };
                            }
                        }();
                    return updatedNode;
                },
                'convertToFunctionExpression': function (obj) {
                    var isDefine = obj.isDefine, isRequire = obj.isRequire, isOptimized = false, node = obj.node, moduleName = obj.moduleName, dependencies = obj.dependencies, depLength = dependencies.length, options = publicAPI.options, dependencyNames = function () {
                            var deps = [], iterator = -1, currentName;
                            while (++iterator < depLength) {
                                currentName = dependencies[iterator];
                                if (options.globalObject === true && options.globalObjectName && currentName !== '{}') {
                                    deps.push({
                                        'type': 'MemberExpression',
                                        'computed': true,
                                        'object': {
                                            'type': 'Identifier',
                                            'name': options.globalObjectName
                                        },
                                        'property': {
                                            'type': 'Literal',
                                            'value': publicAPI.normalizeModuleName(currentName),
                                            'raw': '' + publicAPI.normalizeModuleName(currentName) + ''
                                        },
                                        'name': publicAPI.normalizeModuleName(currentName)
                                    });
                                } else {
                                    deps.push({
                                        'type': 'Identifier',
                                        'name': publicAPI.normalizeModuleName(currentName)
                                    });
                                }
                            }
                            return deps;
                        }(), callbackFunc = function () {
                            var callbackFunc = obj.moduleReturnValue, body, returnStatements, firstReturnStatement, returnStatementArg;
                            if (!depLength && callbackFunc && callbackFunc.type === 'FunctionExpression' && callbackFunc.body && _.isArray(callbackFunc.body.body) && callbackFunc.body.body.length) {
                                body = callbackFunc.body.body;
                                returnStatements = _.where(callbackFunc.body.body, { 'type': 'ReturnStatement' });
                                if (returnStatements.length) {
                                    firstReturnStatement = returnStatements[0];
                                    returnStatementArg = firstReturnStatement.argument;
                                    if (!publicAPI.isFunctionExpression(firstReturnStatement) && body.length > 1 || returnStatementArg && returnStatementArg.type === 'Identifier') {
                                        return callbackFunc;
                                    } else {
                                        callbackFunc = returnStatementArg;
                                        isOptimized = true;
                                        if (callbackFunc.params) {
                                            depLength = callbackFunc.params.length;
                                        }
                                    }
                                }
                            }
                            return callbackFunc;
                        }(), hasReturnStatement = function () {
                            var returns = [];
                            if (callbackFunc && callbackFunc.body && _.isArray(callbackFunc.body.body)) {
                                returns = _.where(callbackFunc.body.body, { 'type': 'ReturnStatement' });
                                if (returns.length) {
                                    return true;
                                }
                            }
                            return false;
                        }(), hasExportsParam = false, callbackFuncParams = function () {
                            var deps = [], iterator = -1, currentParam, currentName, cbParams = callbackFunc.params || [];
                            while (++iterator < depLength) {
                                currentParam = cbParams[iterator];
                                if (currentParam) {
                                    currentName = currentParam.name;
                                } else {
                                    currentName = dependencyNames[iterator].name;
                                }
                                if (currentName === 'exports') {
                                    hasExportsParam = true;
                                }
                                if (currentName === '{}') {
                                    currentName = 'module';
                                }
                                deps.push({
                                    'type': 'Identifier',
                                    'name': currentName
                                });
                            }
                            return deps;
                        }();
                    if (!hasReturnStatement && hasExportsParam) {
                        callbackFunc.body.body.push({
                            'type': 'ReturnStatement',
                            'argument': {
                                'type': 'Identifier',
                                'name': 'exports'
                            }
                        });
                    }
                    if (isDefine) {
                        return publicAPI.convertToIIFEDeclaration({
                            moduleName: moduleName,
                            dependencyNames: dependencyNames,
                            callbackFuncParams: callbackFuncParams,
                            hasExportsParam: hasExportsParam,
                            callbackFunc: callbackFunc,
                            isOptimized: isOptimized
                        });
                    } else if (isRequire) {
                        return publicAPI.convertToIIFE({
                            dependencyNames: dependencyNames,
                            callbackFuncParams: callbackFuncParams,
                            callbackFunc: callbackFunc
                        });
                    }
                },
                'convertDefinesAndRequires': function (node, parent) {
                    var moduleName, args, dependencies, moduleReturnValue, params, isDefine = publicAPI.isDefine(node), isRequire = publicAPI.isRequire(node), startLineNumber, comments, currentLineNumber, lineNumberObj = {}, callbackFuncArg = false, type = '';
                    if (node.type === 'Program') {
                        comments = function () {
                            var arr = [];
                            _.each(node.comments, function (currentComment, iterator) {
                                var currentCommentValue = currentComment.value.trim();
                                if (currentCommentValue === publicAPI.options.commentCleanName) {
                                    arr.push(currentComment);
                                }
                            });
                            return arr;
                        }();
                        _.each(comments, function (currentComment, iterator) {
                            currentLineNumber = currentComment.loc.start.line;
                            lineNumberObj[currentLineNumber] = true;
                        });
                        publicAPI.commentLineNumbers = lineNumberObj;
                    }
                    if (publicAPI.isAMDConditional(node)) {
                        node.test = {
                            'type': 'Literal',
                            'value': true,
                            'raw': 'true'
                        };
                        return node;
                    }
                    if (isDefine || isRequire) {
                        startLineNumber = node.expression.loc.start.line;
                        if (publicAPI.commentLineNumbers[startLineNumber] || publicAPI.commentLineNumbers['' + (parseInt(startLineNumber, 10) - 1)]) {
                            return node;
                        }
                        args = Array.prototype.slice.call(node.expression['arguments'], 0);
                        dependencies = function () {
                            var deps = isRequire ? args[0] : args[args.length - 2], depNames = [];
                            if (_.isPlainObject(deps)) {
                                deps = deps.elements || [];
                            } else {
                                deps = [];
                            }
                            if (Array.isArray(deps) && deps.length) {
                                _.each(deps, function (currentDependency) {
                                    if (publicAPI.dependencyBlacklist[currentDependency.value]) {
                                        depNames.push('{}');
                                    } else {
                                        depNames.push(currentDependency.value);
                                    }
                                });
                            }
                            return depNames;
                        }();
                        moduleReturnValue = isRequire ? args[1] : args[args.length - 1];
                        moduleName = publicAPI.normalizeModuleName(node.expression['arguments'][0].value);
                        params = {
                            node: node,
                            moduleName: moduleName,
                            dependencies: dependencies,
                            moduleReturnValue: moduleReturnValue,
                            isDefine: isDefine,
                            isRequire: isRequire
                        };
                        if (isDefine) {
                            if (_.isObject(publicAPI.options.shimOverrides) && publicAPI.options.shimOverrides[moduleName]) {
                                params.moduleReturnValue = publicAPI.createAst({ 'code': publicAPI.options.shimOverrides[moduleName] });
                                if (_.isArray(params.moduleReturnValue.body) && _.isObject(params.moduleReturnValue.body[0])) {
                                    if (_.isObject(params.moduleReturnValue.body[0].expression)) {
                                        params.moduleReturnValue = params.moduleReturnValue.body[0].expression;
                                        type = 'objectExpression';
                                    }
                                } else {
                                    params.moduleReturnValue = moduleReturnValue;
                                }
                            }
                            if (params.moduleReturnValue && params.moduleReturnValue.type === 'Identifier') {
                                type = 'functionExpression';
                            }
                            if (_.isArray(publicAPI.options.ignoreModules) && publicAPI.options.ignoreModules.indexOf(moduleName) !== -1) {
                                return node;
                            } else if (publicAPI.isFunctionExpression(moduleReturnValue) || type === 'functionExpression') {
                                return publicAPI.convertToFunctionExpression(params);
                            } else if (publicAPI.isObjectExpression(moduleReturnValue) || type === 'objectExpression') {
                                return publicAPI.convertToObjectDeclaration(params);
                            } else if (publicAPI.isFunctionCallExpression(moduleReturnValue)) {
                                return publicAPI.convertToObjectDeclaration(params, 'functionCallExpression');
                            }
                        } else if (isRequire) {
                            callbackFuncArg = _.isArray(node.expression['arguments']) && node.expression['arguments'].length ? node.expression['arguments'][1] && node.expression['arguments'][1].body && node.expression['arguments'][1].body.body && node.expression['arguments'][1].body.body.length : false;
                            if (publicAPI.options.removeAllRequires !== true && callbackFuncArg) {
                                return publicAPI.convertToFunctionExpression(params);
                            } else {
                                return { type: 'EmptyStatement' };
                            }
                        }
                    } else {
                        if (node.type === 'FunctionExpression' && _.isArray(node.params) && _.where(node.params, {
                                'type': 'Identifier',
                                'name': 'exports'
                            }).length && _.isObject(node.body) && _.isArray(node.body.body) && !_.where(node.body.body, {
                                'type': 'ReturnStatement',
                                'argument': { 'type': 'Identifier' }
                            }).length) {
                            node.body.body.unshift({
                                'type': 'ExpressionStatement',
                                'expression': {
                                    'type': 'AssignmentExpression',
                                    'operator': '=',
                                    'left': {
                                        'type': 'Identifier',
                                        'name': 'exports'
                                    },
                                    'right': {
                                        'type': 'LogicalExpression',
                                        'operator': '||',
                                        'left': {
                                            'type': 'Identifier',
                                            'name': 'exports'
                                        },
                                        'right': {
                                            'type': 'ObjectExpression',
                                            'properties': []
                                        }
                                    }
                                }
                            });
                            node.body.body.push({
                                'type': 'ReturnStatement',
                                'argument': {
                                    'type': 'Identifier',
                                    'name': 'exports'
                                }
                            });
                        }
                        return node;
                    }
                },
                'createAst': function (obj) {
                    var filePath = obj.filePath, code = obj.code || (filePath && publicAPI.env === 'node' ? publicAPI.readFile(filePath) : ''), esprimaOptions = publicAPI.options.esprima;
                    if (!code) {
                        throw new Error(publicAPI.errorMsgs.emptyCode);
                    } else {
                        if (!_.isPlainObject(esprima) || !_.isFunction(esprima.parse)) {
                            throw new Error(publicAPI.errorMsgs.esprima);
                        }
                        return esprima.parse(code, esprimaOptions);
                    }
                },
                'traverseAndUpdateAst': function (obj) {
                    if (!_.isPlainObject(obj)) {
                        throw new Error(publicAPI.errorMsgs.invalidObject('traverseAndUpdateAst'));
                    }
                    var ast = obj.ast, enterDefault = function (node, parent) {
                            return publicAPI.convertDefinesAndRequires(node, parent);
                        }, leaveDefault = function (node, parent) {
                            return node;
                        }, enterFunc = _.isFunction(obj.enterFunc) ? obj.enterFunc : enterDefault, leaveFunc = _.isFunction(obj.leaveFunc) ? obj.leaveFunc : leaveDefault;
                    if (!ast) {
                        throw new Error(publicAPI.errorMsgs.emptyAst('traverseAndUpdateAst'));
                    }
                    if (!_.isPlainObject(estraverse) || !_.isFunction(estraverse.replace)) {
                        throw new Error(publicAPI.errorMsgs.estraverse);
                    }
                    estraverse.replace(ast, {
                        'enter': enterFunc,
                        'leave': leaveFunc
                    });
                    return ast;
                },
                'generateCode': function (ast, options) {
                    var esprimaOptions = options.esprima || {}, escodegenOptions = options.escodegen || {};
                    if (!_.isPlainObject(escodegen) || !_.isFunction(escodegen.generate)) {
                        throw new Error(publicAPI.errorMsgs.escodegen);
                    }
                    if (esprimaOptions.comment === true && escodegenOptions.comment === true) {
                        try {
                            ast = escodegen.attachComments(ast, ast.comments, ast.tokens);
                        } catch (e) {
                        }
                    }
                    return escodegen.generate(ast, escodegenOptions);
                },
                'clean': function (obj) {
                    var code = {}, ast = {}, options = {}, defaultOptions = _.cloneDeep(publicAPI.defaultOptions) || {}, userOptions = _.cloneDeep(obj) || {};
                    publicAPI.options = options = _.merge(defaultOptions, userOptions);
                    if (!_ || !_.isPlainObject) {
                        throw new Error(publicAPI.errorMsgs.lodash);
                    }
                    if (!_.isPlainObject(obj) && _.isString(obj)) {
                        code.code = obj;
                    } else if (_.isPlainObject(obj)) {
                        code = obj;
                    } else {
                        throw new Error(publicAPI.errorMsgs.invalidObject('clean'));
                    }
                    ast = publicAPI.traverseAndUpdateAst({ ast: publicAPI.createAst(code) });
                    if (ast && _.isArray(ast.body)) {
                        estraverse.replace(ast, {
                            enter: function (node, parent) {
                                if (node === undefined || node.type === 'EmptyStatement') {
                                    _.each(parent.body, function (currentNode, iterator) {
                                        if (currentNode === undefined || currentNode.type === 'EmptyStatement') {
                                            parent.body.splice(iterator, 1);
                                        }
                                    });
                                } else if (publicAPI.isRequireExpression(node)) {
                                    if (node.arguments && node.arguments[0] && node.arguments[0].value) {
                                        return {
                                            'type': 'Identifier',
                                            'name': publicAPI.normalizeModuleName(node.arguments[0].value)
                                        };
                                    } else {
                                        return node;
                                    }
                                }
                            }
                        });
                    }
                    if (_.isArray(options.globalModules)) {
                        _.each(options.globalModules, function (currentModule) {
                            if (_.isString(currentModule) && currentModule.length) {
                                ast.body.push({
                                    'type': 'ExpressionStatement',
                                    'expression': {
                                        'type': 'AssignmentExpression',
                                        'operator': '=',
                                        'left': {
                                            'type': 'MemberExpression',
                                            'computed': false,
                                            'object': {
                                                'type': 'Identifier',
                                                'name': 'window'
                                            },
                                            'property': {
                                                'type': 'Identifier',
                                                'name': currentModule
                                            }
                                        },
                                        'right': {
                                            'type': 'Identifier',
                                            'name': currentModule
                                        }
                                    }
                                });
                            }
                        });
                    }
                    if (options.globalObject === true && options.globalObjectName && !publicAPI.createdGlobalObject) {
                        if (options.rememberGlobalObject === true) {
                            publicAPI.createdGlobalObject = true;
                        }
                        ast.body.unshift({
                            'type': 'VariableDeclaration',
                            'declarations': [{
                                    'type': 'VariableDeclarator',
                                    'id': {
                                        'type': 'Identifier',
                                        'name': options.globalObjectName
                                    },
                                    'init': {
                                        'type': 'ObjectExpression',
                                        'properties': []
                                    }
                                }],
                            'kind': 'var'
                        });
                    }
                    return publicAPI.generateCode(ast, options);
                }
            };
        if (codeEnv === 'node') {
            module.exports = publicAPI;
        } else {
            return publicAPI;
        }
    }));
    window.CodeMirror = function () {
        
        var gecko = /gecko\/\d/i.test(navigator.userAgent);
        var ie = /MSIE \d/.test(navigator.userAgent);
        var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
        var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
        var webkit = /WebKit\//.test(navigator.userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
        var chrome = /Chrome\//.test(navigator.userAgent);
        var opera = /Opera\//.test(navigator.userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var khtml = /KHTML\//.test(navigator.userAgent);
        var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
        var phantom = /PhantomJS/.test(navigator.userAgent);
        var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
        var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
        var mac = ios || /Mac/.test(navigator.platform);
        var windows = /win/i.test(navigator.platform);
        var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
        if (opera_version)
            opera_version = Number(opera_version[1]);
        if (opera_version && opera_version >= 15) {
            opera = false;
            webkit = true;
        }
        var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
        var captureMiddleClick = gecko || ie && !ie_lt9;
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function CodeMirror(place, options) {
            if (!(this instanceof CodeMirror))
                return new CodeMirror(place, options);
            this.options = options = options || {};
            for (var opt in defaults)
                if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
                    options[opt] = defaults[opt];
            setGuttersForLineNumbers(options);
            var docStart = typeof options.value == 'string' ? 0 : options.value.first;
            var display = this.display = makeDisplay(place, docStart);
            display.wrapper.CodeMirror = this;
            updateGutters(this);
            if (options.autofocus && !mobile)
                focusInput(this);
            this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: false,
                focused: false,
                suppressEdits: false,
                pasteIncoming: false,
                draggingText: false,
                highlight: new Delayed()
            };
            themeChanged(this);
            if (options.lineWrapping)
                this.display.wrapper.className += ' CodeMirror-wrap';
            var doc = options.value;
            if (typeof doc == 'string')
                doc = new Doc(options.value, options.mode);
            operation(this, attachDoc)(this, doc);
            if (ie)
                setTimeout(bind(resetInput, this, true), 20);
            registerEventHandlers(this);
            var hasFocus;
            try {
                hasFocus = document.activeElement == display.input;
            } catch (e) {
            }
            if (hasFocus || options.autofocus && !mobile)
                setTimeout(bind(onFocus, this), 20);
            else
                onBlur(this);
            operation(this, function () {
                for (var opt in optionHandlers)
                    if (optionHandlers.propertyIsEnumerable(opt))
                        optionHandlers[opt](this, options[opt], Init);
                for (var i = 0; i < initHooks.length; ++i)
                    initHooks[i](this);
            })();
        }
        function makeDisplay(place, docStart) {
            var d = {};
            var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
            if (webkit)
                input.style.width = '1000px';
            else
                input.setAttribute('wrap', 'off');
            if (ios)
                input.style.border = '1px solid black';
            input.setAttribute('autocorrect', 'off');
            input.setAttribute('autocapitalize', 'off');
            input.setAttribute('spellcheck', 'false');
            d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
            d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
            d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
            d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
            d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
            d.lineDiv = elt('div', null, 'CodeMirror-code');
            d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
            d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
            d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
            d.measure = elt('div', null, 'CodeMirror-measure');
            d.lineSpace = elt('div', [
                d.measure,
                d.selectionDiv,
                d.lineDiv,
                d.cursor,
                d.otherCursor
            ], null, 'position: relative; outline: none');
            d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
            d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
            d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
            d.gutters = elt('div', null, 'CodeMirror-gutters');
            d.lineGutter = null;
            d.scroller = elt('div', [
                d.sizer,
                d.heightForcer,
                d.gutters
            ], 'CodeMirror-scroll');
            d.scroller.setAttribute('tabIndex', '-1');
            d.wrapper = elt('div', [
                d.inputDiv,
                d.scrollbarH,
                d.scrollbarV,
                d.scrollbarFiller,
                d.gutterFiller,
                d.scroller
            ], 'CodeMirror');
            if (ie_lt8) {
                d.gutters.style.zIndex = -1;
                d.scroller.style.paddingRight = 0;
            }
            if (place.appendChild)
                place.appendChild(d.wrapper);
            else
                place(d.wrapper);
            if (ios)
                input.style.width = '0px';
            if (!webkit)
                d.scroller.draggable = true;
            if (khtml) {
                d.inputDiv.style.height = '1px';
                d.inputDiv.style.position = 'absolute';
            } else if (ie_lt8)
                d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
            d.viewOffset = d.lastSizeC = 0;
            d.showingFrom = d.showingTo = docStart;
            d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
            d.prevInput = '';
            d.alignWidgets = false;
            d.pollingFast = false;
            d.poll = new Delayed();
            d.cachedCharWidth = d.cachedTextHeight = null;
            d.measureLineCache = [];
            d.measureLineCachePos = 0;
            d.inaccurateSelection = false;
            d.maxLine = null;
            d.maxLineLength = 0;
            d.maxLineChanged = false;
            d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
            return d;
        }
        function loadMode(cm) {
            cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
            cm.doc.iter(function (line) {
                if (line.stateAfter)
                    line.stateAfter = null;
                if (line.styles)
                    line.styles = null;
            });
            cm.doc.frontier = cm.doc.first;
            startWorker(cm, 100);
            cm.state.modeGen++;
            if (cm.curOp)
                regChange(cm);
        }
        function wrappingChanged(cm) {
            if (cm.options.lineWrapping) {
                cm.display.wrapper.className += ' CodeMirror-wrap';
                cm.display.sizer.style.minWidth = '';
            } else {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
                computeMaxLength(cm);
            }
            estimateLineHeights(cm);
            regChange(cm);
            clearCaches(cm);
            setTimeout(function () {
                updateScrollbars(cm);
            }, 100);
        }
        function estimateHeight(cm) {
            var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
            var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
            return function (line) {
                if (lineIsHidden(cm.doc, line))
                    return 0;
                else if (wrapping)
                    return (Math.ceil(line.text.length / perLine) || 1) * th;
                else
                    return th;
            };
        }
        function estimateLineHeights(cm) {
            var doc = cm.doc, est = estimateHeight(cm);
            doc.iter(function (line) {
                var estHeight = est(line);
                if (estHeight != line.height)
                    updateLineHeight(line, estHeight);
            });
        }
        function keyMapChanged(cm) {
            var map = keyMap[cm.options.keyMap], style = map.style;
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
            cm.state.disableInput = map.disableInput;
        }
        function themeChanged(cm) {
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
            clearCaches(cm);
        }
        function guttersChanged(cm) {
            updateGutters(cm);
            regChange(cm);
            setTimeout(function () {
                alignHorizontally(cm);
            }, 20);
        }
        function updateGutters(cm) {
            var gutters = cm.display.gutters, specs = cm.options.gutters;
            removeChildren(gutters);
            for (var i = 0; i < specs.length; ++i) {
                var gutterClass = specs[i];
                var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
                if (gutterClass == 'CodeMirror-linenumbers') {
                    cm.display.lineGutter = gElt;
                    gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
                }
            }
            gutters.style.display = i ? '' : 'none';
        }
        function lineLength(doc, line) {
            if (line.height == 0)
                return 0;
            var len = line.text.length, merged, cur = line;
            while (merged = collapsedSpanAtStart(cur)) {
                var found = merged.find();
                cur = getLine(doc, found.from.line);
                len += found.from.ch - found.to.ch;
            }
            cur = line;
            while (merged = collapsedSpanAtEnd(cur)) {
                var found = merged.find();
                len -= cur.text.length - found.from.ch;
                cur = getLine(doc, found.to.line);
                len += cur.text.length - found.to.ch;
            }
            return len;
        }
        function computeMaxLength(cm) {
            var d = cm.display, doc = cm.doc;
            d.maxLine = getLine(doc, doc.first);
            d.maxLineLength = lineLength(doc, d.maxLine);
            d.maxLineChanged = true;
            doc.iter(function (line) {
                var len = lineLength(doc, line);
                if (len > d.maxLineLength) {
                    d.maxLineLength = len;
                    d.maxLine = line;
                }
            });
        }
        function setGuttersForLineNumbers(options) {
            var found = indexOf(options.gutters, 'CodeMirror-linenumbers');
            if (found == -1 && options.lineNumbers) {
                options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
            } else if (found > -1 && !options.lineNumbers) {
                options.gutters = options.gutters.slice(0);
                options.gutters.splice(found, 1);
            }
        }
        function updateScrollbars(cm) {
            var d = cm.display, docHeight = cm.doc.height;
            var totalHeight = docHeight + paddingVert(d);
            d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
            d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + 'px';
            var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
            var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;
            var needsV = scrollHeight > d.scroller.clientHeight + 1;
            if (needsV) {
                d.scrollbarV.style.display = 'block';
                d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
                d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
            } else {
                d.scrollbarV.style.display = '';
                d.scrollbarV.firstChild.style.height = '0';
            }
            if (needsH) {
                d.scrollbarH.style.display = 'block';
                d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
                d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
            } else {
                d.scrollbarH.style.display = '';
                d.scrollbarH.firstChild.style.width = '0';
            }
            if (needsH && needsV) {
                d.scrollbarFiller.style.display = 'block';
                d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
            } else
                d.scrollbarFiller.style.display = '';
            if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
                d.gutterFiller.style.display = 'block';
                d.gutterFiller.style.height = scrollbarWidth(d.measure) + 'px';
                d.gutterFiller.style.width = d.gutters.offsetWidth + 'px';
            } else
                d.gutterFiller.style.display = '';
            if (mac_geLion && scrollbarWidth(d.measure) === 0) {
                d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
                d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = 'none';
            }
        }
        function visibleLines(display, doc, viewPort) {
            var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
            if (typeof viewPort == 'number')
                top = viewPort;
            else if (viewPort) {
                top = viewPort.top;
                height = viewPort.bottom - viewPort.top;
            }
            top = Math.floor(top - paddingTop(display));
            var bottom = Math.ceil(top + height);
            return {
                from: lineAtHeight(doc, top),
                to: lineAtHeight(doc, bottom)
            };
        }
        function alignHorizontally(cm) {
            var display = cm.display;
            if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
                return;
            var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
            var gutterW = display.gutters.offsetWidth, l = comp + 'px';
            for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
                if (n.alignable) {
                    for (var i = 0, a = n.alignable; i < a.length; ++i)
                        a[i].style.left = l;
                }
            if (cm.options.fixedGutter)
                display.gutters.style.left = comp + gutterW + 'px';
        }
        function maybeUpdateLineNumberWidth(cm) {
            if (!cm.options.lineNumbers)
                return false;
            var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
            if (last.length != display.lineNumChars) {
                var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
                var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                display.lineGutter.style.width = '';
                display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
                display.lineNumWidth = display.lineNumInnerWidth + padding;
                display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
                display.lineGutter.style.width = display.lineNumWidth + 'px';
                return true;
            }
            return false;
        }
        function lineNumberFor(options, i) {
            return String(options.lineNumberFormatter(i + options.firstLineNumber));
        }
        function compensateForHScroll(display) {
            return getRect(display.scroller).left - getRect(display.sizer).left;
        }
        function updateDisplay(cm, changes, viewPort, forced) {
            var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
            var visible = visibleLines(cm.display, cm.doc, viewPort);
            for (var first = true;; first = false) {
                var oldWidth = cm.display.scroller.clientWidth;
                if (!updateDisplayInner(cm, changes, visible, forced))
                    break;
                updated = true;
                changes = [];
                updateSelection(cm);
                updateScrollbars(cm);
                if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
                    forced = true;
                    continue;
                }
                forced = false;
                if (viewPort)
                    viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
                visible = visibleLines(cm.display, cm.doc, viewPort);
                if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
                    break;
            }
            if (updated) {
                signalLater(cm, 'update', cm);
                if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
                    signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
            }
            return updated;
        }
        function updateDisplayInner(cm, changes, visible, forced) {
            var display = cm.display, doc = cm.doc;
            if (!display.wrapper.clientWidth) {
                display.showingFrom = display.showingTo = doc.first;
                display.viewOffset = 0;
                return;
            }
            if (!forced && changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
                return;
            if (maybeUpdateLineNumberWidth(cm))
                changes = [{
                        from: doc.first,
                        to: doc.first + doc.size
                    }];
            var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
            display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
            var positionsChangedFrom = Infinity;
            if (cm.options.lineNumbers)
                for (var i = 0; i < changes.length; ++i)
                    if (changes[i].diff && changes[i].from < positionsChangedFrom) {
                        positionsChangedFrom = changes[i].from;
                    }
            var end = doc.first + doc.size;
            var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
            var to = Math.min(end, visible.to + cm.options.viewportMargin);
            if (display.showingFrom < from && from - display.showingFrom < 20)
                from = Math.max(doc.first, display.showingFrom);
            if (display.showingTo > to && display.showingTo - to < 20)
                to = Math.min(end, display.showingTo);
            if (sawCollapsedSpans) {
                from = lineNo(visualLine(doc, getLine(doc, from)));
                while (to < end && lineIsHidden(doc, getLine(doc, to)))
                    ++to;
            }
            var intact = [{
                        from: Math.max(display.showingFrom, doc.first),
                        to: Math.min(display.showingTo, end)
                    }];
            if (intact[0].from >= intact[0].to)
                intact = [];
            else
                intact = computeIntact(intact, changes);
            if (sawCollapsedSpans)
                for (var i = 0; i < intact.length; ++i) {
                    var range = intact[i], merged;
                    while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
                        var newTo = merged.find().from.line;
                        if (newTo > range.from)
                            range.to = newTo;
                        else {
                            intact.splice(i--, 1);
                            break;
                        }
                    }
                }
            var intactLines = 0;
            for (var i = 0; i < intact.length; ++i) {
                var range = intact[i];
                if (range.from < from)
                    range.from = from;
                if (range.to > to)
                    range.to = to;
                if (range.from >= range.to)
                    intact.splice(i--, 1);
                else
                    intactLines += range.to - range.from;
            }
            if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
                updateViewOffset(cm);
                return;
            }
            intact.sort(function (a, b) {
                return a.from - b.from;
            });
            try {
                var focused = document.activeElement;
            } catch (e) {
            }
            if (intactLines < (to - from) * 0.7)
                display.lineDiv.style.display = 'none';
            patchDisplay(cm, from, to, intact, positionsChangedFrom);
            display.lineDiv.style.display = '';
            if (focused && document.activeElement != focused && focused.offsetHeight)
                focused.focus();
            var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
            if (different) {
                display.lastSizeC = display.wrapper.clientHeight;
                startWorker(cm, 400);
            }
            display.showingFrom = from;
            display.showingTo = to;
            updateHeightsInViewport(cm);
            updateViewOffset(cm);
            return true;
        }
        function updateHeightsInViewport(cm) {
            var display = cm.display;
            var prevBottom = display.lineDiv.offsetTop;
            for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
                if (node.lineObj) {
                    if (ie_lt8) {
                        var bot = node.offsetTop + node.offsetHeight;
                        height = bot - prevBottom;
                        prevBottom = bot;
                    } else {
                        var box = getRect(node);
                        height = box.bottom - box.top;
                    }
                    var diff = node.lineObj.height - height;
                    if (height < 2)
                        height = textHeight(display);
                    if (diff > 0.001 || diff < -0.001) {
                        updateLineHeight(node.lineObj, height);
                        var widgets = node.lineObj.widgets;
                        if (widgets)
                            for (var i = 0; i < widgets.length; ++i)
                                widgets[i].height = widgets[i].node.offsetHeight;
                    }
                }
        }
        function updateViewOffset(cm) {
            var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
            cm.display.mover.style.top = off + 'px';
        }
        function computeIntact(intact, changes) {
            for (var i = 0, l = changes.length || 0; i < l; ++i) {
                var change = changes[i], intact2 = [], diff = change.diff || 0;
                for (var j = 0, l2 = intact.length; j < l2; ++j) {
                    var range = intact[j];
                    if (change.to <= range.from && change.diff) {
                        intact2.push({
                            from: range.from + diff,
                            to: range.to + diff
                        });
                    } else if (change.to <= range.from || change.from >= range.to) {
                        intact2.push(range);
                    } else {
                        if (change.from > range.from)
                            intact2.push({
                                from: range.from,
                                to: change.from
                            });
                        if (change.to < range.to)
                            intact2.push({
                                from: change.to + diff,
                                to: range.to + diff
                            });
                    }
                }
                intact = intact2;
            }
            return intact;
        }
        function getDimensions(cm) {
            var d = cm.display, left = {}, width = {};
            for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
                left[cm.options.gutters[i]] = n.offsetLeft;
                width[cm.options.gutters[i]] = n.offsetWidth;
            }
            return {
                fixedPos: compensateForHScroll(d),
                gutterTotalWidth: d.gutters.offsetWidth,
                gutterLeft: left,
                gutterWidth: width,
                wrapperWidth: d.wrapper.clientWidth
            };
        }
        function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
            var dims = getDimensions(cm);
            var display = cm.display, lineNumbers = cm.options.lineNumbers;
            if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
                removeChildren(display.lineDiv);
            var container = display.lineDiv, cur = container.firstChild;
            function rm(node) {
                var next = node.nextSibling;
                if (webkit && mac && cm.display.currentWheelTarget == node) {
                    node.style.display = 'none';
                    node.lineObj = null;
                } else {
                    node.parentNode.removeChild(node);
                }
                return next;
            }
            var nextIntact = intact.shift(), lineN = from;
            cm.doc.iter(from, to, function (line) {
                if (nextIntact && nextIntact.to == lineN)
                    nextIntact = intact.shift();
                if (lineIsHidden(cm.doc, line)) {
                    if (line.height != 0)
                        updateLineHeight(line, 0);
                    if (line.widgets && cur && cur.previousSibling)
                        for (var i = 0; i < line.widgets.length; ++i) {
                            var w = line.widgets[i];
                            if (w.showIfHidden) {
                                var prev = cur.previousSibling;
                                if (/pre/i.test(prev.nodeName)) {
                                    var wrap = elt('div', null, null, 'position: relative');
                                    prev.parentNode.replaceChild(wrap, prev);
                                    wrap.appendChild(prev);
                                    prev = wrap;
                                }
                                var wnode = prev.appendChild(elt('div', [w.node], 'CodeMirror-linewidget'));
                                if (!w.handleMouseEvents)
                                    wnode.ignoreEvents = true;
                                positionLineWidget(w, wnode, prev, dims);
                            }
                        }
                } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
                    while (cur.lineObj != line)
                        cur = rm(cur);
                    if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
                        setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
                    cur = cur.nextSibling;
                } else {
                    if (line.widgets)
                        for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
                            if (search.lineObj == line && /div/i.test(search.nodeName)) {
                                reuse = search;
                                break;
                            }
                    var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
                    if (lineNode != reuse) {
                        container.insertBefore(lineNode, cur);
                    } else {
                        while (cur != reuse)
                            cur = rm(cur);
                        cur = cur.nextSibling;
                    }
                    lineNode.lineObj = line;
                }
                ++lineN;
            });
            while (cur)
                cur = rm(cur);
        }
        function buildLineElement(cm, line, lineNo, dims, reuse) {
            var built = buildLineContent(cm, line), lineElement = built.pre;
            var markers = line.gutterMarkers, display = cm.display, wrap;
            var bgClass = built.bgClass ? built.bgClass + ' ' + (line.bgClass || '') : line.bgClass;
            if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)
                return lineElement;
            if (reuse) {
                reuse.alignable = null;
                var isOk = true, widgetsSeen = 0, insertBefore = null;
                for (var n = reuse.firstChild, next; n; n = next) {
                    next = n.nextSibling;
                    if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
                        reuse.removeChild(n);
                    } else {
                        for (var i = 0; i < line.widgets.length; ++i) {
                            var widget = line.widgets[i];
                            if (widget.node == n.firstChild) {
                                if (!widget.above && !insertBefore)
                                    insertBefore = n;
                                positionLineWidget(widget, n, reuse, dims);
                                ++widgetsSeen;
                                break;
                            }
                        }
                        if (i == line.widgets.length) {
                            isOk = false;
                            break;
                        }
                    }
                }
                reuse.insertBefore(lineElement, insertBefore);
                if (isOk && widgetsSeen == line.widgets.length) {
                    wrap = reuse;
                    reuse.className = line.wrapClass || '';
                }
            }
            if (!wrap) {
                wrap = elt('div', null, line.wrapClass, 'position: relative');
                wrap.appendChild(lineElement);
            }
            if (bgClass)
                wrap.insertBefore(elt('div', null, bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
            if (cm.options.lineNumbers || markers) {
                var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
                if (cm.options.fixedGutter)
                    (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
                if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
                    wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
                if (markers)
                    for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                        if (found)
                            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
                    }
            }
            if (ie_lt8)
                wrap.style.zIndex = 2;
            if (line.widgets && wrap != reuse)
                for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
                    if (!widget.handleMouseEvents)
                        node.ignoreEvents = true;
                    positionLineWidget(widget, node, wrap, dims);
                    if (widget.above)
                        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
                    else
                        wrap.appendChild(node);
                    signalLater(widget, 'redraw');
                }
            return wrap;
        }
        function positionLineWidget(widget, node, wrap, dims) {
            if (widget.noHScroll) {
                (wrap.alignable || (wrap.alignable = [])).push(node);
                var width = dims.wrapperWidth;
                node.style.left = dims.fixedPos + 'px';
                if (!widget.coverGutter) {
                    width -= dims.gutterTotalWidth;
                    node.style.paddingLeft = dims.gutterTotalWidth + 'px';
                }
                node.style.width = width + 'px';
            }
            if (widget.coverGutter) {
                node.style.zIndex = 5;
                node.style.position = 'relative';
                if (!widget.noHScroll)
                    node.style.marginLeft = -dims.gutterTotalWidth + 'px';
            }
        }
        function updateSelection(cm) {
            var display = cm.display;
            var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
            if (collapsed || cm.options.showCursorWhenSelecting)
                updateSelectionCursor(cm);
            else
                display.cursor.style.display = display.otherCursor.style.display = 'none';
            if (!collapsed)
                updateSelectionRange(cm);
            else
                display.selectionDiv.style.display = 'none';
            if (cm.options.moveInputWithCursor) {
                var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
                var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
                display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
                display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
            }
        }
        function updateSelectionCursor(cm) {
            var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
            display.cursor.style.left = pos.left + 'px';
            display.cursor.style.top = pos.top + 'px';
            display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
            display.cursor.style.display = '';
            if (pos.other) {
                display.otherCursor.style.display = '';
                display.otherCursor.style.left = pos.other.left + 'px';
                display.otherCursor.style.top = pos.other.top + 'px';
                display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
            } else {
                display.otherCursor.style.display = 'none';
            }
        }
        function updateSelectionRange(cm) {
            var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
            var fragment = document.createDocumentFragment();
            var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
            function add(left, top, width, bottom) {
                if (top < 0)
                    top = 0;
                fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
            }
            function drawForLine(line, fromArg, toArg) {
                var lineObj = getLine(doc, line);
                var lineLen = lineObj.text.length;
                var start, end;
                function coords(ch, bias) {
                    return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
                }
                iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
                    var leftPos = coords(from, 'left'), rightPos, left, right;
                    if (from == to) {
                        rightPos = leftPos;
                        left = right = leftPos.left;
                    } else {
                        rightPos = coords(to - 1, 'right');
                        if (dir == 'rtl') {
                            var tmp = leftPos;
                            leftPos = rightPos;
                            rightPos = tmp;
                        }
                        left = leftPos.left;
                        right = rightPos.right;
                    }
                    if (fromArg == null && from == 0)
                        left = pl;
                    if (rightPos.top - leftPos.top > 3) {
                        add(left, leftPos.top, null, leftPos.bottom);
                        left = pl;
                        if (leftPos.bottom < rightPos.top)
                            add(left, leftPos.bottom, null, rightPos.top);
                    }
                    if (toArg == null && to == lineLen)
                        right = clientWidth;
                    if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
                        start = leftPos;
                    if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
                        end = rightPos;
                    if (left < pl + 1)
                        left = pl;
                    add(left, rightPos.top, right - left, rightPos.bottom);
                });
                return {
                    start: start,
                    end: end
                };
            }
            if (sel.from.line == sel.to.line) {
                drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
            } else {
                var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
                var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
                var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
                var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
                if (singleVLine) {
                    if (leftEnd.top < rightStart.top - 2) {
                        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                        add(pl, rightStart.top, rightStart.left, rightStart.bottom);
                    } else {
                        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                    }
                }
                if (leftEnd.bottom < rightStart.top)
                    add(pl, leftEnd.bottom, null, rightStart.top);
            }
            removeChildrenAndAdd(display.selectionDiv, fragment);
            display.selectionDiv.style.display = '';
        }
        function restartBlink(cm) {
            if (!cm.state.focused)
                return;
            var display = cm.display;
            clearInterval(display.blinker);
            var on = true;
            display.cursor.style.visibility = display.otherCursor.style.visibility = '';
            if (cm.options.cursorBlinkRate > 0)
                display.blinker = setInterval(function () {
                    display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
                }, cm.options.cursorBlinkRate);
        }
        function startWorker(cm, time) {
            if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
                cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
        function highlightWorker(cm) {
            var doc = cm.doc;
            if (doc.frontier < doc.first)
                doc.frontier = doc.first;
            if (doc.frontier >= cm.display.showingTo)
                return;
            var end = +new Date() + cm.options.workTime;
            var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
            var changed = [], prevChange;
            doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
                if (doc.frontier >= cm.display.showingFrom) {
                    var oldStyles = line.styles;
                    line.styles = highlightLine(cm, line, state);
                    var ischange = !oldStyles || oldStyles.length != line.styles.length;
                    for (var i = 0; !ischange && i < oldStyles.length; ++i)
                        ischange = oldStyles[i] != line.styles[i];
                    if (ischange) {
                        if (prevChange && prevChange.end == doc.frontier)
                            prevChange.end++;
                        else
                            changed.push(prevChange = {
                                start: doc.frontier,
                                end: doc.frontier + 1
                            });
                    }
                    line.stateAfter = copyState(doc.mode, state);
                } else {
                    processLine(cm, line, state);
                    line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                }
                ++doc.frontier;
                if (+new Date() > end) {
                    startWorker(cm, cm.options.workDelay);
                    return true;
                }
            });
            if (changed.length)
                operation(cm, function () {
                    for (var i = 0; i < changed.length; ++i)
                        regChange(this, changed[i].start, changed[i].end);
                })();
        }
        function findStartLine(cm, n, precise) {
            var minindent, minline, doc = cm.doc;
            var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
            for (var search = n; search > lim; --search) {
                if (search <= doc.first)
                    return doc.first;
                var line = getLine(doc, search - 1);
                if (line.stateAfter && (!precise || search <= doc.frontier))
                    return search;
                var indented = countColumn(line.text, null, cm.options.tabSize);
                if (minline == null || minindent > indented) {
                    minline = search - 1;
                    minindent = indented;
                }
            }
            return minline;
        }
        function getStateBefore(cm, n, precise) {
            var doc = cm.doc, display = cm.display;
            if (!doc.mode.startState)
                return true;
            var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
            if (!state)
                state = startState(doc.mode);
            else
                state = copyState(doc.mode, state);
            doc.iter(pos, n, function (line) {
                processLine(cm, line, state);
                var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
                line.stateAfter = save ? copyState(doc.mode, state) : null;
                ++pos;
            });
            if (precise)
                doc.frontier = pos;
            return state;
        }
        function paddingTop(display) {
            return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
            return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingLeft(display) {
            var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
            return e.offsetLeft;
        }
        function measureChar(cm, line, ch, data, bias) {
            var dir = -1;
            data = data || measureLine(cm, line);
            if (data.crude) {
                var left = data.left + ch * data.width;
                return {
                    left: left,
                    right: left + data.width,
                    top: data.top,
                    bottom: data.bottom
                };
            }
            for (var pos = ch;; pos += dir) {
                var r = data[pos];
                if (r)
                    break;
                if (dir < 0 && pos == 0)
                    dir = 1;
            }
            bias = pos > ch ? 'left' : pos < ch ? 'right' : bias;
            if (bias == 'left' && r.leftSide)
                r = r.leftSide;
            else if (bias == 'right' && r.rightSide)
                r = r.rightSide;
            return {
                left: pos < ch ? r.right : r.left,
                right: pos > ch ? r.left : r.right,
                top: r.top,
                bottom: r.bottom
            };
        }
        function findCachedMeasurement(cm, line) {
            var cache = cm.display.measureLineCache;
            for (var i = 0; i < cache.length; ++i) {
                var memo = cache[i];
                if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.wrapClass)
                    return memo;
            }
        }
        function clearCachedMeasurement(cm, line) {
            var exists = findCachedMeasurement(cm, line);
            if (exists)
                exists.text = exists.measure = exists.markedSpans = null;
        }
        function measureLine(cm, line) {
            var cached = findCachedMeasurement(cm, line);
            if (cached)
                return cached.measure;
            var measure = measureLineInner(cm, line);
            var cache = cm.display.measureLineCache;
            var memo = {
                    text: line.text,
                    width: cm.display.scroller.clientWidth,
                    markedSpans: line.markedSpans,
                    measure: measure,
                    classes: line.textClass + '|' + line.wrapClass
                };
            if (cache.length == 16)
                cache[++cm.display.measureLineCachePos % 16] = memo;
            else
                cache.push(memo);
            return measure;
        }
        function measureLineInner(cm, line) {
            if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)
                return crudelyMeasureLine(cm, line);
            var display = cm.display, measure = emptyArray(line.text.length);
            var pre = buildLineContent(cm, line, measure, true).pre;
            if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
                var fragment = document.createDocumentFragment();
                var chunk = 10, n = pre.childNodes.length;
                for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
                    var wrap = elt('div', null, null, 'display: inline-block');
                    for (var j = 0; j < chunk && n; ++j) {
                        wrap.appendChild(pre.firstChild);
                        --n;
                    }
                    fragment.appendChild(wrap);
                }
                pre.appendChild(fragment);
            }
            removeChildrenAndAdd(display.measure, pre);
            var outer = getRect(display.lineDiv);
            var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
            if (ie_lt9 && display.measure.first != pre)
                removeChildrenAndAdd(display.measure, pre);
            function measureRect(rect) {
                var top = rect.top - outer.top, bot = rect.bottom - outer.top;
                if (bot > maxBot)
                    bot = maxBot;
                if (top < 0)
                    top = 0;
                for (var i = vranges.length - 2; i >= 0; i -= 2) {
                    var rtop = vranges[i], rbot = vranges[i + 1];
                    if (rtop > bot || rbot < top)
                        continue;
                    if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
                        vranges[i] = Math.min(top, rtop);
                        vranges[i + 1] = Math.max(bot, rbot);
                        break;
                    }
                }
                if (i < 0) {
                    i = vranges.length;
                    vranges.push(top, bot);
                }
                return {
                    left: rect.left - outer.left,
                    right: rect.right - outer.left,
                    top: i,
                    bottom: null
                };
            }
            function finishRect(rect) {
                rect.bottom = vranges[rect.top + 1];
                rect.top = vranges[rect.top];
            }
            for (var i = 0, cur; i < measure.length; ++i)
                if (cur = measure[i]) {
                    var node = cur, rect = null;
                    if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
                        if (cur.firstChild.nodeType == 1)
                            node = cur.firstChild;
                        var rects = node.getClientRects();
                        if (rects.length > 1) {
                            rect = data[i] = measureRect(rects[0]);
                            rect.rightSide = measureRect(rects[rects.length - 1]);
                        }
                    }
                    if (!rect)
                        rect = data[i] = measureRect(getRect(node));
                    if (cur.measureRight)
                        rect.right = getRect(cur.measureRight).left;
                    if (cur.leftSide)
                        rect.leftSide = measureRect(getRect(cur.leftSide));
                }
            removeChildren(cm.display.measure);
            for (var i = 0, cur; i < data.length; ++i)
                if (cur = data[i]) {
                    finishRect(cur);
                    if (cur.leftSide)
                        finishRect(cur.leftSide);
                    if (cur.rightSide)
                        finishRect(cur.rightSide);
                }
            return data;
        }
        function crudelyMeasureLine(cm, line) {
            var copy = new Line(line.text.slice(0, 100), null);
            if (line.textClass)
                copy.textClass = line.textClass;
            var measure = measureLineInner(cm, copy);
            var left = measureChar(cm, copy, 0, measure, 'left');
            var right = measureChar(cm, copy, 99, measure, 'right');
            return {
                crude: true,
                top: left.top,
                left: left.left,
                bottom: left.bottom,
                width: (right.right - left.left) / 100
            };
        }
        function measureLineWidth(cm, line) {
            var hasBadSpan = false;
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans; ++i) {
                    var sp = line.markedSpans[i];
                    if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
                        hasBadSpan = true;
                }
            var cached = !hasBadSpan && findCachedMeasurement(cm, line);
            if (cached || line.text.length >= cm.options.crudeMeasuringFrom)
                return measureChar(cm, line, line.text.length, cached && cached.measure, 'right').right;
            var pre = buildLineContent(cm, line, null, true).pre;
            var end = pre.appendChild(zeroWidthElement(cm.display.measure));
            removeChildrenAndAdd(cm.display.measure, pre);
            return getRect(end).right - getRect(cm.display.lineDiv).left;
        }
        function clearCaches(cm) {
            cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
            cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
            if (!cm.options.lineWrapping)
                cm.display.maxLineChanged = true;
            cm.display.lineNumChars = null;
        }
        function pageScrollX() {
            return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
        }
        function pageScrollY() {
            return window.pageYOffset || (document.documentElement || document.body).scrollTop;
        }
        function intoCoordSystem(cm, lineObj, rect, context) {
            if (lineObj.widgets)
                for (var i = 0; i < lineObj.widgets.length; ++i)
                    if (lineObj.widgets[i].above) {
                        var size = widgetHeight(lineObj.widgets[i]);
                        rect.top += size;
                        rect.bottom += size;
                    }
            if (context == 'line')
                return rect;
            if (!context)
                context = 'local';
            var yOff = heightAtLine(cm, lineObj);
            if (context == 'local')
                yOff += paddingTop(cm.display);
            else
                yOff -= cm.display.viewOffset;
            if (context == 'page' || context == 'window') {
                var lOff = getRect(cm.display.lineSpace);
                yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
                var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
                rect.left += xOff;
                rect.right += xOff;
            }
            rect.top += yOff;
            rect.bottom += yOff;
            return rect;
        }
        function fromCoordSystem(cm, coords, context) {
            if (context == 'div')
                return coords;
            var left = coords.left, top = coords.top;
            if (context == 'page') {
                left -= pageScrollX();
                top -= pageScrollY();
            } else if (context == 'local' || !context) {
                var localBox = getRect(cm.display.sizer);
                left += localBox.left;
                top += localBox.top;
            }
            var lineSpaceBox = getRect(cm.display.lineSpace);
            return {
                left: left - lineSpaceBox.left,
                top: top - lineSpaceBox.top
            };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
            if (!lineObj)
                lineObj = getLine(cm.doc, pos.line);
            return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, measurement) {
            lineObj = lineObj || getLine(cm.doc, pos.line);
            if (!measurement)
                measurement = measureLine(cm, lineObj);
            function get(ch, right) {
                var m = measureChar(cm, lineObj, ch, measurement, right ? 'right' : 'left');
                if (right)
                    m.left = m.right;
                else
                    m.right = m.left;
                return intoCoordSystem(cm, lineObj, m, context);
            }
            function getBidi(ch, partPos) {
                var part = order[partPos], right = part.level % 2;
                if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
                    part = order[--partPos];
                    ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
                    right = true;
                } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
                    part = order[++partPos];
                    ch = bidiLeft(part) - part.level % 2;
                    right = false;
                }
                if (right && ch == part.to && ch > part.from)
                    return get(ch - 1);
                return get(ch, right);
            }
            var order = getOrder(lineObj), ch = pos.ch;
            if (!order)
                return get(ch);
            var partPos = getBidiPartAt(order, ch);
            var val = getBidi(ch, partPos);
            if (bidiOther != null)
                val.other = getBidi(ch, bidiOther);
            return val;
        }
        function PosWithInfo(line, ch, outside, xRel) {
            var pos = new Pos(line, ch);
            pos.xRel = xRel;
            if (outside)
                pos.outside = true;
            return pos;
        }
        function coordsChar(cm, x, y) {
            var doc = cm.doc;
            y += cm.display.viewOffset;
            if (y < 0)
                return PosWithInfo(doc.first, 0, true, -1);
            var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
            if (lineNo > last)
                return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
            if (x < 0)
                x = 0;
            for (;;) {
                var lineObj = getLine(doc, lineNo);
                var found = coordsCharInner(cm, lineObj, lineNo, x, y);
                var merged = collapsedSpanAtEnd(lineObj);
                var mergedPos = merged && merged.find();
                if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                    lineNo = mergedPos.to.line;
                else
                    return found;
            }
        }
        function coordsCharInner(cm, lineObj, lineNo, x, y) {
            var innerOff = y - heightAtLine(cm, lineObj);
            var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
            var measurement = measureLine(cm, lineObj);
            function getX(ch) {
                var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
                wrongLine = true;
                if (innerOff > sp.bottom)
                    return sp.left - adjust;
                else if (innerOff < sp.top)
                    return sp.left + adjust;
                else
                    wrongLine = false;
                return sp.left;
            }
            var bidi = getOrder(lineObj), dist = lineObj.text.length;
            var from = lineLeft(lineObj), to = lineRight(lineObj);
            var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
            if (x > toX)
                return PosWithInfo(lineNo, to, toOutside, 1);
            for (;;) {
                if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                    var ch = x < fromX || x - fromX <= toX - x ? from : to;
                    var xDiff = x - (ch == from ? fromX : toX);
                    while (isExtendingChar.test(lineObj.text.charAt(ch)))
                        ++ch;
                    var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);
                    return pos;
                }
                var step = Math.ceil(dist / 2), middle = from + step;
                if (bidi) {
                    middle = from;
                    for (var i = 0; i < step; ++i)
                        middle = moveVisually(lineObj, middle, 1);
                }
                var middleX = getX(middle);
                if (middleX > x) {
                    to = middle;
                    toX = middleX;
                    if (toOutside = wrongLine)
                        toX += 1000;
                    dist = step;
                } else {
                    from = middle;
                    fromX = middleX;
                    fromOutside = wrongLine;
                    dist -= step;
                }
            }
        }
        var measureText;
        function textHeight(display) {
            if (display.cachedTextHeight != null)
                return display.cachedTextHeight;
            if (measureText == null) {
                measureText = elt('pre');
                for (var i = 0; i < 49; ++i) {
                    measureText.appendChild(document.createTextNode('x'));
                    measureText.appendChild(elt('br'));
                }
                measureText.appendChild(document.createTextNode('x'));
            }
            removeChildrenAndAdd(display.measure, measureText);
            var height = measureText.offsetHeight / 50;
            if (height > 3)
                display.cachedTextHeight = height;
            removeChildren(display.measure);
            return height || 1;
        }
        function charWidth(display) {
            if (display.cachedCharWidth != null)
                return display.cachedCharWidth;
            var anchor = elt('span', 'x');
            var pre = elt('pre', [anchor]);
            removeChildrenAndAdd(display.measure, pre);
            var width = anchor.offsetWidth;
            if (width > 2)
                display.cachedCharWidth = width;
            return width || 10;
        }
        var nextOpId = 0;
        function startOperation(cm) {
            cm.curOp = {
                changes: [],
                forceUpdate: false,
                updateInput: null,
                userSelChange: null,
                textChanged: null,
                selectionChanged: false,
                cursorActivity: false,
                updateMaxLine: false,
                updateScrollPos: false,
                id: ++nextOpId
            };
            if (!delayedCallbackDepth++)
                delayedCallbacks = [];
        }
        function endOperation(cm) {
            var op = cm.curOp, doc = cm.doc, display = cm.display;
            cm.curOp = null;
            if (op.updateMaxLine)
                computeMaxLength(cm);
            if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
                var width = measureLineWidth(cm, display.maxLine);
                display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
                display.maxLineChanged = false;
                var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
                if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
                    setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
            }
            var newScrollPos, updated;
            if (op.updateScrollPos) {
                newScrollPos = op.updateScrollPos;
            } else if (op.selectionChanged && display.scroller.clientHeight) {
                var coords = cursorCoords(cm, doc.sel.head);
                newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
            }
            if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {
                updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);
                if (cm.display.scroller.offsetHeight)
                    cm.doc.scrollTop = cm.display.scroller.scrollTop;
            }
            if (!updated && op.selectionChanged)
                updateSelection(cm);
            if (op.updateScrollPos) {
                display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
                display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
                alignHorizontally(cm);
                if (op.scrollToPos)
                    scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
            } else if (newScrollPos) {
                scrollCursorIntoView(cm);
            }
            if (op.selectionChanged)
                restartBlink(cm);
            if (cm.state.focused && op.updateInput)
                resetInput(cm, op.userSelChange);
            var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
            if (hidden)
                for (var i = 0; i < hidden.length; ++i)
                    if (!hidden[i].lines.length)
                        signal(hidden[i], 'hide');
            if (unhidden)
                for (var i = 0; i < unhidden.length; ++i)
                    if (unhidden[i].lines.length)
                        signal(unhidden[i], 'unhide');
            var delayed;
            if (!--delayedCallbackDepth) {
                delayed = delayedCallbacks;
                delayedCallbacks = null;
            }
            if (op.textChanged)
                signal(cm, 'change', cm, op.textChanged);
            if (op.cursorActivity)
                signal(cm, 'cursorActivity', cm);
            if (delayed)
                for (var i = 0; i < delayed.length; ++i)
                    delayed[i]();
        }
        function operation(cm1, f) {
            return function () {
                var cm = cm1 || this, withOp = !cm.curOp;
                if (withOp)
                    startOperation(cm);
                try {
                    var result = f.apply(cm, arguments);
                } finally {
                    if (withOp)
                        endOperation(cm);
                }
                return result;
            };
        }
        function docOperation(f) {
            return function () {
                var withOp = this.cm && !this.cm.curOp, result;
                if (withOp)
                    startOperation(this.cm);
                try {
                    result = f.apply(this, arguments);
                } finally {
                    if (withOp)
                        endOperation(this.cm);
                }
                return result;
            };
        }
        function runInOp(cm, f) {
            var withOp = !cm.curOp, result;
            if (withOp)
                startOperation(cm);
            try {
                result = f();
            } finally {
                if (withOp)
                    endOperation(cm);
            }
            return result;
        }
        function regChange(cm, from, to, lendiff) {
            if (from == null)
                from = cm.doc.first;
            if (to == null)
                to = cm.doc.first + cm.doc.size;
            cm.curOp.changes.push({
                from: from,
                to: to,
                diff: lendiff
            });
        }
        function slowPoll(cm) {
            if (cm.display.pollingFast)
                return;
            cm.display.poll.set(cm.options.pollInterval, function () {
                readInput(cm);
                if (cm.state.focused)
                    slowPoll(cm);
            });
        }
        function fastPoll(cm) {
            var missed = false;
            cm.display.pollingFast = true;
            function p() {
                var changed = readInput(cm);
                if (!changed && !missed) {
                    missed = true;
                    cm.display.poll.set(60, p);
                } else {
                    cm.display.pollingFast = false;
                    slowPoll(cm);
                }
            }
            cm.display.poll.set(20, p);
        }
        function readInput(cm) {
            var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
            if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput)
                return false;
            if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
                input.value = input.value.substring(0, input.value.length - 1);
                cm.state.fakedLastChar = false;
            }
            var text = input.value;
            if (text == prevInput && posEq(sel.from, sel.to))
                return false;
            if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
                resetInput(cm, true);
                return false;
            }
            var withOp = !cm.curOp;
            if (withOp)
                startOperation(cm);
            sel.shift = false;
            var same = 0, l = Math.min(prevInput.length, text.length);
            while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
                ++same;
            var from = sel.from, to = sel.to;
            if (same < prevInput.length)
                from = Pos(from.line, from.ch - (prevInput.length - same));
            else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
            var updateInput = cm.curOp.updateInput;
            var changeEvent = {
                    from: from,
                    to: to,
                    text: splitLines(text.slice(same)),
                    origin: cm.state.pasteIncoming ? 'paste' : '+input'
                };
            makeChange(cm.doc, changeEvent, 'end');
            cm.curOp.updateInput = updateInput;
            signalLater(cm, 'inputRead', cm, changeEvent);
            if (text.length > 1000 || text.indexOf('\n') > -1)
                input.value = cm.display.prevInput = '';
            else
                cm.display.prevInput = text;
            if (withOp)
                endOperation(cm);
            cm.state.pasteIncoming = false;
            return true;
        }
        function resetInput(cm, user) {
            var minimal, selected, doc = cm.doc;
            if (!posEq(doc.sel.from, doc.sel.to)) {
                cm.display.prevInput = '';
                minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
                var content = minimal ? '-' : selected || cm.getSelection();
                cm.display.input.value = content;
                if (cm.state.focused)
                    selectInput(cm.display.input);
                if (ie && !ie_lt9)
                    cm.display.inputHasSelection = content;
            } else if (user) {
                cm.display.prevInput = cm.display.input.value = '';
                if (ie && !ie_lt9)
                    cm.display.inputHasSelection = null;
            }
            cm.display.inaccurateSelection = minimal;
        }
        function focusInput(cm) {
            if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
                cm.display.input.focus();
        }
        function isReadOnly(cm) {
            return cm.options.readOnly || cm.doc.cantEdit;
        }
        function registerEventHandlers(cm) {
            var d = cm.display;
            on(d.scroller, 'mousedown', operation(cm, onMouseDown));
            if (ie)
                on(d.scroller, 'dblclick', operation(cm, function (e) {
                    if (signalDOMEvent(cm, e))
                        return;
                    var pos = posFromMouse(cm, e);
                    if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
                        return;
                    e_preventDefault(e);
                    var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
                    extendSelection(cm.doc, word.from, word.to);
                }));
            else
                on(d.scroller, 'dblclick', function (e) {
                    signalDOMEvent(cm, e) || e_preventDefault(e);
                });
            on(d.lineSpace, 'selectstart', function (e) {
                if (!eventInWidget(d, e))
                    e_preventDefault(e);
            });
            if (!captureMiddleClick)
                on(d.scroller, 'contextmenu', function (e) {
                    onContextMenu(cm, e);
                });
            on(d.scroller, 'scroll', function () {
                if (d.scroller.clientHeight) {
                    setScrollTop(cm, d.scroller.scrollTop);
                    setScrollLeft(cm, d.scroller.scrollLeft, true);
                    signal(cm, 'scroll', cm);
                }
            });
            on(d.scrollbarV, 'scroll', function () {
                if (d.scroller.clientHeight)
                    setScrollTop(cm, d.scrollbarV.scrollTop);
            });
            on(d.scrollbarH, 'scroll', function () {
                if (d.scroller.clientHeight)
                    setScrollLeft(cm, d.scrollbarH.scrollLeft);
            });
            on(d.scroller, 'mousewheel', function (e) {
                onScrollWheel(cm, e);
            });
            on(d.scroller, 'DOMMouseScroll', function (e) {
                onScrollWheel(cm, e);
            });
            function reFocus() {
                if (cm.state.focused)
                    setTimeout(bind(focusInput, cm), 0);
            }
            on(d.scrollbarH, 'mousedown', reFocus);
            on(d.scrollbarV, 'mousedown', reFocus);
            on(d.wrapper, 'scroll', function () {
                d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
            });
            var resizeTimer;
            function onResize() {
                if (resizeTimer == null)
                    resizeTimer = setTimeout(function () {
                        resizeTimer = null;
                        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
                        clearCaches(cm);
                        runInOp(cm, bind(regChange, cm));
                    }, 100);
            }
            on(window, 'resize', onResize);
            function unregister() {
                for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
                }
                if (p)
                    setTimeout(unregister, 5000);
                else
                    off(window, 'resize', onResize);
            }
            setTimeout(unregister, 5000);
            on(d.input, 'keyup', operation(cm, function (e) {
                if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                    return;
                if (e.keyCode == 16)
                    cm.doc.sel.shift = false;
            }));
            on(d.input, 'input', function () {
                if (ie && !ie_lt9 && cm.display.inputHasSelection)
                    cm.display.inputHasSelection = null;
                fastPoll(cm);
            });
            on(d.input, 'keydown', operation(cm, onKeyDown));
            on(d.input, 'keypress', operation(cm, onKeyPress));
            on(d.input, 'focus', bind(onFocus, cm));
            on(d.input, 'blur', bind(onBlur, cm));
            function drag_(e) {
                if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
                    return;
                e_stop(e);
            }
            if (cm.options.dragDrop) {
                on(d.scroller, 'dragstart', function (e) {
                    onDragStart(cm, e);
                });
                on(d.scroller, 'dragenter', drag_);
                on(d.scroller, 'dragover', drag_);
                on(d.scroller, 'drop', operation(cm, onDrop));
            }
            on(d.scroller, 'paste', function (e) {
                if (eventInWidget(d, e))
                    return;
                focusInput(cm);
                fastPoll(cm);
            });
            on(d.input, 'paste', function () {
                if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
                    var start = d.input.selectionStart, end = d.input.selectionEnd;
                    d.input.value += '$';
                    d.input.selectionStart = start;
                    d.input.selectionEnd = end;
                    cm.state.fakedLastChar = true;
                }
                cm.state.pasteIncoming = true;
                fastPoll(cm);
            });
            function prepareCopy() {
                if (d.inaccurateSelection) {
                    d.prevInput = '';
                    d.inaccurateSelection = false;
                    d.input.value = cm.getSelection();
                    selectInput(d.input);
                }
            }
            on(d.input, 'cut', prepareCopy);
            on(d.input, 'copy', prepareCopy);
            if (khtml)
                on(d.sizer, 'mouseup', function () {
                    if (document.activeElement == d.input)
                        d.input.blur();
                    focusInput(cm);
                });
        }
        function eventInWidget(display, e) {
            for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
                if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
                    return true;
            }
        }
        function posFromMouse(cm, e, liberal) {
            var display = cm.display;
            if (!liberal) {
                var target = e_target(e);
                if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller)
                    return null;
            }
            var x, y, space = getRect(display.lineSpace);
            try {
                x = e.clientX;
                y = e.clientY;
            } catch (e) {
                return null;
            }
            return coordsChar(cm, x - space.left, y - space.top);
        }
        var lastClick, lastDoubleClick;
        function onMouseDown(e) {
            if (signalDOMEvent(this, e))
                return;
            var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
            sel.shift = e.shiftKey;
            if (eventInWidget(display, e)) {
                if (!webkit) {
                    display.scroller.draggable = false;
                    setTimeout(function () {
                        display.scroller.draggable = true;
                    }, 100);
                }
                return;
            }
            if (clickInGutter(cm, e))
                return;
            var start = posFromMouse(cm, e);
            switch (e_button(e)) {
            case 3:
                if (captureMiddleClick)
                    onContextMenu.call(cm, cm, e);
                return;
            case 2:
                if (webkit)
                    cm.state.lastMiddleDown = +new Date();
                if (start)
                    extendSelection(cm.doc, start);
                setTimeout(bind(focusInput, cm), 20);
                e_preventDefault(e);
                return;
            }
            if (!start) {
                if (e_target(e) == display.scroller)
                    e_preventDefault(e);
                return;
            }
            if (!cm.state.focused)
                onFocus(cm);
            var now = +new Date(), type = 'single';
            if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
                type = 'triple';
                e_preventDefault(e);
                setTimeout(bind(focusInput, cm), 20);
                selectLine(cm, start.line);
            } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
                type = 'double';
                lastDoubleClick = {
                    time: now,
                    pos: start
                };
                e_preventDefault(e);
                var word = findWordAt(getLine(doc, start.line).text, start);
                extendSelection(cm.doc, word.from, word.to);
            } else {
                lastClick = {
                    time: now,
                    pos: start
                };
            }
            var last = start;
            if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
                var dragEnd = operation(cm, function (e2) {
                        if (webkit)
                            display.scroller.draggable = false;
                        cm.state.draggingText = false;
                        off(document, 'mouseup', dragEnd);
                        off(display.scroller, 'drop', dragEnd);
                        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                            e_preventDefault(e2);
                            extendSelection(cm.doc, start);
                            focusInput(cm);
                        }
                    });
                if (webkit)
                    display.scroller.draggable = true;
                cm.state.draggingText = dragEnd;
                if (display.scroller.dragDrop)
                    display.scroller.dragDrop();
                on(document, 'mouseup', dragEnd);
                on(display.scroller, 'drop', dragEnd);
                return;
            }
            e_preventDefault(e);
            if (type == 'single')
                extendSelection(cm.doc, clipPos(doc, start));
            var startstart = sel.from, startend = sel.to, lastPos = start;
            function doSelect(cur) {
                if (posEq(lastPos, cur))
                    return;
                lastPos = cur;
                if (type == 'single') {
                    extendSelection(cm.doc, clipPos(doc, start), cur);
                    return;
                }
                startstart = clipPos(doc, startstart);
                startend = clipPos(doc, startend);
                if (type == 'double') {
                    var word = findWordAt(getLine(doc, cur.line).text, cur);
                    if (posLess(cur, startstart))
                        extendSelection(cm.doc, word.from, startend);
                    else
                        extendSelection(cm.doc, startstart, word.to);
                } else if (type == 'triple') {
                    if (posLess(cur, startstart))
                        extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
                    else
                        extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
                }
            }
            var editorSize = getRect(display.wrapper);
            var counter = 0;
            function extend(e) {
                var curCount = ++counter;
                var cur = posFromMouse(cm, e, true);
                if (!cur)
                    return;
                if (!posEq(cur, last)) {
                    if (!cm.state.focused)
                        onFocus(cm);
                    last = cur;
                    doSelect(cur);
                    var visible = visibleLines(display, doc);
                    if (cur.line >= visible.to || cur.line < visible.from)
                        setTimeout(operation(cm, function () {
                            if (counter == curCount)
                                extend(e);
                        }), 150);
                } else {
                    var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                    if (outside)
                        setTimeout(operation(cm, function () {
                            if (counter != curCount)
                                return;
                            display.scroller.scrollTop += outside;
                            extend(e);
                        }), 50);
                }
            }
            function done(e) {
                counter = Infinity;
                e_preventDefault(e);
                focusInput(cm);
                off(document, 'mousemove', move);
                off(document, 'mouseup', up);
            }
            var move = operation(cm, function (e) {
                    if (!ie && !e_button(e))
                        done(e);
                    else
                        extend(e);
                });
            var up = operation(cm, done);
            on(document, 'mousemove', move);
            on(document, 'mouseup', up);
        }
        function gutterEvent(cm, e, type, prevent, signalfn) {
            try {
                var mX = e.clientX, mY = e.clientY;
            } catch (e) {
                return false;
            }
            if (mX >= Math.floor(getRect(cm.display.gutters).right))
                return false;
            if (prevent)
                e_preventDefault(e);
            var display = cm.display;
            var lineBox = getRect(display.lineDiv);
            if (mY > lineBox.bottom || !hasHandler(cm, type))
                return e_defaultPrevented(e);
            mY -= lineBox.top - display.viewOffset;
            for (var i = 0; i < cm.options.gutters.length; ++i) {
                var g = display.gutters.childNodes[i];
                if (g && getRect(g).right >= mX) {
                    var line = lineAtHeight(cm.doc, mY);
                    var gutter = cm.options.gutters[i];
                    signalfn(cm, type, cm, line, gutter, e);
                    return e_defaultPrevented(e);
                }
            }
        }
        function contextMenuInGutter(cm, e) {
            if (!hasHandler(cm, 'gutterContextMenu'))
                return false;
            return gutterEvent(cm, e, 'gutterContextMenu', false, signal);
        }
        function clickInGutter(cm, e) {
            return gutterEvent(cm, e, 'gutterClick', true, signalLater);
        }
        var lastDrop = 0;
        function onDrop(e) {
            var cm = this;
            if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
                return;
            e_preventDefault(e);
            if (ie)
                lastDrop = +new Date();
            var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
            if (!pos || isReadOnly(cm))
                return;
            if (files && files.length && window.FileReader && window.File) {
                var n = files.length, text = Array(n), read = 0;
                var loadFile = function (file, i) {
                    var reader = new FileReader();
                    reader.onload = function () {
                        text[i] = reader.result;
                        if (++read == n) {
                            pos = clipPos(cm.doc, pos);
                            makeChange(cm.doc, {
                                from: pos,
                                to: pos,
                                text: splitLines(text.join('\n')),
                                origin: 'paste'
                            }, 'around');
                        }
                    };
                    reader.readAsText(file);
                };
                for (var i = 0; i < n; ++i)
                    loadFile(files[i], i);
            } else {
                if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
                    cm.state.draggingText(e);
                    setTimeout(bind(focusInput, cm), 20);
                    return;
                }
                try {
                    var text = e.dataTransfer.getData('Text');
                    if (text) {
                        var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
                        setSelection(cm.doc, pos, pos);
                        if (cm.state.draggingText)
                            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
                        cm.replaceSelection(text, null, 'paste');
                        focusInput(cm);
                        onFocus(cm);
                    }
                } catch (e) {
                }
            }
        }
        function onDragStart(cm, e) {
            if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
                e_stop(e);
                return;
            }
            if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
                return;
            var txt = cm.getSelection();
            e.dataTransfer.setData('Text', txt);
            if (e.dataTransfer.setDragImage && !safari) {
                var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
                img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
                if (opera) {
                    img.width = img.height = 1;
                    cm.display.wrapper.appendChild(img);
                    img._top = img.offsetTop;
                }
                e.dataTransfer.setDragImage(img, 0, 0);
                if (opera)
                    img.parentNode.removeChild(img);
            }
        }
        function setScrollTop(cm, val) {
            if (Math.abs(cm.doc.scrollTop - val) < 2)
                return;
            cm.doc.scrollTop = val;
            if (!gecko)
                updateDisplay(cm, [], val);
            if (cm.display.scroller.scrollTop != val)
                cm.display.scroller.scrollTop = val;
            if (cm.display.scrollbarV.scrollTop != val)
                cm.display.scrollbarV.scrollTop = val;
            if (gecko)
                updateDisplay(cm, []);
            startWorker(cm, 100);
        }
        function setScrollLeft(cm, val, isScroller) {
            if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
                return;
            val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
            cm.doc.scrollLeft = val;
            alignHorizontally(cm);
            if (cm.display.scroller.scrollLeft != val)
                cm.display.scroller.scrollLeft = val;
            if (cm.display.scrollbarH.scrollLeft != val)
                cm.display.scrollbarH.scrollLeft = val;
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie)
            wheelPixelsPerUnit = -0.53;
        else if (gecko)
            wheelPixelsPerUnit = 15;
        else if (chrome)
            wheelPixelsPerUnit = -0.7;
        else if (safari)
            wheelPixelsPerUnit = -1 / 3;
        function onScrollWheel(cm, e) {
            var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
            if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
                dx = e.detail;
            if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
                dy = e.detail;
            else if (dy == null)
                dy = e.wheelDelta;
            var display = cm.display, scroll = display.scroller;
            if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
                return;
            if (dy && mac && webkit) {
                for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
                    if (cur.lineObj) {
                        cm.display.currentWheelTarget = cur;
                        break;
                    }
                }
            }
            if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
                if (dy)
                    setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
                setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
                e_preventDefault(e);
                display.wheelStartX = null;
                return;
            }
            if (dy && wheelPixelsPerUnit != null) {
                var pixels = dy * wheelPixelsPerUnit;
                var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                if (pixels < 0)
                    top = Math.max(0, top + pixels - 50);
                else
                    bot = Math.min(cm.doc.height, bot + pixels + 50);
                updateDisplay(cm, [], {
                    top: top,
                    bottom: bot
                });
            }
            if (wheelSamples < 20) {
                if (display.wheelStartX == null) {
                    display.wheelStartX = scroll.scrollLeft;
                    display.wheelStartY = scroll.scrollTop;
                    display.wheelDX = dx;
                    display.wheelDY = dy;
                    setTimeout(function () {
                        if (display.wheelStartX == null)
                            return;
                        var movedX = scroll.scrollLeft - display.wheelStartX;
                        var movedY = scroll.scrollTop - display.wheelStartY;
                        var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                        display.wheelStartX = display.wheelStartY = null;
                        if (!sample)
                            return;
                        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                        ++wheelSamples;
                    }, 200);
                } else {
                    display.wheelDX += dx;
                    display.wheelDY += dy;
                }
            }
        }
        function doHandleBinding(cm, bound, dropShift) {
            if (typeof bound == 'string') {
                bound = commands[bound];
                if (!bound)
                    return false;
            }
            if (cm.display.pollingFast && readInput(cm))
                cm.display.pollingFast = false;
            var doc = cm.doc, prevShift = doc.sel.shift, done = false;
            try {
                if (isReadOnly(cm))
                    cm.state.suppressEdits = true;
                if (dropShift)
                    doc.sel.shift = false;
                done = bound(cm) != Pass;
            } finally {
                doc.sel.shift = prevShift;
                cm.state.suppressEdits = false;
            }
            return done;
        }
        function allKeyMaps(cm) {
            var maps = cm.state.keyMaps.slice(0);
            if (cm.options.extraKeys)
                maps.push(cm.options.extraKeys);
            maps.push(cm.options.keyMap);
            return maps;
        }
        var maybeTransition;
        function handleKeyBinding(cm, e) {
            var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
            clearTimeout(maybeTransition);
            if (next && !isModifierKey(e))
                maybeTransition = setTimeout(function () {
                    if (getKeyMap(cm.options.keyMap) == startMap) {
                        cm.options.keyMap = next.call ? next.call(null, cm) : next;
                        keyMapChanged(cm);
                    }
                }, 50);
            var name = keyName(e, true), handled = false;
            if (!name)
                return false;
            var keymaps = allKeyMaps(cm);
            if (e.shiftKey) {
                handled = lookupKey('Shift-' + name, keymaps, function (b) {
                    return doHandleBinding(cm, b, true);
                }) || lookupKey(name, keymaps, function (b) {
                    if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
                        return doHandleBinding(cm, b);
                });
            } else {
                handled = lookupKey(name, keymaps, function (b) {
                    return doHandleBinding(cm, b);
                });
            }
            if (handled) {
                e_preventDefault(e);
                restartBlink(cm);
                if (ie_lt9) {
                    e.oldKeyCode = e.keyCode;
                    e.keyCode = 0;
                }
                signalLater(cm, 'keyHandled', cm, name, e);
            }
            return handled;
        }
        function handleCharBinding(cm, e, ch) {
            var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
                    return doHandleBinding(cm, b, true);
                });
            if (handled) {
                e_preventDefault(e);
                restartBlink(cm);
                signalLater(cm, 'keyHandled', cm, '\'' + ch + '\'', e);
            }
            return handled;
        }
        var lastStoppedKey = null;
        function onKeyDown(e) {
            var cm = this;
            if (!cm.state.focused)
                onFocus(cm);
            if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                return;
            if (ie && e.keyCode == 27)
                e.returnValue = false;
            var code = e.keyCode;
            cm.doc.sel.shift = code == 16 || e.shiftKey;
            var handled = handleKeyBinding(cm, e);
            if (opera) {
                lastStoppedKey = handled ? code : null;
                if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
                    cm.replaceSelection('');
            }
        }
        function onKeyPress(e) {
            var cm = this;
            if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                return;
            var keyCode = e.keyCode, charCode = e.charCode;
            if (opera && keyCode == lastStoppedKey) {
                lastStoppedKey = null;
                e_preventDefault(e);
                return;
            }
            if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
                return;
            var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
            if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
                setTimeout(operation(cm, function () {
                    indentLine(cm, cm.doc.sel.to.line, 'smart');
                }), 75);
            if (handleCharBinding(cm, e, ch))
                return;
            if (ie && !ie_lt9)
                cm.display.inputHasSelection = null;
            fastPoll(cm);
        }
        function onFocus(cm) {
            if (cm.options.readOnly == 'nocursor')
                return;
            if (!cm.state.focused) {
                signal(cm, 'focus', cm);
                cm.state.focused = true;
                if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
                    cm.display.wrapper.className += ' CodeMirror-focused';
                if (!cm.curOp) {
                    resetInput(cm, true);
                    if (webkit)
                        setTimeout(bind(resetInput, cm, true), 0);
                }
            }
            slowPoll(cm);
            restartBlink(cm);
        }
        function onBlur(cm) {
            if (cm.state.focused) {
                signal(cm, 'blur', cm);
                cm.state.focused = false;
                cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
            }
            clearInterval(cm.display.blinker);
            setTimeout(function () {
                if (!cm.state.focused)
                    cm.doc.sel.shift = false;
            }, 150);
        }
        var detectingSelectAll;
        function onContextMenu(cm, e) {
            if (signalDOMEvent(cm, e, 'contextmenu'))
                return;
            var display = cm.display, sel = cm.doc.sel;
            if (eventInWidget(display, e) || contextMenuInGutter(cm, e))
                return;
            var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
            if (!pos || opera)
                return;
            var reset = cm.options.resetSelectionOnContextMenu;
            if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))
                operation(cm, setSelection)(cm.doc, pos, pos);
            var oldCSS = display.input.style.cssText;
            display.inputDiv.style.position = 'absolute';
            display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
            focusInput(cm);
            resetInput(cm, true);
            if (posEq(sel.from, sel.to))
                display.input.value = display.prevInput = ' ';
            function prepareSelectAllHack() {
                if (display.input.selectionStart != null) {
                    var extval = display.input.value = '\u200b' + (posEq(sel.from, sel.to) ? '' : display.input.value);
                    display.prevInput = '\u200b';
                    display.input.selectionStart = 1;
                    display.input.selectionEnd = extval.length;
                }
            }
            function rehide() {
                display.inputDiv.style.position = 'relative';
                display.input.style.cssText = oldCSS;
                if (ie_lt9)
                    display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
                slowPoll(cm);
                if (display.input.selectionStart != null) {
                    if (!ie || ie_lt9)
                        prepareSelectAllHack();
                    clearTimeout(detectingSelectAll);
                    var i = 0, poll = function () {
                            if (display.prevInput == ' ' && display.input.selectionStart == 0)
                                operation(cm, commands.selectAll)(cm);
                            else if (i++ < 10)
                                detectingSelectAll = setTimeout(poll, 500);
                            else
                                resetInput(cm);
                        };
                    detectingSelectAll = setTimeout(poll, 200);
                }
            }
            if (ie && !ie_lt9)
                prepareSelectAllHack();
            if (captureMiddleClick) {
                e_stop(e);
                var mouseup = function () {
                    off(window, 'mouseup', mouseup);
                    setTimeout(rehide, 20);
                };
                on(window, 'mouseup', mouseup);
            } else {
                setTimeout(rehide, 50);
            }
        }
        var changeEnd = CodeMirror.changeEnd = function (change) {
                if (!change.text)
                    return change.to;
                return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
            };
        function clipPostChange(doc, change, pos) {
            if (!posLess(change.from, pos))
                return clipPos(doc, pos);
            var diff = change.text.length - 1 - (change.to.line - change.from.line);
            if (pos.line > change.to.line + diff) {
                var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
                if (preLine > lastLine)
                    return Pos(lastLine, getLine(doc, lastLine).text.length);
                return clipToLen(pos, getLine(doc, preLine).text.length);
            }
            if (pos.line == change.to.line + diff)
                return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
            var inside = pos.line - change.from.line;
            return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
        }
        function computeSelAfterChange(doc, change, hint) {
            if (hint && typeof hint == 'object')
                return {
                    anchor: clipPostChange(doc, change, hint.anchor),
                    head: clipPostChange(doc, change, hint.head)
                };
            if (hint == 'start')
                return {
                    anchor: change.from,
                    head: change.from
                };
            var end = changeEnd(change);
            if (hint == 'around')
                return {
                    anchor: change.from,
                    head: end
                };
            if (hint == 'end')
                return {
                    anchor: end,
                    head: end
                };
            var adjustPos = function (pos) {
                if (posLess(pos, change.from))
                    return pos;
                if (!posLess(change.to, pos))
                    return end;
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                if (pos.line == change.to.line)
                    ch += end.ch - change.to.ch;
                return Pos(line, ch);
            };
            return {
                anchor: adjustPos(doc.sel.anchor),
                head: adjustPos(doc.sel.head)
            };
        }
        function filterChange(doc, change, update) {
            var obj = {
                    canceled: false,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function () {
                        this.canceled = true;
                    }
                };
            if (update)
                obj.update = function (from, to, text, origin) {
                    if (from)
                        this.from = clipPos(doc, from);
                    if (to)
                        this.to = clipPos(doc, to);
                    if (text)
                        this.text = text;
                    if (origin !== undefined)
                        this.origin = origin;
                };
            signal(doc, 'beforeChange', doc, obj);
            if (doc.cm)
                signal(doc.cm, 'beforeChange', doc.cm, obj);
            if (obj.canceled)
                return null;
            return {
                from: obj.from,
                to: obj.to,
                text: obj.text,
                origin: obj.origin
            };
        }
        function makeChange(doc, change, selUpdate, ignoreReadOnly) {
            if (doc.cm) {
                if (!doc.cm.curOp)
                    return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
                if (doc.cm.state.suppressEdits)
                    return;
            }
            if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
                change = filterChange(doc, change, true);
                if (!change)
                    return;
            }
            var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
            if (split) {
                for (var i = split.length - 1; i >= 1; --i)
                    makeChangeNoReadonly(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: ['']
                    });
                if (split.length)
                    makeChangeNoReadonly(doc, {
                        from: split[0].from,
                        to: split[0].to,
                        text: change.text
                    }, selUpdate);
            } else {
                makeChangeNoReadonly(doc, change, selUpdate);
            }
        }
        function makeChangeNoReadonly(doc, change, selUpdate) {
            if (change.text.length == 1 && change.text[0] == '' && posEq(change.from, change.to))
                return;
            var selAfter = computeSelAfterChange(doc, change, selUpdate);
            addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
            makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
            var rebased = [];
            linkedDocs(doc, function (doc, sharedHist) {
                if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
            });
        }
        function makeChangeFromHistory(doc, type) {
            if (doc.cm && doc.cm.state.suppressEdits)
                return;
            var hist = doc.history;
            var event = (type == 'undo' ? hist.done : hist.undone).pop();
            if (!event)
                return;
            var anti = {
                    changes: [],
                    anchorBefore: event.anchorAfter,
                    headBefore: event.headAfter,
                    anchorAfter: event.anchorBefore,
                    headAfter: event.headBefore,
                    generation: hist.generation
                };
            (type == 'undo' ? hist.undone : hist.done).push(anti);
            hist.generation = event.generation || ++hist.maxGeneration;
            var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
            for (var i = event.changes.length - 1; i >= 0; --i) {
                var change = event.changes[i];
                change.origin = type;
                if (filter && !filterChange(doc, change, false)) {
                    (type == 'undo' ? hist.done : hist.undone).length = 0;
                    return;
                }
                anti.changes.push(historyChangeFromChange(doc, change));
                var after = i ? computeSelAfterChange(doc, change, null) : {
                        anchor: event.anchorBefore,
                        head: event.headBefore
                    };
                makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
                var rebased = [];
                linkedDocs(doc, function (doc, sharedHist) {
                    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                        rebaseHist(doc.history, change);
                        rebased.push(doc.history);
                    }
                    makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                });
            }
        }
        function shiftDoc(doc, distance) {
            function shiftPos(pos) {
                return Pos(pos.line + distance, pos.ch);
            }
            doc.first += distance;
            if (doc.cm)
                regChange(doc.cm, doc.first, doc.first, distance);
            doc.sel.head = shiftPos(doc.sel.head);
            doc.sel.anchor = shiftPos(doc.sel.anchor);
            doc.sel.from = shiftPos(doc.sel.from);
            doc.sel.to = shiftPos(doc.sel.to);
        }
        function makeChangeSingleDoc(doc, change, selAfter, spans) {
            if (doc.cm && !doc.cm.curOp)
                return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
            if (change.to.line < doc.first) {
                shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                return;
            }
            if (change.from.line > doc.lastLine())
                return;
            if (change.from.line < doc.first) {
                var shift = change.text.length - 1 - (doc.first - change.from.line);
                shiftDoc(doc, shift);
                change = {
                    from: Pos(doc.first, 0),
                    to: Pos(change.to.line + shift, change.to.ch),
                    text: [lst(change.text)],
                    origin: change.origin
                };
            }
            var last = doc.lastLine();
            if (change.to.line > last) {
                change = {
                    from: change.from,
                    to: Pos(last, getLine(doc, last).text.length),
                    text: [change.text[0]],
                    origin: change.origin
                };
            }
            change.removed = getBetween(doc, change.from, change.to);
            if (!selAfter)
                selAfter = computeSelAfterChange(doc, change, null);
            if (doc.cm)
                makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
            else
                updateDoc(doc, change, spans, selAfter);
        }
        function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
            var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
            var recomputeMaxLength = false, checkWidthStart = from.line;
            if (!cm.options.lineWrapping) {
                checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
                doc.iter(checkWidthStart, to.line + 1, function (line) {
                    if (line == display.maxLine) {
                        recomputeMaxLength = true;
                        return true;
                    }
                });
            }
            if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
                cm.curOp.cursorActivity = true;
            updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
            if (!cm.options.lineWrapping) {
                doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
                    var len = lineLength(doc, line);
                    if (len > display.maxLineLength) {
                        display.maxLine = line;
                        display.maxLineLength = len;
                        display.maxLineChanged = true;
                        recomputeMaxLength = false;
                    }
                });
                if (recomputeMaxLength)
                    cm.curOp.updateMaxLine = true;
            }
            doc.frontier = Math.min(doc.frontier, from.line);
            startWorker(cm, 400);
            var lendiff = change.text.length - (to.line - from.line) - 1;
            regChange(cm, from.line, to.line + 1, lendiff);
            if (hasHandler(cm, 'change')) {
                var changeObj = {
                        from: from,
                        to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                if (cm.curOp.textChanged) {
                    for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
                    }
                    cur.next = changeObj;
                } else
                    cm.curOp.textChanged = changeObj;
            }
        }
        function replaceRange(doc, code, from, to, origin) {
            if (!to)
                to = from;
            if (posLess(to, from)) {
                var tmp = to;
                to = from;
                from = tmp;
            }
            if (typeof code == 'string')
                code = splitLines(code);
            makeChange(doc, {
                from: from,
                to: to,
                text: code,
                origin: origin
            }, null);
        }
        function Pos(line, ch) {
            if (!(this instanceof Pos))
                return new Pos(line, ch);
            this.line = line;
            this.ch = ch;
        }
        CodeMirror.Pos = Pos;
        function posEq(a, b) {
            return a.line == b.line && a.ch == b.ch;
        }
        function posLess(a, b) {
            return a.line < b.line || a.line == b.line && a.ch < b.ch;
        }
        function copyPos(x) {
            return Pos(x.line, x.ch);
        }
        function clipLine(doc, n) {
            return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
        }
        function clipPos(doc, pos) {
            if (pos.line < doc.first)
                return Pos(doc.first, 0);
            var last = doc.first + doc.size - 1;
            if (pos.line > last)
                return Pos(last, getLine(doc, last).text.length);
            return clipToLen(pos, getLine(doc, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
            var ch = pos.ch;
            if (ch == null || ch > linelen)
                return Pos(pos.line, linelen);
            else if (ch < 0)
                return Pos(pos.line, 0);
            else
                return pos;
        }
        function isLine(doc, l) {
            return l >= doc.first && l < doc.first + doc.size;
        }
        function extendSelection(doc, pos, other, bias) {
            if (doc.sel.shift || doc.sel.extend) {
                var anchor = doc.sel.anchor;
                if (other) {
                    var posBefore = posLess(pos, anchor);
                    if (posBefore != posLess(other, anchor)) {
                        anchor = pos;
                        pos = other;
                    } else if (posBefore != posLess(pos, other)) {
                        pos = other;
                    }
                }
                setSelection(doc, anchor, pos, bias);
            } else {
                setSelection(doc, pos, other || pos, bias);
            }
            if (doc.cm)
                doc.cm.curOp.userSelChange = true;
        }
        function filterSelectionChange(doc, anchor, head) {
            var obj = {
                    anchor: anchor,
                    head: head
                };
            signal(doc, 'beforeSelectionChange', doc, obj);
            if (doc.cm)
                signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
            obj.anchor = clipPos(doc, obj.anchor);
            obj.head = clipPos(doc, obj.head);
            return obj;
        }
        function setSelection(doc, anchor, head, bias, checkAtomic) {
            if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
                var filtered = filterSelectionChange(doc, anchor, head);
                head = filtered.head;
                anchor = filtered.anchor;
            }
            var sel = doc.sel;
            sel.goalColumn = null;
            if (bias == null)
                bias = posLess(head, sel.head) ? -1 : 1;
            if (checkAtomic || !posEq(anchor, sel.anchor))
                anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
            if (checkAtomic || !posEq(head, sel.head))
                head = skipAtomic(doc, head, bias, checkAtomic != 'push');
            if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
                return;
            sel.anchor = anchor;
            sel.head = head;
            var inv = posLess(head, anchor);
            sel.from = inv ? head : anchor;
            sel.to = inv ? anchor : head;
            if (doc.cm)
                doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
            signalLater(doc, 'cursorActivity', doc);
        }
        function reCheckSelection(cm) {
            setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
        }
        function skipAtomic(doc, pos, bias, mayClear) {
            var flipped = false, curPos = pos;
            var dir = bias || 1;
            doc.cantEdit = false;
            search:
                for (;;) {
                    var line = getLine(doc, curPos.line);
                    if (line.markedSpans) {
                        for (var i = 0; i < line.markedSpans.length; ++i) {
                            var sp = line.markedSpans[i], m = sp.marker;
                            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                                if (mayClear) {
                                    signal(m, 'beforeCursorEnter');
                                    if (m.explicitlyCleared) {
                                        if (!line.markedSpans)
                                            break;
                                        else {
                                            --i;
                                            continue;
                                        }
                                    }
                                }
                                if (!m.atomic)
                                    continue;
                                var newPos = m.find()[dir < 0 ? 'from' : 'to'];
                                if (posEq(newPos, curPos)) {
                                    newPos.ch += dir;
                                    if (newPos.ch < 0) {
                                        if (newPos.line > doc.first)
                                            newPos = clipPos(doc, Pos(newPos.line - 1));
                                        else
                                            newPos = null;
                                    } else if (newPos.ch > line.text.length) {
                                        if (newPos.line < doc.first + doc.size - 1)
                                            newPos = Pos(newPos.line + 1, 0);
                                        else
                                            newPos = null;
                                    }
                                    if (!newPos) {
                                        if (flipped) {
                                            if (!mayClear)
                                                return skipAtomic(doc, pos, bias, true);
                                            doc.cantEdit = true;
                                            return Pos(doc.first, 0);
                                        }
                                        flipped = true;
                                        newPos = pos;
                                        dir = -dir;
                                    }
                                }
                                curPos = newPos;
                                continue search;
                            }
                        }
                    }
                    return curPos;
                }
        }
        function scrollCursorIntoView(cm) {
            var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
            if (!cm.state.focused)
                return;
            var display = cm.display, box = getRect(display.sizer), doScroll = null;
            if (coords.top + box.top < 0)
                doScroll = true;
            else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
                doScroll = false;
            if (doScroll != null && !phantom) {
                var hidden = display.cursor.style.display == 'none';
                if (hidden) {
                    display.cursor.style.display = '';
                    display.cursor.style.left = coords.left + 'px';
                    display.cursor.style.top = coords.top - display.viewOffset + 'px';
                }
                display.cursor.scrollIntoView(doScroll);
                if (hidden)
                    display.cursor.style.display = 'none';
            }
        }
        function scrollPosIntoView(cm, pos, margin) {
            if (margin == null)
                margin = 0;
            for (;;) {
                var changed = false, coords = cursorCoords(cm, pos);
                var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
                var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                if (scrollPos.scrollTop != null) {
                    setScrollTop(cm, scrollPos.scrollTop);
                    if (Math.abs(cm.doc.scrollTop - startTop) > 1)
                        changed = true;
                }
                if (scrollPos.scrollLeft != null) {
                    setScrollLeft(cm, scrollPos.scrollLeft);
                    if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
                        changed = true;
                }
                if (!changed)
                    return coords;
            }
        }
        function scrollIntoView(cm, x1, y1, x2, y2) {
            var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
            if (scrollPos.scrollTop != null)
                setScrollTop(cm, scrollPos.scrollTop);
            if (scrollPos.scrollLeft != null)
                setScrollLeft(cm, scrollPos.scrollLeft);
        }
        function calculateScrollPos(cm, x1, y1, x2, y2) {
            var display = cm.display, snapMargin = textHeight(cm.display);
            if (y1 < 0)
                y1 = 0;
            var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
            var docBottom = cm.doc.height + paddingVert(display);
            var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
            if (y1 < screentop) {
                result.scrollTop = atTop ? 0 : y1;
            } else if (y2 > screentop + screen) {
                var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
                if (newTop != screentop)
                    result.scrollTop = newTop;
            }
            var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
            x1 += display.gutters.offsetWidth;
            x2 += display.gutters.offsetWidth;
            var gutterw = display.gutters.offsetWidth;
            var atLeft = x1 < gutterw + 10;
            if (x1 < screenleft + gutterw || atLeft) {
                if (atLeft)
                    x1 = 0;
                result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
            } else if (x2 > screenw + screenleft - 3) {
                result.scrollLeft = x2 + 10 - screenw;
            }
            return result;
        }
        function updateScrollPos(cm, left, top) {
            cm.curOp.updateScrollPos = {
                scrollLeft: left == null ? cm.doc.scrollLeft : left,
                scrollTop: top == null ? cm.doc.scrollTop : top
            };
        }
        function addToScrollPos(cm, left, top) {
            var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
                    scrollLeft: cm.doc.scrollLeft,
                    scrollTop: cm.doc.scrollTop
                });
            var scroll = cm.display.scroller;
            pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
            pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
        }
        function indentLine(cm, n, how, aggressive) {
            var doc = cm.doc;
            if (how == null)
                how = 'add';
            if (how == 'smart') {
                if (!cm.doc.mode.indent)
                    how = 'prev';
                else
                    var state = getStateBefore(cm, n);
            }
            var tabSize = cm.options.tabSize;
            var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
            var curSpaceString = line.text.match(/^\s*/)[0], indentation;
            if (how == 'smart') {
                indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
                if (indentation == Pass) {
                    if (!aggressive)
                        return;
                    how = 'prev';
                }
            }
            if (how == 'prev') {
                if (n > doc.first)
                    indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
                else
                    indentation = 0;
            } else if (how == 'add') {
                indentation = curSpace + cm.options.indentUnit;
            } else if (how == 'subtract') {
                indentation = curSpace - cm.options.indentUnit;
            } else if (typeof how == 'number') {
                indentation = curSpace + how;
            }
            indentation = Math.max(0, indentation);
            var indentString = '', pos = 0;
            if (cm.options.indentWithTabs)
                for (var i = Math.floor(indentation / tabSize); i; --i) {
                    pos += tabSize;
                    indentString += '\t';
                }
            if (pos < indentation)
                indentString += spaceStr(indentation - pos);
            if (indentString != curSpaceString)
                replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
            line.stateAfter = null;
        }
        function changeLine(cm, handle, op) {
            var no = handle, line = handle, doc = cm.doc;
            if (typeof handle == 'number')
                line = getLine(doc, clipLine(doc, handle));
            else
                no = lineNo(handle);
            if (no == null)
                return null;
            if (op(line, no))
                regChange(cm, no, no + 1);
            else
                return null;
            return line;
        }
        function findPosH(doc, pos, dir, unit, visually) {
            var line = pos.line, ch = pos.ch, origDir = dir;
            var lineObj = getLine(doc, line);
            var possible = true;
            function findNextLine() {
                var l = line + dir;
                if (l < doc.first || l >= doc.first + doc.size)
                    return possible = false;
                line = l;
                return lineObj = getLine(doc, l);
            }
            function moveOnce(boundToLine) {
                var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
                if (next == null) {
                    if (!boundToLine && findNextLine()) {
                        if (visually)
                            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
                        else
                            ch = dir < 0 ? lineObj.text.length : 0;
                    } else
                        return possible = false;
                } else
                    ch = next;
                return true;
            }
            if (unit == 'char')
                moveOnce();
            else if (unit == 'column')
                moveOnce(true);
            else if (unit == 'word' || unit == 'group') {
                var sawType = null, group = unit == 'group';
                for (var first = true;; first = false) {
                    if (dir < 0 && !moveOnce(!first))
                        break;
                    var cur = lineObj.text.charAt(ch) || '\n';
                    var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
                    if (sawType && sawType != type) {
                        if (dir < 0) {
                            dir = 1;
                            moveOnce();
                        }
                        break;
                    }
                    if (type)
                        sawType = type;
                    if (dir > 0 && !moveOnce(!first))
                        break;
                }
            }
            var result = skipAtomic(doc, Pos(line, ch), origDir, true);
            if (!possible)
                result.hitSide = true;
            return result;
        }
        function findPosV(cm, pos, dir, unit) {
            var doc = cm.doc, x = pos.left, y;
            if (unit == 'page') {
                var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
            } else if (unit == 'line') {
                y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
            }
            for (;;) {
                var target = coordsChar(cm, x, y);
                if (!target.outside)
                    break;
                if (dir < 0 ? y <= 0 : y >= doc.height) {
                    target.hitSide = true;
                    break;
                }
                y += dir * 5;
            }
            return target;
        }
        function findWordAt(line, pos) {
            var start = pos.ch, end = pos.ch;
            if (line) {
                if ((pos.xRel < 0 || end == line.length) && start)
                    --start;
                else
                    ++end;
                var startChar = line.charAt(start);
                var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
                        return /\s/.test(ch);
                    } : function (ch) {
                        return !/\s/.test(ch) && !isWordChar(ch);
                    };
                while (start > 0 && check(line.charAt(start - 1)))
                    --start;
                while (end < line.length && check(line.charAt(end)))
                    ++end;
            }
            return {
                from: Pos(pos.line, start),
                to: Pos(pos.line, end)
            };
        }
        function selectLine(cm, line) {
            extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
        }
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function () {
                window.focus();
                focusInput(this);
                onFocus(this);
                fastPoll(this);
            },
            setOption: function (option, value) {
                var options = this.options, old = options[option];
                if (options[option] == value && option != 'mode')
                    return;
                options[option] = value;
                if (optionHandlers.hasOwnProperty(option))
                    operation(this, optionHandlers[option])(this, value, old);
            },
            getOption: function (option) {
                return this.options[option];
            },
            getDoc: function () {
                return this.doc;
            },
            addKeyMap: function (map, bottom) {
                this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
            },
            removeKeyMap: function (map) {
                var maps = this.state.keyMaps;
                for (var i = 0; i < maps.length; ++i)
                    if (maps[i] == map || typeof maps[i] != 'string' && maps[i].name == map) {
                        maps.splice(i, 1);
                        return true;
                    }
            },
            addOverlay: operation(null, function (spec, options) {
                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState)
                    throw new Error('Overlays may not be stateful.');
                this.state.overlays.push({
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque
                });
                this.state.modeGen++;
                regChange(this);
            }),
            removeOverlay: operation(null, function (spec) {
                var overlays = this.state.overlays;
                for (var i = 0; i < overlays.length; ++i) {
                    var cur = overlays[i].modeSpec;
                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {
                        overlays.splice(i, 1);
                        this.state.modeGen++;
                        regChange(this);
                        return;
                    }
                }
            }),
            indentLine: operation(null, function (n, dir, aggressive) {
                if (typeof dir != 'string' && typeof dir != 'number') {
                    if (dir == null)
                        dir = this.options.smartIndent ? 'smart' : 'prev';
                    else
                        dir = dir ? 'add' : 'subtract';
                }
                if (isLine(this.doc, n))
                    indentLine(this, n, dir, aggressive);
            }),
            indentSelection: operation(null, function (how) {
                var sel = this.doc.sel;
                if (posEq(sel.from, sel.to))
                    return indentLine(this, sel.from.line, how);
                var e = sel.to.line - (sel.to.ch ? 0 : 1);
                for (var i = sel.from.line; i <= e; ++i)
                    indentLine(this, i, how);
            }),
            getTokenAt: function (pos, precise) {
                var doc = this.doc;
                pos = clipPos(doc, pos);
                var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
                var line = getLine(doc, pos.line);
                var stream = new StringStream(line.text, this.options.tabSize);
                while (stream.pos < pos.ch && !stream.eol()) {
                    stream.start = stream.pos;
                    var style = mode.token(stream, state);
                }
                return {
                    start: stream.start,
                    end: stream.pos,
                    string: stream.current(),
                    className: style || null,
                    type: style || null,
                    state: state
                };
            },
            getTokenTypeAt: function (pos) {
                pos = clipPos(this.doc, pos);
                var styles = getLineStyles(this, getLine(this.doc, pos.line));
                var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                if (ch == 0)
                    return styles[2];
                for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                        after = mid;
                    else if (styles[mid * 2 + 1] < ch)
                        before = mid + 1;
                    else
                        return styles[mid * 2 + 2];
                }
            },
            getModeAt: function (pos) {
                var mode = this.doc.mode;
                if (!mode.innerMode)
                    return mode;
                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function (pos, type) {
                if (!helpers.hasOwnProperty(type))
                    return;
                var help = helpers[type], mode = this.getModeAt(pos);
                return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name];
            },
            getStateAfter: function (line, precise) {
                var doc = this.doc;
                line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
                return getStateBefore(this, line + 1, precise);
            },
            cursorCoords: function (start, mode) {
                var pos, sel = this.doc.sel;
                if (start == null)
                    pos = sel.head;
                else if (typeof start == 'object')
                    pos = clipPos(this.doc, start);
                else
                    pos = start ? sel.from : sel.to;
                return cursorCoords(this, pos, mode || 'page');
            },
            charCoords: function (pos, mode) {
                return charCoords(this, clipPos(this.doc, pos), mode || 'page');
            },
            coordsChar: function (coords, mode) {
                coords = fromCoordSystem(this, coords, mode || 'page');
                return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function (height, mode) {
                height = fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || 'page').top;
                return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function (line, mode) {
                var end = false, last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first)
                    line = this.doc.first;
                else if (line > last) {
                    line = last;
                    end = true;
                }
                var lineObj = getLine(this.doc, line);
                return intoCoordSystem(this, getLine(this.doc, line), {
                    top: 0,
                    left: 0
                }, mode || 'page').top + (end ? lineObj.height : 0);
            },
            defaultTextHeight: function () {
                return textHeight(this.display);
            },
            defaultCharWidth: function () {
                return charWidth(this.display);
            },
            setGutterMarker: operation(null, function (line, gutterID, value) {
                return changeLine(this, line, function (line) {
                    var markers = line.gutterMarkers || (line.gutterMarkers = {});
                    markers[gutterID] = value;
                    if (!value && isEmpty(markers))
                        line.gutterMarkers = null;
                    return true;
                });
            }),
            clearGutter: operation(null, function (gutterID) {
                var cm = this, doc = cm.doc, i = doc.first;
                doc.iter(function (line) {
                    if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                        line.gutterMarkers[gutterID] = null;
                        regChange(cm, i, i + 1);
                        if (isEmpty(line.gutterMarkers))
                            line.gutterMarkers = null;
                    }
                    ++i;
                });
            }),
            addLineClass: operation(null, function (handle, where, cls) {
                return changeLine(this, handle, function (line) {
                    var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                    if (!line[prop])
                        line[prop] = cls;
                    else if (new RegExp('(?:^|\\s)' + cls + '(?:$|\\s)').test(line[prop]))
                        return false;
                    else
                        line[prop] += ' ' + cls;
                    return true;
                });
            }),
            removeLineClass: operation(null, function (handle, where, cls) {
                return changeLine(this, handle, function (line) {
                    var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                    var cur = line[prop];
                    if (!cur)
                        return false;
                    else if (cls == null)
                        line[prop] = null;
                    else {
                        var found = cur.match(new RegExp('(?:^|\\s+)' + cls + '(?:$|\\s+)'));
                        if (!found)
                            return false;
                        var end = found.index + found[0].length;
                        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
                    }
                    return true;
                });
            }),
            addLineWidget: operation(null, function (handle, node, options) {
                return addLineWidget(this, handle, node, options);
            }),
            removeLineWidget: function (widget) {
                widget.clear();
            },
            lineInfo: function (line) {
                if (typeof line == 'number') {
                    if (!isLine(this.doc, line))
                        return null;
                    var n = line;
                    line = getLine(this.doc, line);
                    if (!line)
                        return null;
                } else {
                    var n = lineNo(line);
                    if (n == null)
                        return null;
                }
                return {
                    line: n,
                    handle: line,
                    text: line.text,
                    gutterMarkers: line.gutterMarkers,
                    textClass: line.textClass,
                    bgClass: line.bgClass,
                    wrapClass: line.wrapClass,
                    widgets: line.widgets
                };
            },
            getViewport: function () {
                return {
                    from: this.display.showingFrom,
                    to: this.display.showingTo
                };
            },
            addWidget: function (pos, node, scroll, vert, horiz) {
                var display = this.display;
                pos = cursorCoords(this, clipPos(this.doc, pos));
                var top = pos.bottom, left = pos.left;
                node.style.position = 'absolute';
                display.sizer.appendChild(node);
                if (vert == 'over') {
                    top = pos.top;
                } else if (vert == 'above' || vert == 'near') {
                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                        top = pos.top - node.offsetHeight;
                    else if (pos.bottom + node.offsetHeight <= vspace)
                        top = pos.bottom;
                    if (left + node.offsetWidth > hspace)
                        left = hspace - node.offsetWidth;
                }
                node.style.top = top + 'px';
                node.style.left = node.style.right = '';
                if (horiz == 'right') {
                    left = display.sizer.clientWidth - node.offsetWidth;
                    node.style.right = '0px';
                } else {
                    if (horiz == 'left')
                        left = 0;
                    else if (horiz == 'middle')
                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                    node.style.left = left + 'px';
                }
                if (scroll)
                    scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
            },
            triggerOnKeyDown: operation(null, onKeyDown),
            execCommand: function (cmd) {
                return commands[cmd](this);
            },
            findPosH: function (from, amount, unit, visually) {
                var dir = 1;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                    cur = findPosH(this.doc, cur, dir, unit, visually);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveH: operation(null, function (dir, unit) {
                var sel = this.doc.sel, pos;
                if (sel.shift || sel.extend || posEq(sel.from, sel.to))
                    pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
                else
                    pos = dir < 0 ? sel.from : sel.to;
                extendSelection(this.doc, pos, pos, dir);
            }),
            deleteH: operation(null, function (dir, unit) {
                var sel = this.doc.sel;
                if (!posEq(sel.from, sel.to))
                    replaceRange(this.doc, '', sel.from, sel.to, '+delete');
                else
                    replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
                this.curOp.userSelChange = true;
            }),
            findPosV: function (from, amount, unit, goalColumn) {
                var dir = 1, x = goalColumn;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                    var coords = cursorCoords(this, cur, 'div');
                    if (x == null)
                        x = coords.left;
                    else
                        coords.left = x;
                    cur = findPosV(this, coords, dir, unit);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveV: operation(null, function (dir, unit) {
                var sel = this.doc.sel;
                var pos = cursorCoords(this, sel.head, 'div');
                if (sel.goalColumn != null)
                    pos.left = sel.goalColumn;
                var target = findPosV(this, pos, dir, unit);
                if (unit == 'page')
                    addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
                extendSelection(this.doc, target, target, dir);
                sel.goalColumn = pos.left;
            }),
            toggleOverwrite: function (value) {
                if (value != null && value == this.state.overwrite)
                    return;
                if (this.state.overwrite = !this.state.overwrite)
                    this.display.cursor.className += ' CodeMirror-overwrite';
                else
                    this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
            },
            hasFocus: function () {
                return this.state.focused;
            },
            scrollTo: operation(null, function (x, y) {
                updateScrollPos(this, x, y);
            }),
            getScrollInfo: function () {
                var scroller = this.display.scroller, co = scrollerCutOff;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - co,
                    width: scroller.scrollWidth - co,
                    clientHeight: scroller.clientHeight - co,
                    clientWidth: scroller.clientWidth - co
                };
            },
            scrollIntoView: operation(null, function (pos, margin) {
                if (typeof pos == 'number')
                    pos = Pos(pos, 0);
                if (!margin)
                    margin = 0;
                var coords = pos;
                if (!pos || pos.line != null) {
                    this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
                    this.curOp.scrollToPosMargin = margin;
                    coords = cursorCoords(this, this.curOp.scrollToPos);
                }
                var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
                updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
            }),
            setSize: operation(null, function (width, height) {
                function interpret(val) {
                    return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
                }
                if (width != null)
                    this.display.wrapper.style.width = interpret(width);
                if (height != null)
                    this.display.wrapper.style.height = interpret(height);
                if (this.options.lineWrapping)
                    this.display.measureLineCache.length = this.display.measureLineCachePos = 0;
                this.curOp.forceUpdate = true;
            }),
            operation: function (f) {
                return runInOp(this, f);
            },
            refresh: operation(null, function () {
                var badHeight = this.display.cachedTextHeight == null;
                clearCaches(this);
                updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
                regChange(this);
                if (badHeight)
                    estimateLineHeights(this);
            }),
            swapDoc: operation(null, function (doc) {
                var old = this.doc;
                old.cm = null;
                attachDoc(this, doc);
                clearCaches(this);
                resetInput(this, true);
                updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
                signalLater(this, 'swapDoc', this, old);
                return old;
            }),
            getInputField: function () {
                return this.display.input;
            },
            getWrapperElement: function () {
                return this.display.wrapper;
            },
            getScrollerElement: function () {
                return this.display.scroller;
            },
            getGutterElement: function () {
                return this.display.gutters;
            }
        };
        eventMixin(CodeMirror);
        var optionHandlers = CodeMirror.optionHandlers = {};
        var defaults = CodeMirror.defaults = {};
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt;
            if (handle)
                optionHandlers[name] = notOnInit ? function (cm, val, old) {
                    if (old != Init)
                        handle(cm, val, old);
                } : handle;
        }
        var Init = CodeMirror.Init = {
                toString: function () {
                    return 'CodeMirror.Init';
                }
            };
        option('value', '', function (cm, val) {
            cm.setValue(val);
        }, true);
        option('mode', null, function (cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
        }, true);
        option('indentUnit', 2, loadMode, true);
        option('indentWithTabs', false);
        option('smartIndent', true);
        option('tabSize', 4, function (cm) {
            loadMode(cm);
            clearCaches(cm);
            regChange(cm);
        }, true);
        option('electricChars', true);
        option('rtlMoveVisually', !windows);
        option('theme', 'default', function (cm) {
            themeChanged(cm);
            guttersChanged(cm);
        }, true);
        option('keyMap', 'default', keyMapChanged);
        option('extraKeys', null);
        option('onKeyEvent', null);
        option('onDragEvent', null);
        option('lineWrapping', false, wrappingChanged, true);
        option('gutters', [], function (cm) {
            setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('fixedGutter', true, function (cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
            cm.refresh();
        }, true);
        option('coverGutterNextToScrollbar', false, updateScrollbars, true);
        option('lineNumbers', false, function (cm) {
            setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('firstLineNumber', 1, guttersChanged, true);
        option('lineNumberFormatter', function (integer) {
            return integer;
        }, guttersChanged, true);
        option('showCursorWhenSelecting', false, updateSelection, true);
        option('resetSelectionOnContextMenu', true);
        option('readOnly', false, function (cm, val) {
            if (val == 'nocursor') {
                onBlur(cm);
                cm.display.input.blur();
            } else if (!val)
                resetInput(cm, true);
        });
        option('dragDrop', true);
        option('cursorBlinkRate', 530);
        option('cursorScrollMargin', 0);
        option('cursorHeight', 1);
        option('workTime', 100);
        option('workDelay', 100);
        option('flattenSpans', true);
        option('pollInterval', 100);
        option('undoDepth', 40, function (cm, val) {
            cm.doc.history.undoDepth = val;
        });
        option('historyEventDelay', 500);
        option('viewportMargin', 10, function (cm) {
            cm.refresh();
        }, true);
        option('maxHighlightLength', 10000, function (cm) {
            loadMode(cm);
            cm.refresh();
        }, true);
        option('crudeMeasuringFrom', 10000);
        option('moveInputWithCursor', true, function (cm, val) {
            if (!val)
                cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
        });
        option('tabindex', null, function (cm, val) {
            cm.display.input.tabIndex = val || '';
        });
        option('autofocus', null);
        var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
        CodeMirror.defineMode = function (name, mode) {
            if (!CodeMirror.defaults.mode && name != 'null')
                CodeMirror.defaults.mode = name;
            if (arguments.length > 2) {
                mode.dependencies = [];
                for (var i = 2; i < arguments.length; ++i)
                    mode.dependencies.push(arguments[i]);
            }
            modes[name] = mode;
        };
        CodeMirror.defineMIME = function (mime, spec) {
            mimeModes[mime] = spec;
        };
        CodeMirror.resolveMode = function (spec) {
            if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
                spec = mimeModes[spec];
            } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
                var found = mimeModes[spec.name];
                spec = createObj(found, spec);
                spec.name = found.name;
            } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
                return CodeMirror.resolveMode('application/xml');
            }
            if (typeof spec == 'string')
                return { name: spec };
            else
                return spec || { name: 'null' };
        };
        CodeMirror.getMode = function (options, spec) {
            var spec = CodeMirror.resolveMode(spec);
            var mfactory = modes[spec.name];
            if (!mfactory)
                return CodeMirror.getMode(options, 'text/plain');
            var modeObj = mfactory(options, spec);
            if (modeExtensions.hasOwnProperty(spec.name)) {
                var exts = modeExtensions[spec.name];
                for (var prop in exts) {
                    if (!exts.hasOwnProperty(prop))
                        continue;
                    if (modeObj.hasOwnProperty(prop))
                        modeObj['_' + prop] = modeObj[prop];
                    modeObj[prop] = exts[prop];
                }
            }
            modeObj.name = spec.name;
            return modeObj;
        };
        CodeMirror.defineMode('null', function () {
            return {
                token: function (stream) {
                    stream.skipToEnd();
                }
            };
        });
        CodeMirror.defineMIME('text/plain', 'null');
        var modeExtensions = CodeMirror.modeExtensions = {};
        CodeMirror.extendMode = function (mode, properties) {
            var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
            copyObj(properties, exts);
        };
        CodeMirror.defineExtension = function (name, func) {
            CodeMirror.prototype[name] = func;
        };
        CodeMirror.defineDocExtension = function (name, func) {
            Doc.prototype[name] = func;
        };
        CodeMirror.defineOption = option;
        var initHooks = [];
        CodeMirror.defineInitHook = function (f) {
            initHooks.push(f);
        };
        var helpers = CodeMirror.helpers = {};
        CodeMirror.registerHelper = function (type, name, value) {
            if (!helpers.hasOwnProperty(type))
                helpers[type] = CodeMirror[type] = {};
            helpers[type][name] = value;
        };
        CodeMirror.isWordChar = isWordChar;
        function copyState(mode, state) {
            if (state === true)
                return state;
            if (mode.copyState)
                return mode.copyState(state);
            var nstate = {};
            for (var n in state) {
                var val = state[n];
                if (val instanceof Array)
                    val = val.concat([]);
                nstate[n] = val;
            }
            return nstate;
        }
        CodeMirror.copyState = copyState;
        function startState(mode, a1, a2) {
            return mode.startState ? mode.startState(a1, a2) : true;
        }
        CodeMirror.startState = startState;
        CodeMirror.innerMode = function (mode, state) {
            while (mode.innerMode) {
                var info = mode.innerMode(state);
                if (!info || info.mode == mode)
                    break;
                state = info.state;
                mode = info.mode;
            }
            return info || {
                mode: mode,
                state: state
            };
        };
        var commands = CodeMirror.commands = {
                selectAll: function (cm) {
                    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
                },
                killLine: function (cm) {
                    var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
                    if (!sel && cm.getLine(from.line).length == from.ch)
                        cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
                    else
                        cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
                },
                deleteLine: function (cm) {
                    var l = cm.getCursor().line;
                    cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
                },
                delLineLeft: function (cm) {
                    var cur = cm.getCursor();
                    cm.replaceRange('', Pos(cur.line, 0), cur, '+delete');
                },
                undo: function (cm) {
                    cm.undo();
                },
                redo: function (cm) {
                    cm.redo();
                },
                goDocStart: function (cm) {
                    cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function (cm) {
                    cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function (cm) {
                    cm.extendSelection(lineStart(cm, cm.getCursor().line));
                },
                goLineStartSmart: function (cm) {
                    var cur = cm.getCursor(), start = lineStart(cm, cur.line);
                    var line = cm.getLineHandle(start.line);
                    var order = getOrder(line);
                    if (!order || order[0].level == 0) {
                        var firstNonWS = Math.max(0, line.text.search(/\S/));
                        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
                        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
                    } else
                        cm.extendSelection(start);
                },
                goLineEnd: function (cm) {
                    cm.extendSelection(lineEnd(cm, cm.getCursor().line));
                },
                goLineRight: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
                    cm.extendSelection(cm.coordsChar({
                        left: cm.display.lineDiv.offsetWidth + 100,
                        top: top
                    }, 'div'));
                },
                goLineLeft: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
                    cm.extendSelection(cm.coordsChar({
                        left: 0,
                        top: top
                    }, 'div'));
                },
                goLineUp: function (cm) {
                    cm.moveV(-1, 'line');
                },
                goLineDown: function (cm) {
                    cm.moveV(1, 'line');
                },
                goPageUp: function (cm) {
                    cm.moveV(-1, 'page');
                },
                goPageDown: function (cm) {
                    cm.moveV(1, 'page');
                },
                goCharLeft: function (cm) {
                    cm.moveH(-1, 'char');
                },
                goCharRight: function (cm) {
                    cm.moveH(1, 'char');
                },
                goColumnLeft: function (cm) {
                    cm.moveH(-1, 'column');
                },
                goColumnRight: function (cm) {
                    cm.moveH(1, 'column');
                },
                goWordLeft: function (cm) {
                    cm.moveH(-1, 'word');
                },
                goGroupRight: function (cm) {
                    cm.moveH(1, 'group');
                },
                goGroupLeft: function (cm) {
                    cm.moveH(-1, 'group');
                },
                goWordRight: function (cm) {
                    cm.moveH(1, 'word');
                },
                delCharBefore: function (cm) {
                    cm.deleteH(-1, 'char');
                },
                delCharAfter: function (cm) {
                    cm.deleteH(1, 'char');
                },
                delWordBefore: function (cm) {
                    cm.deleteH(-1, 'word');
                },
                delWordAfter: function (cm) {
                    cm.deleteH(1, 'word');
                },
                delGroupBefore: function (cm) {
                    cm.deleteH(-1, 'group');
                },
                delGroupAfter: function (cm) {
                    cm.deleteH(1, 'group');
                },
                indentAuto: function (cm) {
                    cm.indentSelection('smart');
                },
                indentMore: function (cm) {
                    cm.indentSelection('add');
                },
                indentLess: function (cm) {
                    cm.indentSelection('subtract');
                },
                insertTab: function (cm) {
                    cm.replaceSelection('\t', 'end', '+input');
                },
                defaultTab: function (cm) {
                    if (cm.somethingSelected())
                        cm.indentSelection('add');
                    else
                        cm.replaceSelection('\t', 'end', '+input');
                },
                transposeChars: function (cm) {
                    var cur = cm.getCursor(), line = cm.getLine(cur.line);
                    if (cur.ch > 0 && cur.ch < line.length - 1)
                        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
                },
                newlineAndIndent: function (cm) {
                    operation(cm, function () {
                        cm.replaceSelection('\n', 'end', '+input');
                        cm.indentLine(cm.getCursor().line, null, true);
                    })();
                },
                toggleOverwrite: function (cm) {
                    cm.toggleOverwrite();
                }
            };
        var keyMap = CodeMirror.keyMap = {};
        keyMap.basic = {
            'Left': 'goCharLeft',
            'Right': 'goCharRight',
            'Up': 'goLineUp',
            'Down': 'goLineDown',
            'End': 'goLineEnd',
            'Home': 'goLineStartSmart',
            'PageUp': 'goPageUp',
            'PageDown': 'goPageDown',
            'Delete': 'delCharAfter',
            'Backspace': 'delCharBefore',
            'Shift-Backspace': 'delCharBefore',
            'Tab': 'defaultTab',
            'Shift-Tab': 'indentAuto',
            'Enter': 'newlineAndIndent',
            'Insert': 'toggleOverwrite'
        };
        keyMap.pcDefault = {
            'Ctrl-A': 'selectAll',
            'Ctrl-D': 'deleteLine',
            'Ctrl-Z': 'undo',
            'Shift-Ctrl-Z': 'redo',
            'Ctrl-Y': 'redo',
            'Ctrl-Home': 'goDocStart',
            'Alt-Up': 'goDocStart',
            'Ctrl-End': 'goDocEnd',
            'Ctrl-Down': 'goDocEnd',
            'Ctrl-Left': 'goGroupLeft',
            'Ctrl-Right': 'goGroupRight',
            'Alt-Left': 'goLineStart',
            'Alt-Right': 'goLineEnd',
            'Ctrl-Backspace': 'delGroupBefore',
            'Ctrl-Delete': 'delGroupAfter',
            'Ctrl-S': 'save',
            'Ctrl-F': 'find',
            'Ctrl-G': 'findNext',
            'Shift-Ctrl-G': 'findPrev',
            'Shift-Ctrl-F': 'replace',
            'Shift-Ctrl-R': 'replaceAll',
            'Ctrl-[': 'indentLess',
            'Ctrl-]': 'indentMore',
            fallthrough: 'basic'
        };
        keyMap.macDefault = {
            'Cmd-A': 'selectAll',
            'Cmd-D': 'deleteLine',
            'Cmd-Z': 'undo',
            'Shift-Cmd-Z': 'redo',
            'Cmd-Y': 'redo',
            'Cmd-Up': 'goDocStart',
            'Cmd-End': 'goDocEnd',
            'Cmd-Down': 'goDocEnd',
            'Alt-Left': 'goGroupLeft',
            'Alt-Right': 'goGroupRight',
            'Cmd-Left': 'goLineStart',
            'Cmd-Right': 'goLineEnd',
            'Alt-Backspace': 'delGroupBefore',
            'Ctrl-Alt-Backspace': 'delGroupAfter',
            'Alt-Delete': 'delGroupAfter',
            'Cmd-S': 'save',
            'Cmd-F': 'find',
            'Cmd-G': 'findNext',
            'Shift-Cmd-G': 'findPrev',
            'Cmd-Alt-F': 'replace',
            'Shift-Cmd-Alt-F': 'replaceAll',
            'Cmd-[': 'indentLess',
            'Cmd-]': 'indentMore',
            'Cmd-Backspace': 'delLineLeft',
            fallthrough: [
                'basic',
                'emacsy'
            ]
        };
        keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
        keyMap.emacsy = {
            'Ctrl-F': 'goCharRight',
            'Ctrl-B': 'goCharLeft',
            'Ctrl-P': 'goLineUp',
            'Ctrl-N': 'goLineDown',
            'Alt-F': 'goWordRight',
            'Alt-B': 'goWordLeft',
            'Ctrl-A': 'goLineStart',
            'Ctrl-E': 'goLineEnd',
            'Ctrl-V': 'goPageDown',
            'Shift-Ctrl-V': 'goPageUp',
            'Ctrl-D': 'delCharAfter',
            'Ctrl-H': 'delCharBefore',
            'Alt-D': 'delWordAfter',
            'Alt-Backspace': 'delWordBefore',
            'Ctrl-K': 'killLine',
            'Ctrl-T': 'transposeChars'
        };
        function getKeyMap(val) {
            if (typeof val == 'string')
                return keyMap[val];
            else
                return val;
        }
        function lookupKey(name, maps, handle) {
            function lookup(map) {
                map = getKeyMap(map);
                var found = map[name];
                if (found === false)
                    return 'stop';
                if (found != null && handle(found))
                    return true;
                if (map.nofallthrough)
                    return 'stop';
                var fallthrough = map.fallthrough;
                if (fallthrough == null)
                    return false;
                if (Object.prototype.toString.call(fallthrough) != '[object Array]')
                    return lookup(fallthrough);
                for (var i = 0, e = fallthrough.length; i < e; ++i) {
                    var done = lookup(fallthrough[i]);
                    if (done)
                        return done;
                }
                return false;
            }
            for (var i = 0; i < maps.length; ++i) {
                var done = lookup(maps[i]);
                if (done)
                    return done != 'stop';
            }
        }
        function isModifierKey(event) {
            var name = keyNames[event.keyCode];
            return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
        }
        function keyName(event, noShift) {
            if (opera && event.keyCode == 34 && event['char'])
                return false;
            var name = keyNames[event.keyCode];
            if (name == null || event.altGraphKey)
                return false;
            if (event.altKey)
                name = 'Alt-' + name;
            if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
                name = 'Ctrl-' + name;
            if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
                name = 'Cmd-' + name;
            if (!noShift && event.shiftKey)
                name = 'Shift-' + name;
            return name;
        }
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.keyName = keyName;
        CodeMirror.fromTextArea = function (textarea, options) {
            if (!options)
                options = {};
            options.value = textarea.value;
            if (!options.tabindex && textarea.tabindex)
                options.tabindex = textarea.tabindex;
            if (!options.placeholder && textarea.placeholder)
                options.placeholder = textarea.placeholder;
            if (options.autofocus == null) {
                var hasFocus = document.body;
                try {
                    hasFocus = document.activeElement;
                } catch (e) {
                }
                options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
            }
            function save() {
                textarea.value = cm.getValue();
            }
            if (textarea.form) {
                on(textarea.form, 'submit', save);
                if (!options.leaveSubmitMethodAlone) {
                    var form = textarea.form, realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function () {
                                save();
                                form.submit = realSubmit;
                                form.submit();
                                form.submit = wrappedSubmit;
                            };
                    } catch (e) {
                    }
                }
            }
            textarea.style.display = 'none';
            var cm = CodeMirror(function (node) {
                    textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
            cm.save = save;
            cm.getTextArea = function () {
                return textarea;
            };
            cm.toTextArea = function () {
                save();
                textarea.parentNode.removeChild(cm.getWrapperElement());
                textarea.style.display = '';
                if (textarea.form) {
                    off(textarea.form, 'submit', save);
                    if (typeof textarea.form.submit == 'function')
                        textarea.form.submit = realSubmit;
                }
            };
            return cm;
        };
        function StringStream(string, tabSize) {
            this.pos = this.start = 0;
            this.string = string;
            this.tabSize = tabSize || 8;
            this.lastColumnPos = this.lastColumnValue = 0;
        }
        StringStream.prototype = {
            eol: function () {
                return this.pos >= this.string.length;
            },
            sol: function () {
                return this.pos == 0;
            },
            peek: function () {
                return this.string.charAt(this.pos) || undefined;
            },
            next: function () {
                if (this.pos < this.string.length)
                    return this.string.charAt(this.pos++);
            },
            eat: function (match) {
                var ch = this.string.charAt(this.pos);
                if (typeof match == 'string')
                    var ok = ch == match;
                else
                    var ok = ch && (match.test ? match.test(ch) : match(ch));
                if (ok) {
                    ++this.pos;
                    return ch;
                }
            },
            eatWhile: function (match) {
                var start = this.pos;
                while (this.eat(match)) {
                }
                return this.pos > start;
            },
            eatSpace: function () {
                var start = this.pos;
                while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                    ++this.pos;
                return this.pos > start;
            },
            skipToEnd: function () {
                this.pos = this.string.length;
            },
            skipTo: function (ch) {
                var found = this.string.indexOf(ch, this.pos);
                if (found > -1) {
                    this.pos = found;
                    return true;
                }
            },
            backUp: function (n) {
                this.pos -= n;
            },
            column: function () {
                if (this.lastColumnPos < this.start) {
                    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                    this.lastColumnPos = this.start;
                }
                return this.lastColumnValue;
            },
            indentation: function () {
                return countColumn(this.string, null, this.tabSize);
            },
            match: function (pattern, consume, caseInsensitive) {
                if (typeof pattern == 'string') {
                    var cased = function (str) {
                        return caseInsensitive ? str.toLowerCase() : str;
                    };
                    var substr = this.string.substr(this.pos, pattern.length);
                    if (cased(substr) == cased(pattern)) {
                        if (consume !== false)
                            this.pos += pattern.length;
                        return true;
                    }
                } else {
                    var match = this.string.slice(this.pos).match(pattern);
                    if (match && match.index > 0)
                        return null;
                    if (match && consume !== false)
                        this.pos += match[0].length;
                    return match;
                }
            },
            current: function () {
                return this.string.slice(this.start, this.pos);
            }
        };
        CodeMirror.StringStream = StringStream;
        function TextMarker(doc, type) {
            this.lines = [];
            this.type = type;
            this.doc = doc;
        }
        CodeMirror.TextMarker = TextMarker;
        eventMixin(TextMarker);
        TextMarker.prototype.clear = function () {
            if (this.explicitlyCleared)
                return;
            var cm = this.doc.cm, withOp = cm && !cm.curOp;
            if (withOp)
                startOperation(cm);
            if (hasHandler(this, 'clear')) {
                var found = this.find();
                if (found)
                    signalLater(this, 'clear', found.from, found.to);
            }
            var min = null, max = null;
            for (var i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i];
                var span = getMarkedSpanFor(line.markedSpans, this);
                if (span.to != null)
                    max = lineNo(line);
                line.markedSpans = removeMarkedSpan(line.markedSpans, span);
                if (span.from != null)
                    min = lineNo(line);
                else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
                    updateLineHeight(line, textHeight(cm.display));
            }
            if (cm && this.collapsed && !cm.options.lineWrapping)
                for (var i = 0; i < this.lines.length; ++i) {
                    var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
                    if (len > cm.display.maxLineLength) {
                        cm.display.maxLine = visual;
                        cm.display.maxLineLength = len;
                        cm.display.maxLineChanged = true;
                    }
                }
            if (min != null && cm)
                regChange(cm, min, max + 1);
            this.lines.length = 0;
            this.explicitlyCleared = true;
            if (this.atomic && this.doc.cantEdit) {
                this.doc.cantEdit = false;
                if (cm)
                    reCheckSelection(cm);
            }
            if (withOp)
                endOperation(cm);
        };
        TextMarker.prototype.find = function () {
            var from, to;
            for (var i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i];
                var span = getMarkedSpanFor(line.markedSpans, this);
                if (span.from != null || span.to != null) {
                    var found = lineNo(line);
                    if (span.from != null)
                        from = Pos(found, span.from);
                    if (span.to != null)
                        to = Pos(found, span.to);
                }
            }
            if (this.type == 'bookmark')
                return from;
            return from && {
                from: from,
                to: to
            };
        };
        TextMarker.prototype.changed = function () {
            var pos = this.find(), cm = this.doc.cm;
            if (!pos || !cm)
                return;
            if (this.type != 'bookmark')
                pos = pos.from;
            var line = getLine(this.doc, pos.line);
            clearCachedMeasurement(cm, line);
            if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {
                for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling)
                    if (node.lineObj == line) {
                        if (node.offsetHeight != line.height)
                            updateLineHeight(line, node.offsetHeight);
                        break;
                    }
                runInOp(cm, function () {
                    cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;
                });
            }
        };
        TextMarker.prototype.attachLine = function (line) {
            if (!this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
                    (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
            this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function (line) {
            this.lines.splice(indexOf(this.lines, line), 1);
            if (!this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
            }
        };
        function markText(doc, from, to, options, type) {
            if (options && options.shared)
                return markTextShared(doc, from, to, options, type);
            if (doc.cm && !doc.cm.curOp)
                return operation(doc.cm, markText)(doc, from, to, options, type);
            var marker = new TextMarker(doc, type);
            if (type == 'range' && !posLess(from, to))
                return marker;
            if (options)
                copyObj(options, marker);
            if (marker.replacedWith) {
                marker.collapsed = true;
                marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
                if (!options.handleMouseEvents)
                    marker.replacedWith.ignoreEvents = true;
            }
            if (marker.collapsed)
                sawCollapsedSpans = true;
            if (marker.addToHistory)
                addToHistory(doc, {
                    from: from,
                    to: to,
                    origin: 'markText'
                }, {
                    head: doc.sel.head,
                    anchor: doc.sel.anchor
                }, NaN);
            var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
            doc.iter(curLine, to.line + 1, function (line) {
                if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
                    updateMaxLine = true;
                var span = {
                        from: null,
                        to: null,
                        marker: marker
                    };
                size += line.text.length;
                if (curLine == from.line) {
                    span.from = from.ch;
                    size -= from.ch;
                }
                if (curLine == to.line) {
                    span.to = to.ch;
                    size -= line.text.length - to.ch;
                }
                if (marker.collapsed) {
                    if (curLine == to.line)
                        collapsedAtEnd = collapsedSpanAt(line, to.ch);
                    if (curLine == from.line)
                        collapsedAtStart = collapsedSpanAt(line, from.ch);
                    else
                        updateLineHeight(line, 0);
                }
                addMarkedSpan(line, span);
                ++curLine;
            });
            if (marker.collapsed)
                doc.iter(from.line, to.line + 1, function (line) {
                    if (lineIsHidden(doc, line))
                        updateLineHeight(line, 0);
                });
            if (marker.clearOnEnter)
                on(marker, 'beforeCursorEnter', function () {
                    marker.clear();
                });
            if (marker.readOnly) {
                sawReadOnlySpans = true;
                if (doc.history.done.length || doc.history.undone.length)
                    doc.clearHistory();
            }
            if (marker.collapsed) {
                if (collapsedAtStart != collapsedAtEnd)
                    throw new Error('Inserting collapsed marker overlapping an existing one');
                marker.size = size;
                marker.atomic = true;
            }
            if (cm) {
                if (updateMaxLine)
                    cm.curOp.updateMaxLine = true;
                if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)
                    regChange(cm, from.line, to.line + 1);
                if (marker.atomic)
                    reCheckSelection(cm);
            }
            return marker;
        }
        function SharedTextMarker(markers, primary) {
            this.markers = markers;
            this.primary = primary;
            for (var i = 0, me = this; i < markers.length; ++i) {
                markers[i].parent = this;
                on(markers[i], 'clear', function () {
                    me.clear();
                });
            }
        }
        CodeMirror.SharedTextMarker = SharedTextMarker;
        eventMixin(SharedTextMarker);
        SharedTextMarker.prototype.clear = function () {
            if (this.explicitlyCleared)
                return;
            this.explicitlyCleared = true;
            for (var i = 0; i < this.markers.length; ++i)
                this.markers[i].clear();
            signalLater(this, 'clear');
        };
        SharedTextMarker.prototype.find = function () {
            return this.primary.find();
        };
        function markTextShared(doc, from, to, options, type) {
            options = copyObj(options);
            options.shared = false;
            var markers = [markText(doc, from, to, options, type)], primary = markers[0];
            var widget = options.replacedWith;
            linkedDocs(doc, function (doc) {
                if (widget)
                    options.replacedWith = widget.cloneNode(true);
                markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                for (var i = 0; i < doc.linked.length; ++i)
                    if (doc.linked[i].isParent)
                        return;
                primary = lst(markers);
            });
            return new SharedTextMarker(markers, primary);
        }
        function getMarkedSpanFor(spans, marker) {
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker)
                        return span;
                }
        }
        function removeMarkedSpan(spans, span) {
            for (var r, i = 0; i < spans.length; ++i)
                if (spans[i] != span)
                    (r || (r = [])).push(spans[i]);
            return r;
        }
        function addMarkedSpan(line, span) {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
            span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
            if (old)
                for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push({
                            from: span.from,
                            to: endsAfter ? null : span.to,
                            marker: marker
                        });
                    }
                }
            return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
            if (old)
                for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push({
                            from: startsBefore ? null : span.from - endCh,
                            to: span.to == null ? null : span.to - endCh,
                            marker: marker
                        });
                    }
                }
            return nw;
        }
        function stretchSpansOverChange(doc, change) {
            var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
            var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
            if (!oldFirst && !oldLast)
                return null;
            var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
            var first = markedSpansBefore(oldFirst, startCh, isInsert);
            var last = markedSpansAfter(oldLast, endCh, isInsert);
            var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
            if (first) {
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (span.to == null) {
                        var found = getMarkedSpanFor(last, span.marker);
                        if (!found)
                            span.to = startCh;
                        else if (sameLine)
                            span.to = found.to == null ? null : found.to + offset;
                    }
                }
            }
            if (last) {
                for (var i = 0; i < last.length; ++i) {
                    var span = last[i];
                    if (span.to != null)
                        span.to += offset;
                    if (span.from == null) {
                        var found = getMarkedSpanFor(first, span.marker);
                        if (!found) {
                            span.from = offset;
                            if (sameLine)
                                (first || (first = [])).push(span);
                        }
                    } else {
                        span.from += offset;
                        if (sameLine)
                            (first || (first = [])).push(span);
                    }
                }
            }
            if (sameLine && first) {
                for (var i = 0; i < first.length; ++i)
                    if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != 'bookmark')
                        first.splice(i--, 1);
                if (!first.length)
                    first = null;
            }
            var newMarkers = [first];
            if (!sameLine) {
                var gap = change.text.length - 2, gapMarkers;
                if (gap > 0 && first)
                    for (var i = 0; i < first.length; ++i)
                        if (first[i].to == null)
                            (gapMarkers || (gapMarkers = [])).push({
                                from: null,
                                to: null,
                                marker: first[i].marker
                            });
                for (var i = 0; i < gap; ++i)
                    newMarkers.push(gapMarkers);
                newMarkers.push(last);
            }
            return newMarkers;
        }
        function mergeOldSpans(doc, change) {
            var old = getOldSpans(doc, change);
            var stretched = stretchSpansOverChange(doc, change);
            if (!old)
                return stretched;
            if (!stretched)
                return old;
            for (var i = 0; i < old.length; ++i) {
                var oldCur = old[i], stretchCur = stretched[i];
                if (oldCur && stretchCur) {
                    spans:
                        for (var j = 0; j < stretchCur.length; ++j) {
                            var span = stretchCur[j];
                            for (var k = 0; k < oldCur.length; ++k)
                                if (oldCur[k].marker == span.marker)
                                    continue spans;
                            oldCur.push(span);
                        }
                } else if (stretchCur) {
                    old[i] = stretchCur;
                }
            }
            return old;
        }
        function removeReadOnlyRanges(doc, from, to) {
            var markers = null;
            doc.iter(from.line, to.line + 1, function (line) {
                if (line.markedSpans)
                    for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                            (markers || (markers = [])).push(mark);
                    }
            });
            if (!markers)
                return null;
            var parts = [{
                        from: from,
                        to: to
                    }];
            for (var i = 0; i < markers.length; ++i) {
                var mk = markers[i], m = mk.find();
                for (var j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (posLess(p.to, m.from) || posLess(m.to, p.from))
                        continue;
                    var newParts = [
                            j,
                            1
                        ];
                    if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
                        newParts.push({
                            from: p.from,
                            to: m.from
                        });
                    if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
                        newParts.push({
                            from: m.to,
                            to: p.to
                        });
                    parts.splice.apply(parts, newParts);
                    j += newParts.length - 1;
                }
            }
            return parts;
        }
        function collapsedSpanAt(line, ch) {
            var sps = sawCollapsedSpans && line.markedSpans, found;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (!sp.marker.collapsed)
                        continue;
                    if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
                        found = sp.marker;
                }
            return found;
        }
        function collapsedSpanAtStart(line) {
            return collapsedSpanAt(line, -1);
        }
        function collapsedSpanAtEnd(line) {
            return collapsedSpanAt(line, line.text.length + 1);
        }
        function visualLine(doc, line) {
            var merged;
            while (merged = collapsedSpanAtStart(line))
                line = getLine(doc, merged.find().from.line);
            return line;
        }
        function lineIsHidden(doc, line) {
            var sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (!sp.marker.collapsed)
                        continue;
                    if (sp.from == null)
                        return true;
                    if (sp.marker.replacedWith)
                        continue;
                    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                        return true;
                }
        }
        function lineIsHiddenInner(doc, line, span) {
            if (span.to == null) {
                var end = span.marker.find().to, endLine = getLine(doc, end.line);
                return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
            }
            if (span.marker.inclusiveRight && span.to == line.text.length)
                return true;
            for (var sp, i = 0; i < line.markedSpans.length; ++i) {
                sp = line.markedSpans[i];
                if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                    return true;
            }
        }
        function detachMarkedSpans(line) {
            var spans = line.markedSpans;
            if (!spans)
                return;
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.detachLine(line);
            line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
            if (!spans)
                return;
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.attachLine(line);
            line.markedSpans = spans;
        }
        var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
                if (options)
                    for (var opt in options)
                        if (options.hasOwnProperty(opt))
                            this[opt] = options[opt];
                this.cm = cm;
                this.node = node;
            };
        eventMixin(LineWidget);
        function widgetOperation(f) {
            return function () {
                var withOp = !this.cm.curOp;
                if (withOp)
                    startOperation(this.cm);
                try {
                    var result = f.apply(this, arguments);
                } finally {
                    if (withOp)
                        endOperation(this.cm);
                }
                return result;
            };
        }
        LineWidget.prototype.clear = widgetOperation(function () {
            var ws = this.line.widgets, no = lineNo(this.line);
            if (no == null || !ws)
                return;
            for (var i = 0; i < ws.length; ++i)
                if (ws[i] == this)
                    ws.splice(i--, 1);
            if (!ws.length)
                this.line.widgets = null;
            var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
            updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
            if (aboveVisible)
                addToScrollPos(this.cm, 0, -this.height);
            regChange(this.cm, no, no + 1);
        });
        LineWidget.prototype.changed = widgetOperation(function () {
            var oldH = this.height;
            this.height = null;
            var diff = widgetHeight(this) - oldH;
            if (!diff)
                return;
            updateLineHeight(this.line, this.line.height + diff);
            var no = lineNo(this.line);
            regChange(this.cm, no, no + 1);
        });
        function widgetHeight(widget) {
            if (widget.height != null)
                return widget.height;
            if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
                removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
            return widget.height = widget.node.offsetHeight;
        }
        function addLineWidget(cm, handle, node, options) {
            var widget = new LineWidget(cm, node, options);
            if (widget.noHScroll)
                cm.display.alignWidgets = true;
            changeLine(cm, handle, function (line) {
                var widgets = line.widgets || (line.widgets = []);
                if (widget.insertAt == null)
                    widgets.push(widget);
                else
                    widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
                widget.line = line;
                if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
                    var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
                    updateLineHeight(line, line.height + widgetHeight(widget));
                    if (aboveVisible)
                        addToScrollPos(cm, 0, widget.height);
                }
                return true;
            });
            return widget;
        }
        var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
                this.text = text;
                attachMarkedSpans(this, markedSpans);
                this.height = estimateHeight ? estimateHeight(this) : 1;
            };
        eventMixin(Line);
        function updateLine(line, text, markedSpans, estimateHeight) {
            line.text = text;
            if (line.stateAfter)
                line.stateAfter = null;
            if (line.styles)
                line.styles = null;
            if (line.order != null)
                line.order = null;
            detachMarkedSpans(line);
            attachMarkedSpans(line, markedSpans);
            var estHeight = estimateHeight ? estimateHeight(line) : 1;
            if (estHeight != line.height)
                updateLineHeight(line, estHeight);
        }
        function cleanUpLine(line) {
            line.parent = null;
            detachMarkedSpans(line);
        }
        function runMode(cm, text, mode, state, f) {
            var flattenSpans = mode.flattenSpans;
            if (flattenSpans == null)
                flattenSpans = cm.options.flattenSpans;
            var curStart = 0, curStyle = null;
            var stream = new StringStream(text, cm.options.tabSize), style;
            if (text == '' && mode.blankLine)
                mode.blankLine(state);
            while (!stream.eol()) {
                if (stream.pos > cm.options.maxHighlightLength) {
                    flattenSpans = false;
                    stream.pos = text.length;
                    style = null;
                } else {
                    style = mode.token(stream, state);
                }
                if (!flattenSpans || curStyle != style) {
                    if (curStart < stream.start)
                        f(stream.start, curStyle);
                    curStart = stream.start;
                    curStyle = style;
                }
                stream.start = stream.pos;
            }
            while (curStart < stream.pos) {
                var pos = Math.min(stream.pos, curStart + 50000);
                f(pos, curStyle);
                curStart = pos;
            }
        }
        function highlightLine(cm, line, state) {
            var st = [cm.state.modeGen];
            runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
                st.push(end, style);
            });
            for (var o = 0; o < cm.state.overlays.length; ++o) {
                var overlay = cm.state.overlays[o], i = 1, at = 0;
                runMode(cm, line.text, overlay.mode, true, function (end, style) {
                    var start = i;
                    while (at < end) {
                        var i_end = st[i];
                        if (i_end > end)
                            st.splice(i, 1, end, st[i + 1], i_end);
                        i += 2;
                        at = Math.min(end, i_end);
                    }
                    if (!style)
                        return;
                    if (overlay.opaque) {
                        st.splice(start, i - start, end, style);
                        i = start + 2;
                    } else {
                        for (; start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = cur ? cur + ' ' + style : style;
                        }
                    }
                });
            }
            return st;
        }
        function getLineStyles(cm, line) {
            if (!line.styles || line.styles[0] != cm.state.modeGen)
                line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            return line.styles;
        }
        function processLine(cm, line, state) {
            var mode = cm.doc.mode;
            var stream = new StringStream(line.text, cm.options.tabSize);
            if (line.text == '' && mode.blankLine)
                mode.blankLine(state);
            while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
                mode.token(stream, state);
                stream.start = stream.pos;
            }
        }
        var styleToClassCache = {};
        function interpretTokenStyle(style, builder) {
            if (!style)
                return null;
            for (;;) {
                var lineClass = style.match(/(?:^|\s)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? 'bgClass' : 'textClass';
                if (builder[prop] == null)
                    builder[prop] = lineClass[2];
                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(builder[prop]))
                    builder[prop] += ' ' + lineClass[2];
            }
            return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
        }
        function buildLineContent(cm, realLine, measure, copyWidgets) {
            var merged, line = realLine, empty = true;
            while (merged = collapsedSpanAtStart(line))
                line = getLine(cm.doc, merged.find().from.line);
            var builder = {
                    pre: elt('pre'),
                    col: 0,
                    pos: 0,
                    measure: null,
                    measuredSomething: false,
                    cm: cm,
                    copyWidgets: copyWidgets
                };
            do {
                if (line.text)
                    empty = false;
                builder.measure = line == realLine && measure;
                builder.pos = 0;
                builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
                if ((ie || webkit) && cm.getOption('lineWrapping'))
                    builder.addToken = buildTokenSplitSpaces(builder.addToken);
                var next = insertLineContent(line, builder, getLineStyles(cm, line));
                if (measure && line == realLine && !builder.measuredSomething) {
                    measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
                    builder.measuredSomething = true;
                }
                if (next)
                    line = getLine(cm.doc, next.to.line);
            } while (next);
            if (measure && !builder.measuredSomething && !measure[0])
                measure[0] = builder.pre.appendChild(empty ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
            if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
                builder.pre.appendChild(document.createTextNode('\xa0'));
            var order;
            if (measure && ie && (order = getOrder(line))) {
                var l = order.length - 1;
                if (order[l].from == order[l].to)
                    --l;
                var last = order[l], prev = order[l - 1];
                if (last.from + 1 == last.to && prev && last.level < prev.level) {
                    var span = measure[builder.pos - 1];
                    if (span)
                        span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
                }
            }
            var textClass = builder.textClass ? builder.textClass + ' ' + (realLine.textClass || '') : realLine.textClass;
            if (textClass)
                builder.pre.className = textClass;
            signal(cm, 'renderLine', cm, realLine, builder.pre);
            return builder;
        }
        var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
        function buildToken(builder, text, style, startStyle, endStyle, title) {
            if (!text)
                return;
            if (!tokenSpecialChars.test(text)) {
                builder.col += text.length;
                var content = document.createTextNode(text);
            } else {
                var content = document.createDocumentFragment(), pos = 0;
                while (true) {
                    tokenSpecialChars.lastIndex = pos;
                    var m = tokenSpecialChars.exec(text);
                    var skipped = m ? m.index - pos : text.length - pos;
                    if (skipped) {
                        content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
                        builder.col += skipped;
                    }
                    if (!m)
                        break;
                    pos += skipped + 1;
                    if (m[0] == '\t') {
                        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                        content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
                        builder.col += tabWidth;
                    } else {
                        var token = elt('span', '\u2022', 'cm-invalidchar');
                        token.title = '\\u' + m[0].charCodeAt(0).toString(16);
                        content.appendChild(token);
                        builder.col += 1;
                    }
                }
            }
            if (style || startStyle || endStyle || builder.measure) {
                var fullStyle = style || '';
                if (startStyle)
                    fullStyle += startStyle;
                if (endStyle)
                    fullStyle += endStyle;
                var token = elt('span', [content], fullStyle);
                if (title)
                    token.title = title;
                return builder.pre.appendChild(token);
            }
            builder.pre.appendChild(content);
        }
        function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
            var wrapping = builder.cm.options.lineWrapping;
            for (var i = 0; i < text.length; ++i) {
                var ch = text.charAt(i), start = i == 0;
                if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
                    ch = text.slice(i, i + 2);
                    ++i;
                } else if (i && wrapping && spanAffectsWrapping(text, i)) {
                    builder.pre.appendChild(elt('wbr'));
                }
                var old = builder.measure[builder.pos];
                var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
                if (old)
                    span.leftSide = old.leftSide || old;
                if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
                    span.style.whiteSpace = 'normal';
                builder.pos += ch.length;
            }
            if (text.length)
                builder.measuredSomething = true;
        }
        function buildTokenSplitSpaces(inner) {
            function split(old) {
                var out = ' ';
                for (var i = 0; i < old.length - 2; ++i)
                    out += i % 2 ? ' ' : '\xa0';
                out += ' ';
                return out;
            }
            return function (builder, text, style, startStyle, endStyle, title) {
                return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
            };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
            var widget = !ignoreWidget && marker.replacedWith;
            if (widget) {
                if (builder.copyWidgets)
                    widget = widget.cloneNode(true);
                builder.pre.appendChild(widget);
                if (builder.measure) {
                    if (size) {
                        builder.measure[builder.pos] = widget;
                    } else {
                        var elt = zeroWidthElement(builder.cm.display.measure);
                        if (marker.type == 'bookmark' && !marker.insertLeft)
                            builder.measure[builder.pos] = builder.pre.appendChild(elt);
                        else if (builder.measure[builder.pos])
                            return;
                        else
                            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);
                    }
                    builder.measuredSomething = true;
                }
            }
            builder.pos += size;
        }
        function insertLineContent(line, builder, styles) {
            var spans = line.markedSpans, allText = line.text, at = 0;
            if (!spans) {
                for (var i = 1; i < styles.length; i += 2)
                    builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder));
                return;
            }
            var len = allText.length, pos = 0, i = 1, text = '', style;
            var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
            for (;;) {
                if (nextChange == pos) {
                    spanStyle = spanEndStyle = spanStartStyle = title = '';
                    collapsed = null;
                    nextChange = Infinity;
                    var foundBookmarks = [];
                    for (var j = 0; j < spans.length; ++j) {
                        var sp = spans[j], m = sp.marker;
                        if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
                            if (sp.to != null && nextChange > sp.to) {
                                nextChange = sp.to;
                                spanEndStyle = '';
                            }
                            if (m.className)
                                spanStyle += ' ' + m.className;
                            if (m.startStyle && sp.from == pos)
                                spanStartStyle += ' ' + m.startStyle;
                            if (m.endStyle && sp.to == nextChange)
                                spanEndStyle += ' ' + m.endStyle;
                            if (m.title && !title)
                                title = m.title;
                            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
                                collapsed = sp;
                        } else if (sp.from > pos && nextChange > sp.from) {
                            nextChange = sp.from;
                        }
                        if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
                            foundBookmarks.push(m);
                    }
                    if (collapsed && (collapsed.from || 0) == pos) {
                        buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                        if (collapsed.to == null)
                            return collapsed.marker.find();
                    }
                    if (!collapsed && foundBookmarks.length)
                        for (var j = 0; j < foundBookmarks.length; ++j)
                            buildCollapsedSpan(builder, 0, foundBookmarks[j]);
                }
                if (pos >= len)
                    break;
                var upto = Math.min(len, nextChange);
                while (true) {
                    if (text) {
                        var end = pos + text.length;
                        if (!collapsed) {
                            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title);
                        }
                        if (end >= upto) {
                            text = text.slice(upto - pos);
                            pos = upto;
                            break;
                        }
                        pos = end;
                        spanStartStyle = '';
                    }
                    text = allText.slice(at, at = styles[i++]);
                    style = interpretTokenStyle(styles[i++], builder);
                }
            }
        }
        function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
            function spansFor(n) {
                return markedSpans ? markedSpans[n] : null;
            }
            function update(line, text, spans) {
                updateLine(line, text, spans, estimateHeight);
                signalLater(line, 'change', line, change);
            }
            var from = change.from, to = change.to, text = change.text;
            var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
            var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
            if (from.ch == 0 && to.ch == 0 && lastText == '') {
                for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                update(lastLine, lastLine.text, lastSpans);
                if (nlines)
                    doc.remove(from.line, nlines);
                if (added.length)
                    doc.insert(from.line, added);
            } else if (firstLine == lastLine) {
                if (text.length == 1) {
                    update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
                } else {
                    for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
                        added.push(new Line(text[i], spansFor(i), estimateHeight));
                    added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                    doc.insert(from.line + 1, added);
                }
            } else if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
                doc.remove(from.line + 1, nlines);
            } else {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                if (nlines > 1)
                    doc.remove(from.line + 1, nlines - 1);
                doc.insert(from.line + 1, added);
            }
            signalLater(doc, 'change', doc, change);
            setSelection(doc, selAfter.anchor, selAfter.head, null, true);
        }
        function LeafChunk(lines) {
            this.lines = lines;
            this.parent = null;
            for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
                lines[i].parent = this;
                height += lines[i].height;
            }
            this.height = height;
        }
        LeafChunk.prototype = {
            chunkSize: function () {
                return this.lines.length;
            },
            removeInner: function (at, n) {
                for (var i = at, e = at + n; i < e; ++i) {
                    var line = this.lines[i];
                    this.height -= line.height;
                    cleanUpLine(line);
                    signalLater(line, 'delete');
                }
                this.lines.splice(at, n);
            },
            collapse: function (lines) {
                lines.splice.apply(lines, [
                    lines.length,
                    0
                ].concat(this.lines));
            },
            insertInner: function (at, lines, height) {
                this.height += height;
                this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                for (var i = 0, e = lines.length; i < e; ++i)
                    lines[i].parent = this;
            },
            iterN: function (at, n, op) {
                for (var e = at + n; at < e; ++at)
                    if (op(this.lines[at]))
                        return true;
            }
        };
        function BranchChunk(children) {
            this.children = children;
            var size = 0, height = 0;
            for (var i = 0, e = children.length; i < e; ++i) {
                var ch = children[i];
                size += ch.chunkSize();
                height += ch.height;
                ch.parent = this;
            }
            this.size = size;
            this.height = height;
            this.parent = null;
        }
        BranchChunk.prototype = {
            chunkSize: function () {
                return this.size;
            },
            removeInner: function (at, n) {
                this.size -= n;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var rm = Math.min(n, sz - at), oldHeight = child.height;
                        child.removeInner(at, rm);
                        this.height -= oldHeight - child.height;
                        if (sz == rm) {
                            this.children.splice(i--, 1);
                            child.parent = null;
                        }
                        if ((n -= rm) == 0)
                            break;
                        at = 0;
                    } else
                        at -= sz;
                }
                if (this.size - n < 25) {
                    var lines = [];
                    this.collapse(lines);
                    this.children = [new LeafChunk(lines)];
                    this.children[0].parent = this;
                }
            },
            collapse: function (lines) {
                for (var i = 0, e = this.children.length; i < e; ++i)
                    this.children[i].collapse(lines);
            },
            insertInner: function (at, lines, height) {
                this.size += lines.length;
                this.height += height;
                for (var i = 0, e = this.children.length; i < e; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at <= sz) {
                        child.insertInner(at, lines, height);
                        if (child.lines && child.lines.length > 50) {
                            while (child.lines.length > 50) {
                                var spilled = child.lines.splice(child.lines.length - 25, 25);
                                var newleaf = new LeafChunk(spilled);
                                child.height -= newleaf.height;
                                this.children.splice(i + 1, 0, newleaf);
                                newleaf.parent = this;
                            }
                            this.maybeSpill();
                        }
                        break;
                    }
                    at -= sz;
                }
            },
            maybeSpill: function () {
                if (this.children.length <= 10)
                    return;
                var me = this;
                do {
                    var spilled = me.children.splice(me.children.length - 5, 5);
                    var sibling = new BranchChunk(spilled);
                    if (!me.parent) {
                        var copy = new BranchChunk(me.children);
                        copy.parent = me;
                        me.children = [
                            copy,
                            sibling
                        ];
                        me = copy;
                    } else {
                        me.size -= sibling.size;
                        me.height -= sibling.height;
                        var myIndex = indexOf(me.parent.children, me);
                        me.parent.children.splice(myIndex + 1, 0, sibling);
                    }
                    sibling.parent = me.parent;
                } while (me.children.length > 10);
                me.parent.maybeSpill();
            },
            iterN: function (at, n, op) {
                for (var i = 0, e = this.children.length; i < e; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var used = Math.min(n, sz - at);
                        if (child.iterN(at, used, op))
                            return true;
                        if ((n -= used) == 0)
                            break;
                        at = 0;
                    } else
                        at -= sz;
                }
            }
        };
        var nextDocId = 0;
        var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
                if (!(this instanceof Doc))
                    return new Doc(text, mode, firstLine);
                if (firstLine == null)
                    firstLine = 0;
                BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
                this.first = firstLine;
                this.scrollTop = this.scrollLeft = 0;
                this.cantEdit = false;
                this.history = makeHistory();
                this.cleanGeneration = 1;
                this.frontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = {
                    from: start,
                    to: start,
                    head: start,
                    anchor: start,
                    shift: false,
                    extend: false,
                    goalColumn: null
                };
                this.id = ++nextDocId;
                this.modeOption = mode;
                if (typeof text == 'string')
                    text = splitLines(text);
                updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }, null, {
                    head: start,
                    anchor: start
                });
            };
        Doc.prototype = createObj(BranchChunk.prototype, {
            constructor: Doc,
            iter: function (from, to, op) {
                if (op)
                    this.iterN(from - this.first, to - from, op);
                else
                    this.iterN(this.first, this.first + this.size, from);
            },
            insert: function (at, lines) {
                var height = 0;
                for (var i = 0, e = lines.length; i < e; ++i)
                    height += lines[i].height;
                this.insertInner(at - this.first, lines, height);
            },
            remove: function (at, n) {
                this.removeInner(at - this.first, n);
            },
            getValue: function (lineSep) {
                var lines = getLines(this, this.first, this.first + this.size);
                if (lineSep === false)
                    return lines;
                return lines.join(lineSep || '\n');
            },
            setValue: function (code) {
                var top = Pos(this.first, 0), last = this.first + this.size - 1;
                makeChange(this, {
                    from: top,
                    to: Pos(last, getLine(this, last).text.length),
                    text: splitLines(code),
                    origin: 'setValue'
                }, {
                    head: top,
                    anchor: top
                }, true);
            },
            replaceRange: function (code, from, to, origin) {
                from = clipPos(this, from);
                to = to ? clipPos(this, to) : from;
                replaceRange(this, code, from, to, origin);
            },
            getRange: function (from, to, lineSep) {
                var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                if (lineSep === false)
                    return lines;
                return lines.join(lineSep || '\n');
            },
            getLine: function (line) {
                var l = this.getLineHandle(line);
                return l && l.text;
            },
            setLine: function (line, text) {
                if (isLine(this, line))
                    replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
            },
            removeLine: function (line) {
                if (line)
                    replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
                else
                    replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
            },
            getLineHandle: function (line) {
                if (isLine(this, line))
                    return getLine(this, line);
            },
            getLineNumber: function (line) {
                return lineNo(line);
            },
            getLineHandleVisualStart: function (line) {
                if (typeof line == 'number')
                    line = getLine(this, line);
                return visualLine(this, line);
            },
            lineCount: function () {
                return this.size;
            },
            firstLine: function () {
                return this.first;
            },
            lastLine: function () {
                return this.first + this.size - 1;
            },
            clipPos: function (pos) {
                return clipPos(this, pos);
            },
            getCursor: function (start) {
                var sel = this.sel, pos;
                if (start == null || start == 'head')
                    pos = sel.head;
                else if (start == 'anchor')
                    pos = sel.anchor;
                else if (start == 'end' || start === false)
                    pos = sel.to;
                else
                    pos = sel.from;
                return copyPos(pos);
            },
            somethingSelected: function () {
                return !posEq(this.sel.head, this.sel.anchor);
            },
            setCursor: docOperation(function (line, ch, extend) {
                var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
                if (extend)
                    extendSelection(this, pos);
                else
                    setSelection(this, pos, pos);
            }),
            setSelection: docOperation(function (anchor, head, bias) {
                setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);
            }),
            extendSelection: docOperation(function (from, to, bias) {
                extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);
            }),
            getSelection: function (lineSep) {
                return this.getRange(this.sel.from, this.sel.to, lineSep);
            },
            replaceSelection: function (code, collapse, origin) {
                makeChange(this, {
                    from: this.sel.from,
                    to: this.sel.to,
                    text: splitLines(code),
                    origin: origin
                }, collapse || 'around');
            },
            undo: docOperation(function () {
                makeChangeFromHistory(this, 'undo');
            }),
            redo: docOperation(function () {
                makeChangeFromHistory(this, 'redo');
            }),
            setExtending: function (val) {
                this.sel.extend = val;
            },
            historySize: function () {
                var hist = this.history;
                return {
                    undo: hist.done.length,
                    redo: hist.undone.length
                };
            },
            clearHistory: function () {
                this.history = makeHistory(this.history.maxGeneration);
            },
            markClean: function () {
                this.cleanGeneration = this.changeGeneration();
            },
            changeGeneration: function () {
                this.history.lastOp = this.history.lastOrigin = null;
                return this.history.generation;
            },
            isClean: function (gen) {
                return this.history.generation == (gen || this.cleanGeneration);
            },
            getHistory: function () {
                return {
                    done: copyHistoryArray(this.history.done),
                    undone: copyHistoryArray(this.history.undone)
                };
            },
            setHistory: function (histData) {
                var hist = this.history = makeHistory(this.history.maxGeneration);
                hist.done = histData.done.slice(0);
                hist.undone = histData.undone.slice(0);
            },
            markText: function (from, to, options) {
                return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
            },
            setBookmark: function (pos, options) {
                var realOpts = {
                        replacedWith: options && (options.nodeType == null ? options.widget : options),
                        insertLeft: options && options.insertLeft
                    };
                pos = clipPos(this, pos);
                return markText(this, pos, pos, realOpts, 'bookmark');
            },
            findMarksAt: function (pos) {
                pos = clipPos(this, pos);
                var markers = [], spans = getLine(this, pos.line).markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                            markers.push(span.marker.parent || span.marker);
                    }
                return markers;
            },
            getAllMarks: function () {
                var markers = [];
                this.iter(function (line) {
                    var sps = line.markedSpans;
                    if (sps)
                        for (var i = 0; i < sps.length; ++i)
                            if (sps[i].from != null)
                                markers.push(sps[i].marker);
                });
                return markers;
            },
            posFromIndex: function (off) {
                var ch, lineNo = this.first;
                this.iter(function (line) {
                    var sz = line.text.length + 1;
                    if (sz > off) {
                        ch = off;
                        return true;
                    }
                    off -= sz;
                    ++lineNo;
                });
                return clipPos(this, Pos(lineNo, ch));
            },
            indexFromPos: function (coords) {
                coords = clipPos(this, coords);
                var index = coords.ch;
                if (coords.line < this.first || coords.ch < 0)
                    return 0;
                this.iter(this.first, coords.line, function (line) {
                    index += line.text.length + 1;
                });
                return index;
            },
            copy: function (copyHistory) {
                var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
                doc.scrollTop = this.scrollTop;
                doc.scrollLeft = this.scrollLeft;
                doc.sel = {
                    from: this.sel.from,
                    to: this.sel.to,
                    head: this.sel.head,
                    anchor: this.sel.anchor,
                    shift: this.sel.shift,
                    extend: false,
                    goalColumn: this.sel.goalColumn
                };
                if (copyHistory) {
                    doc.history.undoDepth = this.history.undoDepth;
                    doc.setHistory(this.getHistory());
                }
                return doc;
            },
            linkedDoc: function (options) {
                if (!options)
                    options = {};
                var from = this.first, to = this.first + this.size;
                if (options.from != null && options.from > from)
                    from = options.from;
                if (options.to != null && options.to < to)
                    to = options.to;
                var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
                if (options.sharedHist)
                    copy.history = this.history;
                (this.linked || (this.linked = [])).push({
                    doc: copy,
                    sharedHist: options.sharedHist
                });
                copy.linked = [{
                        doc: this,
                        isParent: true,
                        sharedHist: options.sharedHist
                    }];
                return copy;
            },
            unlinkDoc: function (other) {
                if (other instanceof CodeMirror)
                    other = other.doc;
                if (this.linked)
                    for (var i = 0; i < this.linked.length; ++i) {
                        var link = this.linked[i];
                        if (link.doc != other)
                            continue;
                        this.linked.splice(i, 1);
                        other.unlinkDoc(this);
                        break;
                    }
                if (other.history == this.history) {
                    var splitIds = [other.id];
                    linkedDocs(other, function (doc) {
                        splitIds.push(doc.id);
                    }, true);
                    other.history = makeHistory();
                    other.history.done = copyHistoryArray(this.history.done, splitIds);
                    other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                }
            },
            iterLinkedDocs: function (f) {
                linkedDocs(this, f);
            },
            getMode: function () {
                return this.mode;
            },
            getEditor: function () {
                return this.cm;
            }
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
        for (var prop in Doc.prototype)
            if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
                CodeMirror.prototype[prop] = function (method) {
                    return function () {
                        return method.apply(this.doc, arguments);
                    };
                }(Doc.prototype[prop]);
        eventMixin(Doc);
        function linkedDocs(doc, f, sharedHistOnly) {
            function propagate(doc, skip, sharedHist) {
                if (doc.linked)
                    for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc == skip)
                            continue;
                        var shared = sharedHist && rel.sharedHist;
                        if (sharedHistOnly && !shared)
                            continue;
                        f(rel.doc, shared);
                        propagate(rel.doc, doc, shared);
                    }
            }
            propagate(doc, null, true);
        }
        function attachDoc(cm, doc) {
            if (doc.cm)
                throw new Error('This document is already in use.');
            cm.doc = doc;
            doc.cm = cm;
            estimateLineHeights(cm);
            loadMode(cm);
            if (!cm.options.lineWrapping)
                computeMaxLength(cm);
            cm.options.mode = doc.modeOption;
            regChange(cm);
        }
        function getLine(chunk, n) {
            n -= chunk.first;
            while (!chunk.lines) {
                for (var i = 0;; ++i) {
                    var child = chunk.children[i], sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break;
                    }
                    n -= sz;
                }
            }
            return chunk.lines[n];
        }
        function getBetween(doc, start, end) {
            var out = [], n = start.line;
            doc.iter(start.line, end.line + 1, function (line) {
                var text = line.text;
                if (n == end.line)
                    text = text.slice(0, end.ch);
                if (n == start.line)
                    text = text.slice(start.ch);
                out.push(text);
                ++n;
            });
            return out;
        }
        function getLines(doc, from, to) {
            var out = [];
            doc.iter(from, to, function (line) {
                out.push(line.text);
            });
            return out;
        }
        function updateLineHeight(line, height) {
            var diff = height - line.height;
            for (var n = line; n; n = n.parent)
                n.height += diff;
        }
        function lineNo(line) {
            if (line.parent == null)
                return null;
            var cur = line.parent, no = indexOf(cur.lines, line);
            for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
                for (var i = 0;; ++i) {
                    if (chunk.children[i] == cur)
                        break;
                    no += chunk.children[i].chunkSize();
                }
            }
            return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
            var n = chunk.first;
            outer:
                do {
                    for (var i = 0, e = chunk.children.length; i < e; ++i) {
                        var child = chunk.children[i], ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch;
                        n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
            for (var i = 0, e = chunk.lines.length; i < e; ++i) {
                var line = chunk.lines[i], lh = line.height;
                if (h < lh)
                    break;
                h -= lh;
            }
            return n + i;
        }
        function heightAtLine(cm, lineObj) {
            lineObj = visualLine(cm.doc, lineObj);
            var h = 0, chunk = lineObj.parent;
            for (var i = 0; i < chunk.lines.length; ++i) {
                var line = chunk.lines[i];
                if (line == lineObj)
                    break;
                else
                    h += line.height;
            }
            for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
                for (var i = 0; i < p.children.length; ++i) {
                    var cur = p.children[i];
                    if (cur == chunk)
                        break;
                    else
                        h += cur.height;
                }
            }
            return h;
        }
        function getOrder(line) {
            var order = line.order;
            if (order == null)
                order = line.order = bidiOrdering(line.text);
            return order;
        }
        function makeHistory(startGen) {
            return {
                done: [],
                undone: [],
                undoDepth: Infinity,
                lastTime: 0,
                lastOp: null,
                lastOrigin: null,
                generation: startGen || 1,
                maxGeneration: startGen || 1
            };
        }
        function attachLocalSpans(doc, change, from, to) {
            var existing = change['spans_' + doc.id], n = 0;
            doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
                if (line.markedSpans)
                    (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
                ++n;
            });
        }
        function historyChangeFromChange(doc, change) {
            var from = {
                    line: change.from.line,
                    ch: change.from.ch
                };
            var histChange = {
                    from: from,
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
            linkedDocs(doc, function (doc) {
                attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
            }, true);
            return histChange;
        }
        function addToHistory(doc, change, selAfter, opId) {
            var hist = doc.history;
            hist.undone.length = 0;
            var time = +new Date(), cur = lst(hist.done);
            if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
                var last = lst(cur.changes);
                if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
                    last.to = changeEnd(change);
                } else {
                    cur.changes.push(historyChangeFromChange(doc, change));
                }
                cur.anchorAfter = selAfter.anchor;
                cur.headAfter = selAfter.head;
            } else {
                cur = {
                    changes: [historyChangeFromChange(doc, change)],
                    generation: hist.generation,
                    anchorBefore: doc.sel.anchor,
                    headBefore: doc.sel.head,
                    anchorAfter: selAfter.anchor,
                    headAfter: selAfter.head
                };
                hist.done.push(cur);
                hist.generation = ++hist.maxGeneration;
                while (hist.done.length > hist.undoDepth)
                    hist.done.shift();
            }
            hist.lastTime = time;
            hist.lastOp = opId;
            hist.lastOrigin = change.origin;
        }
        function removeClearedSpans(spans) {
            if (!spans)
                return null;
            for (var i = 0, out; i < spans.length; ++i) {
                if (spans[i].marker.explicitlyCleared) {
                    if (!out)
                        out = spans.slice(0, i);
                } else if (out)
                    out.push(spans[i]);
            }
            return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc, change) {
            var found = change['spans_' + doc.id];
            if (!found)
                return null;
            for (var i = 0, nw = []; i < change.text.length; ++i)
                nw.push(removeClearedSpans(found[i]));
            return nw;
        }
        function copyHistoryArray(events, newGroup) {
            for (var i = 0, copy = []; i < events.length; ++i) {
                var event = events[i], changes = event.changes, newChanges = [];
                copy.push({
                    changes: newChanges,
                    anchorBefore: event.anchorBefore,
                    headBefore: event.headBefore,
                    anchorAfter: event.anchorAfter,
                    headAfter: event.headAfter
                });
                for (var j = 0; j < changes.length; ++j) {
                    var change = changes[j], m;
                    newChanges.push({
                        from: change.from,
                        to: change.to,
                        text: change.text
                    });
                    if (newGroup)
                        for (var prop in change)
                            if (m = prop.match(/^spans_(\d+)$/)) {
                                if (indexOf(newGroup, Number(m[1])) > -1) {
                                    lst(newChanges)[prop] = change[prop];
                                    delete change[prop];
                                }
                            }
                }
            }
            return copy;
        }
        function rebaseHistSel(pos, from, to, diff) {
            if (to < pos.line) {
                pos.line += diff;
            } else if (from < pos.line) {
                pos.line = from;
                pos.ch = 0;
            }
        }
        function rebaseHistArray(array, from, to, diff) {
            for (var i = 0; i < array.length; ++i) {
                var sub = array[i], ok = true;
                for (var j = 0; j < sub.changes.length; ++j) {
                    var cur = sub.changes[j];
                    if (!sub.copied) {
                        cur.from = copyPos(cur.from);
                        cur.to = copyPos(cur.to);
                    }
                    if (to < cur.from.line) {
                        cur.from.line += diff;
                        cur.to.line += diff;
                    } else if (from <= cur.to.line) {
                        ok = false;
                        break;
                    }
                }
                if (!sub.copied) {
                    sub.anchorBefore = copyPos(sub.anchorBefore);
                    sub.headBefore = copyPos(sub.headBefore);
                    sub.anchorAfter = copyPos(sub.anchorAfter);
                    sub.readAfter = copyPos(sub.headAfter);
                    sub.copied = true;
                }
                if (!ok) {
                    array.splice(0, i + 1);
                    i = 0;
                } else {
                    rebaseHistSel(sub.anchorBefore);
                    rebaseHistSel(sub.headBefore);
                    rebaseHistSel(sub.anchorAfter);
                    rebaseHistSel(sub.headAfter);
                }
            }
        }
        function rebaseHist(hist, change) {
            var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
            rebaseHistArray(hist.done, from, to, diff);
            rebaseHistArray(hist.undone, from, to, diff);
        }
        function stopMethod() {
            e_stop(this);
        }
        function addStop(event) {
            if (!event.stop)
                event.stop = stopMethod;
            return event;
        }
        function e_preventDefault(e) {
            if (e.preventDefault)
                e.preventDefault();
            else
                e.returnValue = false;
        }
        function e_stopPropagation(e) {
            if (e.stopPropagation)
                e.stopPropagation();
            else
                e.cancelBubble = true;
        }
        function e_defaultPrevented(e) {
            return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
        }
        function e_stop(e) {
            e_preventDefault(e);
            e_stopPropagation(e);
        }
        CodeMirror.e_stop = e_stop;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        function e_target(e) {
            return e.target || e.srcElement;
        }
        function e_button(e) {
            var b = e.which;
            if (b == null) {
                if (e.button & 1)
                    b = 1;
                else if (e.button & 2)
                    b = 3;
                else if (e.button & 4)
                    b = 2;
            }
            if (mac && e.ctrlKey && b == 1)
                b = 3;
            return b;
        }
        function on(emitter, type, f) {
            if (emitter.addEventListener)
                emitter.addEventListener(type, f, false);
            else if (emitter.attachEvent)
                emitter.attachEvent('on' + type, f);
            else {
                var map = emitter._handlers || (emitter._handlers = {});
                var arr = map[type] || (map[type] = []);
                arr.push(f);
            }
        }
        function off(emitter, type, f) {
            if (emitter.removeEventListener)
                emitter.removeEventListener(type, f, false);
            else if (emitter.detachEvent)
                emitter.detachEvent('on' + type, f);
            else {
                var arr = emitter._handlers && emitter._handlers[type];
                if (!arr)
                    return;
                for (var i = 0; i < arr.length; ++i)
                    if (arr[i] == f) {
                        arr.splice(i, 1);
                        break;
                    }
            }
        }
        function signal(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            var args = Array.prototype.slice.call(arguments, 2);
            for (var i = 0; i < arr.length; ++i)
                arr[i].apply(null, args);
        }
        var delayedCallbacks, delayedCallbackDepth = 0;
        function signalLater(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            var args = Array.prototype.slice.call(arguments, 2);
            if (!delayedCallbacks) {
                ++delayedCallbackDepth;
                delayedCallbacks = [];
                setTimeout(fireDelayed, 0);
            }
            function bnd(f) {
                return function () {
                    f.apply(null, args);
                };
            }
            for (var i = 0; i < arr.length; ++i)
                delayedCallbacks.push(bnd(arr[i]));
        }
        function signalDOMEvent(cm, e, override) {
            signal(cm, override || e.type, cm, e);
            return e_defaultPrevented(e) || e.codemirrorIgnore;
        }
        function fireDelayed() {
            --delayedCallbackDepth;
            var delayed = delayedCallbacks;
            delayedCallbacks = null;
            for (var i = 0; i < delayed.length; ++i)
                delayed[i]();
        }
        function hasHandler(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            return arr && arr.length > 0;
        }
        CodeMirror.on = on;
        CodeMirror.off = off;
        CodeMirror.signal = signal;
        function eventMixin(ctor) {
            ctor.prototype.on = function (type, f) {
                on(this, type, f);
            };
            ctor.prototype.off = function (type, f) {
                off(this, type, f);
            };
        }
        var scrollerCutOff = 30;
        var Pass = CodeMirror.Pass = {
                toString: function () {
                    return 'CodeMirror.Pass';
                }
            };
        function Delayed() {
            this.id = null;
        }
        Delayed.prototype = {
            set: function (ms, f) {
                clearTimeout(this.id);
                this.id = setTimeout(f, ms);
            }
        };
        function countColumn(string, end, tabSize, startIndex, startValue) {
            if (end == null) {
                end = string.search(/[^\s\u00a0]/);
                if (end == -1)
                    end = string.length;
            }
            for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
                if (string.charAt(i) == '\t')
                    n += tabSize - n % tabSize;
                else
                    ++n;
            }
            return n;
        }
        CodeMirror.countColumn = countColumn;
        var spaceStrs = [''];
        function spaceStr(n) {
            while (spaceStrs.length <= n)
                spaceStrs.push(lst(spaceStrs) + ' ');
            return spaceStrs[n];
        }
        function lst(arr) {
            return arr[arr.length - 1];
        }
        function selectInput(node) {
            if (ios) {
                node.selectionStart = 0;
                node.selectionEnd = node.value.length;
            } else {
                try {
                    node.select();
                } catch (_e) {
                }
            }
        }
        function indexOf(collection, elt) {
            if (collection.indexOf)
                return collection.indexOf(elt);
            for (var i = 0, e = collection.length; i < e; ++i)
                if (collection[i] == elt)
                    return i;
            return -1;
        }
        function createObj(base, props) {
            function Obj() {
            }
            Obj.prototype = base;
            var inst = new Obj();
            if (props)
                copyObj(props, inst);
            return inst;
        }
        function copyObj(obj, target) {
            if (!target)
                target = {};
            for (var prop in obj)
                if (obj.hasOwnProperty(prop))
                    target[prop] = obj[prop];
            return target;
        }
        function emptyArray(size) {
            for (var a = [], i = 0; i < size; ++i)
                a.push(undefined);
            return a;
        }
        function bind(f) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function () {
                return f.apply(null, args);
            };
        }
        var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordChar(ch) {
            return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isEmpty(obj) {
            for (var n in obj)
                if (obj.hasOwnProperty(n) && obj[n])
                    return false;
            return true;
        }
        var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
        function elt(tag, content, className, style) {
            var e = document.createElement(tag);
            if (className)
                e.className = className;
            if (style)
                e.style.cssText = style;
            if (typeof content == 'string')
                setTextContent(e, content);
            else if (content)
                for (var i = 0; i < content.length; ++i)
                    e.appendChild(content[i]);
            return e;
        }
        function removeChildren(e) {
            for (var count = e.childNodes.length; count > 0; --count)
                e.removeChild(e.firstChild);
            return e;
        }
        function removeChildrenAndAdd(parent, e) {
            return removeChildren(parent).appendChild(e);
        }
        function setTextContent(e, str) {
            if (ie_lt9) {
                e.innerHTML = '';
                e.appendChild(document.createTextNode(str));
            } else
                e.textContent = str;
        }
        function getRect(node) {
            return node.getBoundingClientRect();
        }
        CodeMirror.replaceGetRect = function (f) {
            getRect = f;
        };
        var dragAndDrop = function () {
                if (ie_lt9)
                    return false;
                var div = elt('div');
                return 'draggable' in div || 'dragDrop' in div;
            }();
        function spanAffectsWrapping() {
            return false;
        }
        if (gecko)
            spanAffectsWrapping = function (str, i) {
                return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
            };
        else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
            spanAffectsWrapping = function (str, i) {
                return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
            };
        else if (webkit && /Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent))
            spanAffectsWrapping = function (str, i) {
                var code = str.charCodeAt(i - 1);
                return code >= 8208 && code <= 8212;
            };
        else if (webkit)
            spanAffectsWrapping = function (str, i) {
                if (i > 1 && str.charCodeAt(i - 1) == 45) {
                    if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i)))
                        return true;
                    if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i)))
                        return false;
                }
                return /[~!#%&*)=+}\]\\|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|…[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
            };
        var knownScrollbarWidth;
        function scrollbarWidth(measure) {
            if (knownScrollbarWidth != null)
                return knownScrollbarWidth;
            var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
            removeChildrenAndAdd(measure, test);
            if (test.offsetWidth)
                knownScrollbarWidth = test.offsetHeight - test.clientHeight;
            return knownScrollbarWidth || 0;
        }
        var zwspSupported;
        function zeroWidthElement(measure) {
            if (zwspSupported == null) {
                var test = elt('span', '\u200b');
                removeChildrenAndAdd(measure, elt('span', [
                    test,
                    document.createTextNode('x')
                ]));
                if (measure.firstChild.offsetHeight != 0)
                    zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
            }
            if (zwspSupported)
                return elt('span', '\u200b');
            else
                return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
        }
        var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
                var pos = 0, result = [], l = string.length;
                while (pos <= l) {
                    var nl = string.indexOf('\n', pos);
                    if (nl == -1)
                        nl = string.length;
                    var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
                    var rt = line.indexOf('\r');
                    if (rt != -1) {
                        result.push(line.slice(0, rt));
                        pos += rt + 1;
                    } else {
                        result.push(line);
                        pos = nl + 1;
                    }
                }
                return result;
            } : function (string) {
                return string.split(/\r\n?|\n/);
            };
        CodeMirror.splitLines = splitLines;
        var hasSelection = window.getSelection ? function (te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return false;
                }
            } : function (te) {
                try {
                    var range = te.ownerDocument.selection.createRange();
                } catch (e) {
                }
                if (!range || range.parentElement() != te)
                    return false;
                return range.compareEndPoints('StartToEnd', range) != 0;
            };
        var hasCopyEvent = function () {
                var e = elt('div');
                if ('oncopy' in e)
                    return true;
                e.setAttribute('oncopy', 'return;');
                return typeof e.oncopy == 'function';
            }();
        var keyNames = {
                3: 'Enter',
                8: 'Backspace',
                9: 'Tab',
                13: 'Enter',
                16: 'Shift',
                17: 'Ctrl',
                18: 'Alt',
                19: 'Pause',
                20: 'CapsLock',
                27: 'Esc',
                32: 'Space',
                33: 'PageUp',
                34: 'PageDown',
                35: 'End',
                36: 'Home',
                37: 'Left',
                38: 'Up',
                39: 'Right',
                40: 'Down',
                44: 'PrintScrn',
                45: 'Insert',
                46: 'Delete',
                59: ';',
                91: 'Mod',
                92: 'Mod',
                93: 'Mod',
                109: '-',
                107: '=',
                127: 'Delete',
                186: ';',
                187: '=',
                188: ',',
                189: '-',
                190: '.',
                191: '/',
                192: '`',
                219: '[',
                220: '\\',
                221: ']',
                222: '\'',
                63276: 'PageUp',
                63277: 'PageDown',
                63275: 'End',
                63273: 'Home',
                63234: 'Left',
                63232: 'Up',
                63235: 'Right',
                63233: 'Down',
                63302: 'Insert',
                63272: 'Delete'
            };
        CodeMirror.keyNames = keyNames;
        (function () {
            for (var i = 0; i < 10; i++)
                keyNames[i + 48] = String(i);
            for (var i = 65; i <= 90; i++)
                keyNames[i] = String.fromCharCode(i);
            for (var i = 1; i <= 12; i++)
                keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
        }());
        function iterateBidiSections(order, from, to, f) {
            if (!order)
                return f(from, to, 'ltr');
            var found = false;
            for (var i = 0; i < order.length; ++i) {
                var part = order[i];
                if (part.from < to && part.to > from || from == to && part.to == from) {
                    f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
                    found = true;
                }
            }
            if (!found)
                f(from, to, 'ltr');
        }
        function bidiLeft(part) {
            return part.level % 2 ? part.to : part.from;
        }
        function bidiRight(part) {
            return part.level % 2 ? part.from : part.to;
        }
        function lineLeft(line) {
            var order = getOrder(line);
            return order ? bidiLeft(order[0]) : 0;
        }
        function lineRight(line) {
            var order = getOrder(line);
            if (!order)
                return line.text.length;
            return bidiRight(lst(order));
        }
        function lineStart(cm, lineN) {
            var line = getLine(cm.doc, lineN);
            var visual = visualLine(cm.doc, line);
            if (visual != line)
                lineN = lineNo(visual);
            var order = getOrder(visual);
            var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
            return Pos(lineN, ch);
        }
        function lineEnd(cm, lineN) {
            var merged, line;
            while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
                lineN = merged.find().to.line;
            var order = getOrder(line);
            var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
            return Pos(lineN, ch);
        }
        function compareBidiLevel(order, a, b) {
            var linedir = order[0].level;
            if (a == linedir)
                return true;
            if (b == linedir)
                return false;
            return a < b;
        }
        var bidiOther;
        function getBidiPartAt(order, pos) {
            for (var i = 0, found; i < order.length; ++i) {
                var cur = order[i];
                if (cur.from < pos && cur.to > pos) {
                    bidiOther = null;
                    return i;
                }
                if (cur.from == pos || cur.to == pos) {
                    if (found == null) {
                        found = i;
                    } else if (compareBidiLevel(order, cur.level, order[found].level)) {
                        bidiOther = found;
                        return i;
                    } else {
                        bidiOther = i;
                        return found;
                    }
                }
            }
            bidiOther = null;
            return found;
        }
        function moveInLine(line, pos, dir, byUnit) {
            if (!byUnit)
                return pos + dir;
            do
                pos += dir;
            while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
            return pos;
        }
        function moveVisually(line, start, dir, byUnit) {
            var bidi = getOrder(line);
            if (!bidi)
                return moveLogically(line, start, dir, byUnit);
            var pos = getBidiPartAt(bidi, start), part = bidi[pos];
            var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
            for (;;) {
                if (target > part.from && target < part.to)
                    return target;
                if (target == part.from || target == part.to) {
                    if (getBidiPartAt(bidi, target) == pos)
                        return target;
                    part = bidi[pos += dir];
                    return dir > 0 == part.level % 2 ? part.to : part.from;
                } else {
                    part = bidi[pos += dir];
                    if (!part)
                        return null;
                    if (dir > 0 == part.level % 2)
                        target = moveInLine(line, part.to, -1, byUnit);
                    else
                        target = moveInLine(line, part.from, 1, byUnit);
                }
            }
        }
        function moveLogically(line, start, dir, byUnit) {
            var target = start + dir;
            if (byUnit)
                while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
                    target += dir;
            return target < 0 || target > line.text.length ? null : target;
        }
        var bidiOrdering = function () {
                var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
                var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
                function charType(code) {
                    if (code <= 255)
                        return lowTypes.charAt(code);
                    else if (1424 <= code && code <= 1524)
                        return 'R';
                    else if (1536 <= code && code <= 1791)
                        return arabicTypes.charAt(code - 1536);
                    else if (1792 <= code && code <= 2220)
                        return 'r';
                    else
                        return 'L';
                }
                var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
                var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
                var outerType = 'L';
                return function (str) {
                    if (!bidiRE.test(str))
                        return false;
                    var len = str.length, types = [];
                    for (var i = 0, type; i < len; ++i)
                        types.push(type = charType(str.charCodeAt(i)));
                    for (var i = 0, prev = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == 'm')
                            types[i] = prev;
                        else
                            prev = type;
                    }
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == '1' && cur == 'r')
                            types[i] = 'n';
                        else if (isStrong.test(type)) {
                            cur = type;
                            if (type == 'r')
                                types[i] = 'R';
                        }
                    }
                    for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                        var type = types[i];
                        if (type == '+' && prev == '1' && types[i + 1] == '1')
                            types[i] = '1';
                        else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
                            types[i] = prev;
                        prev = type;
                    }
                    for (var i = 0; i < len; ++i) {
                        var type = types[i];
                        if (type == ',')
                            types[i] = 'N';
                        else if (type == '%') {
                            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
                            }
                            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
                            for (var j = i; j < end; ++j)
                                types[j] = replace;
                            i = end - 1;
                        }
                    }
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (cur == 'L' && type == '1')
                            types[i] = 'L';
                        else if (isStrong.test(type))
                            cur = type;
                    }
                    for (var i = 0; i < len; ++i) {
                        if (isNeutral.test(types[i])) {
                            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
                            }
                            var before = (i ? types[i - 1] : outerType) == 'L';
                            var after = (end < len - 1 ? types[end] : outerType) == 'L';
                            var replace = before || after ? 'L' : 'R';
                            for (var j = i; j < end; ++j)
                                types[j] = replace;
                            i = end - 1;
                        }
                    }
                    var order = [], m;
                    for (var i = 0; i < len;) {
                        if (countsAsLeft.test(types[i])) {
                            var start = i;
                            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
                            }
                            order.push({
                                from: start,
                                to: i,
                                level: 0
                            });
                        } else {
                            var pos = i, at = order.length;
                            for (++i; i < len && types[i] != 'L'; ++i) {
                            }
                            for (var j = pos; j < i;) {
                                if (countsAsNum.test(types[j])) {
                                    if (pos < j)
                                        order.splice(at, 0, {
                                            from: pos,
                                            to: j,
                                            level: 1
                                        });
                                    var nstart = j;
                                    for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                                    }
                                    order.splice(at, 0, {
                                        from: nstart,
                                        to: j,
                                        level: 2
                                    });
                                    pos = j;
                                } else
                                    ++j;
                            }
                            if (pos < i)
                                order.splice(at, 0, {
                                    from: pos,
                                    to: i,
                                    level: 1
                                });
                        }
                    }
                    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                        order[0].from = m[0].length;
                        order.unshift({
                            from: 0,
                            to: m[0].length,
                            level: 0
                        });
                    }
                    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                        lst(order).to -= m[0].length;
                        order.push({
                            from: len - m[0].length,
                            to: len,
                            level: 0
                        });
                    }
                    if (order[0].level != lst(order).level)
                        order.push({
                            from: len,
                            to: len,
                            level: order[0].level
                        });
                    return order;
                };
            }();
        CodeMirror.version = '3.18.1';
        return CodeMirror;
    }();
    amdclean_website['codemirror'] = function () {
    }();
    CodeMirror.defineMode('javascript', function (config, parserConfig) {
        var indentUnit = config.indentUnit;
        var jsonMode = parserConfig.json;
        var isTS = parserConfig.typescript;
        var keywords = function () {
                function kw(type) {
                    return {
                        type: type,
                        style: 'keyword'
                    };
                }
                var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c');
                var operator = kw('operator'), atom = {
                        type: 'atom',
                        style: 'atom'
                    };
                var jsKeywords = {
                        'if': A,
                        'while': A,
                        'with': A,
                        'else': B,
                        'do': B,
                        'try': B,
                        'finally': B,
                        'return': C,
                        'break': C,
                        'continue': C,
                        'new': C,
                        'delete': C,
                        'throw': C,
                        'var': kw('var'),
                        'const': kw('var'),
                        'let': kw('var'),
                        'function': kw('function'),
                        'catch': kw('catch'),
                        'for': kw('for'),
                        'switch': kw('switch'),
                        'case': kw('case'),
                        'default': kw('default'),
                        'in': operator,
                        'typeof': operator,
                        'instanceof': operator,
                        'true': atom,
                        'false': atom,
                        'null': atom,
                        'undefined': atom,
                        'NaN': atom,
                        'Infinity': atom
                    };
                if (isTS) {
                    var type = {
                            type: 'variable',
                            style: 'variable-3'
                        };
                    var tsKeywords = {
                            'interface': kw('interface'),
                            'class': kw('class'),
                            'extends': kw('extends'),
                            'constructor': kw('constructor'),
                            'public': kw('public'),
                            'private': kw('private'),
                            'protected': kw('protected'),
                            'static': kw('static'),
                            'super': kw('super'),
                            'string': type,
                            'number': type,
                            'bool': type,
                            'any': type
                        };
                    for (var attr in tsKeywords) {
                        jsKeywords[attr] = tsKeywords[attr];
                    }
                }
                return jsKeywords;
            }();
        var isOperatorChar = /[+\-*&%=<>!?|]/;
        function chain(stream, state, f) {
            state.tokenize = f;
            return f(stream, state);
        }
        function nextUntilUnescaped(stream, end) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
                if (next == end && !escaped)
                    return false;
                escaped = !escaped && next == '\\';
            }
            return escaped;
        }
        var type, content;
        function ret(tp, style, cont) {
            type = tp;
            content = cont;
            return style;
        }
        function jsTokenBase(stream, state) {
            var ch = stream.next();
            if (ch == '"' || ch == '\'')
                return chain(stream, state, jsTokenString(ch));
            else if (/[\[\]{}\(\),;\:\.]/.test(ch))
                return ret(ch);
            else if (ch == '0' && stream.eat(/x/i)) {
                stream.eatWhile(/[\da-f]/i);
                return ret('number', 'number');
            } else if (/\d/.test(ch) || ch == '-' && stream.eat(/\d/)) {
                stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
                return ret('number', 'number');
            } else if (ch == '/') {
                if (stream.eat('*')) {
                    return chain(stream, state, jsTokenComment);
                } else if (stream.eat('/')) {
                    stream.skipToEnd();
                    return ret('comment', 'comment');
                } else if (state.lastType == 'operator' || state.lastType == 'keyword c' || /^[\[{}\(,;:]$/.test(state.lastType)) {
                    nextUntilUnescaped(stream, '/');
                    stream.eatWhile(/[gimy]/);
                    return ret('regexp', 'string-2');
                } else {
                    stream.eatWhile(isOperatorChar);
                    return ret('operator', null, stream.current());
                }
            } else if (ch == '#') {
                stream.skipToEnd();
                return ret('error', 'error');
            } else if (isOperatorChar.test(ch)) {
                stream.eatWhile(isOperatorChar);
                return ret('operator', null, stream.current());
            } else {
                stream.eatWhile(/[\w\$_]/);
                var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
                return known && state.lastType != '.' ? ret(known.type, known.style, word) : ret('variable', 'variable', word);
            }
        }
        function jsTokenString(quote) {
            return function (stream, state) {
                if (!nextUntilUnescaped(stream, quote))
                    state.tokenize = jsTokenBase;
                return ret('string', 'string');
            };
        }
        function jsTokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
                if (ch == '/' && maybeEnd) {
                    state.tokenize = jsTokenBase;
                    break;
                }
                maybeEnd = ch == '*';
            }
            return ret('comment', 'comment');
        }
        var atomicTypes = {
                'atom': true,
                'number': true,
                'variable': true,
                'string': true,
                'regexp': true
            };
        function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type;
            this.prev = prev;
            this.info = info;
            if (align != null)
                this.align = align;
        }
        function inScope(state, varname) {
            for (var v = state.localVars; v; v = v.next)
                if (v.name == varname)
                    return true;
        }
        function parseJS(state, style, type, content, stream) {
            var cc = state.cc;
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            if (!state.lexical.hasOwnProperty('align'))
                state.lexical.align = true;
            while (true) {
                var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                if (combinator(type, content)) {
                    while (cc.length && cc[cc.length - 1].lex)
                        cc.pop()();
                    if (cx.marked)
                        return cx.marked;
                    if (type == 'variable' && inScope(state, content))
                        return 'variable-2';
                    return style;
                }
            }
        }
        var cx = {
                state: null,
                column: null,
                marked: null,
                cc: null
            };
        function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
                cx.cc.push(arguments[i]);
        }
        function cont() {
            pass.apply(null, arguments);
            return true;
        }
        function register(varname) {
            var state = cx.state;
            if (state.context) {
                cx.marked = 'def';
                for (var v = state.localVars; v; v = v.next)
                    if (v.name == varname)
                        return;
                state.localVars = {
                    name: varname,
                    next: state.localVars
                };
            }
        }
        var defaultVars = {
                name: 'this',
                next: { name: 'arguments' }
            };
        function pushcontext() {
            cx.state.context = {
                prev: cx.state.context,
                vars: cx.state.localVars
            };
            cx.state.localVars = defaultVars;
        }
        function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
        }
        function pushlex(type, info) {
            var result = function () {
                var state = cx.state;
                state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
            };
            result.lex = true;
            return result;
        }
        function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
                if (state.lexical.type == ')')
                    state.indented = state.lexical.indented;
                state.lexical = state.lexical.prev;
            }
        }
        poplex.lex = true;
        function expect(wanted) {
            return function expecting(type) {
                if (type == wanted)
                    return cont();
                else if (wanted == ';')
                    return pass();
                else
                    return cont(arguments.callee);
            };
        }
        function statement(type) {
            if (type == 'var')
                return cont(pushlex('vardef'), vardef1, expect(';'), poplex);
            if (type == 'keyword a')
                return cont(pushlex('form'), expression, statement, poplex);
            if (type == 'keyword b')
                return cont(pushlex('form'), statement, poplex);
            if (type == '{')
                return cont(pushlex('}'), block, poplex);
            if (type == ';')
                return cont();
            if (type == 'function')
                return cont(functiondef);
            if (type == 'for')
                return cont(pushlex('form'), expect('('), pushlex(')'), forspec1, expect(')'), poplex, statement, poplex);
            if (type == 'variable')
                return cont(pushlex('stat'), maybelabel);
            if (type == 'switch')
                return cont(pushlex('form'), expression, pushlex('}', 'switch'), expect('{'), block, poplex, poplex);
            if (type == 'case')
                return cont(expression, expect(':'));
            if (type == 'default')
                return cont(expect(':'));
            if (type == 'catch')
                return cont(pushlex('form'), pushcontext, expect('('), funarg, expect(')'), statement, poplex, popcontext);
            return pass(pushlex('stat'), expression, expect(';'), poplex);
        }
        function expression(type) {
            if (atomicTypes.hasOwnProperty(type))
                return cont(maybeoperator);
            if (type == 'function')
                return cont(functiondef);
            if (type == 'keyword c')
                return cont(maybeexpression);
            if (type == '(')
                return cont(pushlex(')'), maybeexpression, expect(')'), poplex, maybeoperator);
            if (type == 'operator')
                return cont(expression);
            if (type == '[')
                return cont(pushlex(']'), commasep(expression, ']'), poplex, maybeoperator);
            if (type == '{')
                return cont(pushlex('}'), commasep(objprop, '}'), poplex, maybeoperator);
            return cont();
        }
        function maybeexpression(type) {
            if (type.match(/[;\}\)\],]/))
                return pass();
            return pass(expression);
        }
        function maybeoperator(type, value) {
            if (type == 'operator' && /\+\+|--/.test(value))
                return cont(maybeoperator);
            if (type == 'operator' && value == '?')
                return cont(expression, expect(':'), expression);
            if (type == ';')
                return;
            if (type == '(')
                return cont(pushlex(')'), commasep(expression, ')'), poplex, maybeoperator);
            if (type == '.')
                return cont(property, maybeoperator);
            if (type == '[')
                return cont(pushlex(']'), expression, expect(']'), poplex, maybeoperator);
        }
        function maybelabel(type) {
            if (type == ':')
                return cont(poplex, statement);
            return pass(maybeoperator, expect(';'), poplex);
        }
        function property(type) {
            if (type == 'variable') {
                cx.marked = 'property';
                return cont();
            }
        }
        function objprop(type) {
            if (type == 'variable')
                cx.marked = 'property';
            if (atomicTypes.hasOwnProperty(type))
                return cont(expect(':'), expression);
        }
        function commasep(what, end) {
            function proceed(type) {
                if (type == ',')
                    return cont(what, proceed);
                if (type == end)
                    return cont();
                return cont(expect(end));
            }
            return function commaSeparated(type) {
                if (type == end)
                    return cont();
                else
                    return pass(what, proceed);
            };
        }
        function block(type) {
            if (type == '}')
                return cont();
            return pass(statement, block);
        }
        function maybetype(type) {
            if (type == ':')
                return cont(typedef);
            return pass();
        }
        function typedef(type) {
            if (type == 'variable') {
                cx.marked = 'variable-3';
                return cont();
            }
            return pass();
        }
        function vardef1(type, value) {
            if (type == 'variable') {
                register(value);
                return isTS ? cont(maybetype, vardef2) : cont(vardef2);
            }
            return pass();
        }
        function vardef2(type, value) {
            if (value == '=')
                return cont(expression, vardef2);
            if (type == ',')
                return cont(vardef1);
        }
        function forspec1(type) {
            if (type == 'var')
                return cont(vardef1, expect(';'), forspec2);
            if (type == ';')
                return cont(forspec2);
            if (type == 'variable')
                return cont(formaybein);
            return cont(forspec2);
        }
        function formaybein(type, value) {
            if (value == 'in')
                return cont(expression);
            return cont(maybeoperator, forspec2);
        }
        function forspec2(type, value) {
            if (type == ';')
                return cont(forspec3);
            if (value == 'in')
                return cont(expression);
            return cont(expression, expect(';'), forspec3);
        }
        function forspec3(type) {
            if (type != ')')
                cont(expression);
        }
        function functiondef(type, value) {
            if (type == 'variable') {
                register(value);
                return cont(functiondef);
            }
            if (type == '(')
                return cont(pushlex(')'), pushcontext, commasep(funarg, ')'), poplex, statement, popcontext);
        }
        function funarg(type, value) {
            if (type == 'variable') {
                register(value);
                return isTS ? cont(maybetype) : cont();
            }
        }
        return {
            startState: function (basecolumn) {
                return {
                    tokenize: jsTokenBase,
                    lastType: null,
                    cc: [],
                    lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),
                    localVars: parserConfig.localVars,
                    context: parserConfig.localVars && { vars: parserConfig.localVars },
                    indented: 0
                };
            },
            token: function (stream, state) {
                if (stream.sol()) {
                    if (!state.lexical.hasOwnProperty('align'))
                        state.lexical.align = false;
                    state.indented = stream.indentation();
                }
                if (stream.eatSpace())
                    return null;
                var style = state.tokenize(stream, state);
                if (type == 'comment')
                    return style;
                state.lastType = type;
                return parseJS(state, style, type, content, stream);
            },
            indent: function (state, textAfter) {
                if (state.tokenize == jsTokenComment)
                    return CodeMirror.Pass;
                if (state.tokenize != jsTokenBase)
                    return 0;
                var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                if (lexical.type == 'stat' && firstChar == '}')
                    lexical = lexical.prev;
                var type = lexical.type, closing = firstChar == type;
                if (type == 'vardef')
                    return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? 4 : 0);
                else if (type == 'form' && firstChar == '{')
                    return lexical.indented;
                else if (type == 'form')
                    return lexical.indented + indentUnit;
                else if (type == 'stat')
                    return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? indentUnit : 0);
                else if (lexical.info == 'switch' && !closing)
                    return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                else if (lexical.align)
                    return lexical.column + (closing ? 0 : 1);
                else
                    return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricChars: ':{}',
            jsonMode: jsonMode
        };
    });
    CodeMirror.defineMIME('text/javascript', 'javascript');
    CodeMirror.defineMIME('application/json', {
        name: 'javascript',
        json: true
    });
    CodeMirror.defineMIME('text/typescript', {
        name: 'javascript',
        typescript: true
    });
    CodeMirror.defineMIME('application/typescript', {
        name: 'javascript',
        typescript: true
    });
    amdclean_website['codemirror_javascript'] = function () {
    }();
    (function () {
        var DEFAULT_BRACKETS = '()[]{}\'\'""';
        var DEFAULT_EXPLODE_ON_ENTER = '[]{}';
        var SPACE_CHAR_REGEX = /\s/;
        CodeMirror.defineOption('autoCloseBrackets', false, function (cm, val, old) {
            if (old != CodeMirror.Init && old)
                cm.removeKeyMap('autoCloseBrackets');
            if (!val)
                return;
            var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;
            if (typeof val == 'string')
                pairs = val;
            else if (typeof val == 'object') {
                if (val.pairs != null)
                    pairs = val.pairs;
                if (val.explode != null)
                    explode = val.explode;
            }
            var map = buildKeymap(pairs);
            if (explode)
                map.Enter = buildExplodeHandler(explode);
            cm.addKeyMap(map);
        });
        function charsAround(cm, pos) {
            var str = cm.getRange(CodeMirror.Pos(pos.line, pos.ch - 1), CodeMirror.Pos(pos.line, pos.ch + 1));
            return str.length == 2 ? str : null;
        }
        function buildKeymap(pairs) {
            var map = {
                    name: 'autoCloseBrackets',
                    Backspace: function (cm) {
                        if (cm.somethingSelected())
                            return CodeMirror.Pass;
                        var cur = cm.getCursor(), around = charsAround(cm, cur);
                        if (around && pairs.indexOf(around) % 2 == 0)
                            cm.replaceRange('', CodeMirror.Pos(cur.line, cur.ch - 1), CodeMirror.Pos(cur.line, cur.ch + 1));
                        else
                            return CodeMirror.Pass;
                    }
                };
            var closingBrackets = '';
            for (var i = 0; i < pairs.length; i += 2)
                (function (left, right) {
                    if (left != right)
                        closingBrackets += right;
                    function surround(cm) {
                        var selection = cm.getSelection();
                        cm.replaceSelection(left + selection + right);
                    }
                    function maybeOverwrite(cm) {
                        var cur = cm.getCursor(), ahead = cm.getRange(cur, CodeMirror.Pos(cur.line, cur.ch + 1));
                        if (ahead != right || cm.somethingSelected())
                            return CodeMirror.Pass;
                        else
                            cm.execCommand('goCharRight');
                    }
                    map['\'' + left + '\''] = function (cm) {
                        if (left == '\'' && cm.getTokenAt(cm.getCursor()).type == 'comment')
                            return CodeMirror.Pass;
                        if (cm.somethingSelected())
                            return surround(cm);
                        if (left == right && maybeOverwrite(cm) != CodeMirror.Pass)
                            return;
                        var cur = cm.getCursor(), ahead = CodeMirror.Pos(cur.line, cur.ch + 1);
                        var line = cm.getLine(cur.line), nextChar = line.charAt(cur.ch), curChar = cur.ch > 0 ? line.charAt(cur.ch - 1) : '';
                        if (left == right && CodeMirror.isWordChar(curChar))
                            return CodeMirror.Pass;
                        if (line.length == cur.ch || closingBrackets.indexOf(nextChar) >= 0 || SPACE_CHAR_REGEX.test(nextChar))
                            cm.replaceSelection(left + right, {
                                head: ahead,
                                anchor: ahead
                            });
                        else
                            return CodeMirror.Pass;
                    };
                    if (left != right)
                        map['\'' + right + '\''] = maybeOverwrite;
                }(pairs.charAt(i), pairs.charAt(i + 1)));
            return map;
        }
        function buildExplodeHandler(pairs) {
            return function (cm) {
                var cur = cm.getCursor(), around = charsAround(cm, cur);
                if (!around || pairs.indexOf(around) % 2 != 0)
                    return CodeMirror.Pass;
                cm.operation(function () {
                    var newPos = CodeMirror.Pos(cur.line + 1, 0);
                    cm.replaceSelection('\n\n', {
                        anchor: newPos,
                        head: newPos
                    }, '+input');
                    cm.indentLine(cur.line + 1, null, true);
                    cm.indentLine(cur.line + 2, null, true);
                });
            };
        }
    }());
    amdclean_website['codemirror_closebrackets'] = function () {
    }();
    (function () {
        var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
        var Pos = CodeMirror.Pos;
        var matching = {
                '(': ')>',
                ')': '(<',
                '[': ']>',
                ']': '[<',
                '{': '}>',
                '}': '{<'
            };
        function findMatchingBracket(cm, where, strict) {
            var state = cm.state.matchBrackets;
            var maxScanLen = state && state.maxScanLineLength || 10000;
            var cur = where || cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;
            var match = pos >= 0 && matching[line.text.charAt(pos)] || matching[line.text.charAt(++pos)];
            if (!match)
                return null;
            var forward = match.charAt(1) == '>', d = forward ? 1 : -1;
            if (strict && forward != (pos == cur.ch))
                return null;
            var style = cm.getTokenTypeAt(Pos(cur.line, pos + 1));
            var stack = [line.text.charAt(pos)], re = /[(){}[\]]/;
            function scan(line, lineNo, start) {
                if (!line.text)
                    return;
                var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;
                if (line.text.length > maxScanLen)
                    return null;
                if (start != null)
                    pos = start + d;
                for (; pos != end; pos += d) {
                    var ch = line.text.charAt(pos);
                    if (re.test(ch) && cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style) {
                        var match = matching[ch];
                        if (match.charAt(1) == '>' == forward)
                            stack.push(ch);
                        else if (stack.pop() != match.charAt(0))
                            return {
                                pos: pos,
                                match: false
                            };
                        else if (!stack.length)
                            return {
                                pos: pos,
                                match: true
                            };
                    }
                }
            }
            for (var i = cur.line, found, e = forward ? Math.min(i + 100, cm.lineCount()) : Math.max(-1, i - 100); i != e; i += d) {
                if (i == cur.line)
                    found = scan(line, i, pos);
                else
                    found = scan(cm.getLineHandle(i), i);
                if (found)
                    break;
            }
            return {
                from: Pos(cur.line, pos),
                to: found && Pos(i, found.pos),
                match: found && found.match,
                forward: forward
            };
        }
        function matchBrackets(cm, autoclear) {
            var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
            var found = findMatchingBracket(cm);
            if (!found || cm.getLine(found.from.line).length > maxHighlightLen || found.to && cm.getLine(found.to.line).length > maxHighlightLen)
                return;
            var style = found.match ? 'CodeMirror-matchingbracket' : 'CodeMirror-nonmatchingbracket';
            var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), { className: style });
            var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), { className: style });
            if (ie_lt8 && cm.state.focused)
                cm.display.input.focus();
            var clear = function () {
                cm.operation(function () {
                    one.clear();
                    two && two.clear();
                });
            };
            if (autoclear)
                setTimeout(clear, 800);
            else
                return clear;
        }
        var currentlyHighlighted = null;
        function doMatchBrackets(cm) {
            cm.operation(function () {
                if (currentlyHighlighted) {
                    currentlyHighlighted();
                    currentlyHighlighted = null;
                }
                if (!cm.somethingSelected())
                    currentlyHighlighted = matchBrackets(cm, false);
            });
        }
        CodeMirror.defineOption('matchBrackets', false, function (cm, val, old) {
            if (old && old != CodeMirror.Init)
                cm.off('cursorActivity', doMatchBrackets);
            if (val) {
                cm.state.matchBrackets = typeof val == 'object' ? val : {};
                cm.on('cursorActivity', doMatchBrackets);
            }
        });
        CodeMirror.defineExtension('matchBrackets', function () {
            matchBrackets(this, true);
        });
        CodeMirror.defineExtension('findMatchingBracket', function (pos, strict) {
            return findMatchingBracket(this, pos, strict);
        });
    }());
    amdclean_website['codemirror_matchbrackets'] = function () {
    }();
    amdclean_website['views_View'] = function ($, Backbone, _, amdclean, esprima, codemirror_javascript, codemirror_closebrackets, codemirror_matchbrackets) {
        var View = Backbone.View.extend({
                el: 'body',
                initialize: function () {
                    var urlCode = this.getParameter('code');
                    this.amdTextarea = $('#amd-textarea');
                    this.standardTextarea = $('#standard-textarea');
                    this.autoRunJS = $('#auto-run-checkbox');
                    this.globalObject = $('#global-object-checkbox');
                    this.standardTextarea.val(amdclean.clean({
                        'code': this.amdTextarea.val(),
                        'globalObject': this.globalObject.is(':checked') ? true : false,
                        'rememberGlobalObject': false
                    }));
                    this.amdEditor = CodeMirror.fromTextArea(document.getElementById('amd-textarea'), {
                        mode: 'javascript',
                        tabMode: 'indent',
                        lineNumbers: true,
                        matchBrackets: true,
                        theme: 'xq-light',
                        autoCloseBrackets: true
                    });
                    this.standardEditor = CodeMirror.fromTextArea(document.getElementById('standard-textarea'), {
                        mode: 'javascript',
                        tabMode: 'indent',
                        lineNumbers: true,
                        readOnly: true,
                        cursorHeight: 0
                    });
                    this.amdEditor.on('change', _.bind(function () {
                        if (this.autoRunJS.is(':checked')) {
                            this.optimizeCode();
                        }
                    }, this));
                    this.codeError = $('.code-error');
                    this.linkToShare = $('#link-to-share');
                    this.linkToShareContainer = $('.link-to-share-container');
                    if (urlCode) {
                        this.amdEditor.setValue(window.escodegen.generate(esprima.parse(decodeURIComponent(urlCode))));
                    }
                },
                events: {
                    'click .clean-btn': 'optimizeCode',
                    'click #global-object-checkbox': 'optimizeCode',
                    'change #auto-run-checkbox': 'autorun',
                    'click .restore-to-defaults': 'restoreToDefaults',
                    'click a[href=#]': function (e) {
                        e.preventDefault();
                    }
                },
                optimizeCode: function () {
                    try {
                        var cleanedCode = amdclean.clean({
                                'code': $.trim(this.amdEditor.getValue()),
                                'globalObject': this.globalObject.is(':checked') ? true : false,
                                'rememberGlobalObject': false
                            });
                        this.standardEditor.setValue(cleanedCode);
                        this.codeError.empty().hide();
                        this.linkToShare.val(this.buildURL());
                        this.linkToShareContainer.fadeIn();
                    } catch (e) {
                        if (e.lineNumber && e.column && e.description) {
                            this.codeError.html('Description: ' + e.description + '<br><br>Line Number: ' + e.lineNumber + '<br><br>Column: ' + e.column).show();
                            this.standardEditor.setValue('');
                        }
                    }
                },
                getParameter: function (paramName) {
                    var searchString = window.location.search.substring(1), i, val, params = searchString.split('&');
                    for (i = 0; i < params.length; i++) {
                        val = params[i].split('=');
                        if (val[0] == paramName) {
                            return val[1];
                        }
                    }
                    return null;
                },
                autorun: function () {
                    if (this.autoRunJS.is(':checked')) {
                        this.optimizeCode();
                    }
                },
                buildURL: function () {
                    return location.protocol + '//' + location.host + location.pathname + '?code=' + encodeURIComponent(this.amdEditor.getValue());
                },
                restoreToDefaults: function () {
                    this.amdEditor.setValue(window.escodegen.generate(esprima.parse(decodeURIComponent(this.defaultAMDCode))));
                },
                defaultAMDCode: 'define(\'example\', [], function() {return \'Convert AMD code to standard JavaScript\';});'
            });
        return View;
    }(amdclean_website['jquery'], amdclean_website['backbone'], amdclean_website['underscore'], amdclean_website['amdclean'], amdclean_website['esprima'], amdclean_website['codemirror_javascript'], amdclean_website['codemirror_closebrackets'], amdclean_website['codemirror_matchbrackets']);
    amdclean_website['routers_router'] = function ($, Backbone, View) {
        var Router = Backbone.Router.extend({
                initialize: function () {
                    Backbone.history.start();
                },
                routes: { '': 'index' },
                index: function () {
                    new View();
                }
            });
        return Router;
    }(amdclean_website['jquery'], amdclean_website['backbone'], amdclean_website['views_View']);
    (function ($, Backbone, MobileRouter) {
        new MobileRouter();
    }(amdclean_website['jquery'], amdclean_website['backbone'], amdclean_website['routers_router']));
    amdclean_website['mobile'] = function () {
    }();
}());